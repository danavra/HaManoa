<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2015A\aibgu2015a---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
מבחן  ב"ישומי בינה מלאכותית"  372.1.3502
מועד א.    01/2/2014
מרצה: פרופסור אריאל פלנר
מתרגל: מר גוני שרון
משך המבחן שעתיים וחצי

יש לענות כל השאלות. 
ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים

שאלה 1 (חובה) : מושגים  (16 נקודות)

הסבירו בקצרה (לא יותר מכמה משפטים) 4 מתוך 5 המושגים הבאים.
Discounted-reward MDP
שלוש קטגוריות של Multi-agent Systems (משפט על כל אחת)
Casual Link
Eliza
Explore vs. Exploit
כפי שנלמד

שאלה 2:  רזולוציה (21 נקודות)
ידועים הפרטים הבאים
דני חכם
משה גבוה ומפחד מצביקה
צביקה הוא חכם או גבוה 
צביקה מפחד מדני

בטאו את א'-ה' כפסוק בתחשיב הפסוקים. 
      השתמשו בפרדיקטים Afraid(x,y)  Smart(x)  Tall(x) 
Smart(Dany)
Tall(Moshe) and Afriad(Moshe,Zvitka)
Smart(Zvika)  or Tall (Zvika)
Afriad(Zvika, Danny)
הפכו ל- clausal form  

רק משפט 2 הופך לשני עובדות: 2a) Tall(Moshe) 2b) Afriad(Moshe,Zvitka)

הוכיחו כי קיים מישהו גבוה המפחד ממישהו חכם

Exist X ,Exist Y Tall(x) and Smart(y) and Afaird (X,y) 

נשלול ונהפוך לclosal form:

Smart(Dany)
Tall(Moshe) 
Afriad(Moshe,Zvitka)
Smart(Zvika)  , Tall (Zvika)
Afriad(Zvika, Danny)
Not(Tall(X)) , Not Smart(y), not(Afriad(X,y)
7. 6+3) not tall(Moshe), not smart(Zvika)
8. 7+2) not smart(Zvika)
9. 8+4) tall(Zvika)
10. 5+6) not tall(Zvika), not smart(Danny)
11) 10+1) not Tall(Zvika)
12) (11+9) Contradiction.
 



שאלה 3: השוואה בין אלגוריתמי חיפוש (21 נק')

ארבעה קריטריונים הוגדרו לצורך השוואה בין אסטרטגיות חיפוש: שלמות, אופטימאליות, סיבוכיות זמן ריצה וסיבוכיות זכרון. עבור כל אחד מהמשפטים הבאים ציינו את הקריטריון המסביר בצורה הטובה ביותר את הטענה הנאמרת בו. שימו לב – יש לציין קריטריון אחד מתוך הארבעה בכל משפט. הניחו שמרחב החיפוש סופי.
Iterative-Deepening Search  בדרך כלל עדיף על Breadth-First Search.

זכרון
Iterative-Deepening Search  בדרך כלל עדיף עלDepth-First Search .

שלמות

אלפא-ביטא עדיף בדרך כלל על מינמקס.

זמן
A* Search עדיף בדרך כלל על חיפוש חמדן

אופטימליות
Search breadth first  Bidirectional בדרך כלל עדיף על
 Single direction Breadth-First Search (סעיף בונוס)

זכרון, זמן


 (
א
ב
ג
3
2
1
8
A
B
42
111
5
C
2
5
0
7
2
MAX
min
)

נתון עץ המשחק הבא



 (
MAX
)
עבור אלו ערכי A אלגוריתם     לא יפתח את קודקוד B ? 
עבור כל A<3
עבור כל A<8
עבור כל A≥3
עבור כל A≥8
כל ערך של A
תמיד נפתח את B	

בהנחה שאף צומת לא נגזם בתת העץ ב', מהו הערך המקסימאלי של C שיגרום שתת העץ ג' ייגזם?
1	
3
4
5
9
לעולם לא נגזום את תת-עץ ג


 (4) (21 נק')
נניח שיש לנו היפוטזת סיווג שמסווגת את כל תצפיות האימון. נניח גם שתצפיות האימון לקוחות מאותה התפלגות כמו בעולם האמיתי. הוכיחו במדוייק שע"מ שההיפוטזה לא תטעה בסיכוי גבוה מ  בוודאות קטנה מ  עלינו לאמן אותה ב m תצפיות, כאשר:           m  1/(ln 1/ + ln |H|)

				(5) (21 נק')
כידוע ניתן לייצג בעיות רבות כבעיית סיפוק אילוצים. הראו כיצד ניתן למדל את בעיית מציאת מסלול על גרף כ CSP.
בעיית מציאת מסלול על גרף: בהינתן גרף לא ממושקל G(V,E), קודקוד התחלה s, קודקוד סיום g, ומספר צעדים k, צריך להחזיר מסלול העובר ב k קודקודים ובמוביל מנקודת ההתחלה לנקודת הסיום.
ציינו מיהם המשתנים מה הדומיין של כל משתנה ומה האילוצים.
משתנים:
t0,t1,…,tk משתנה עבור כל נקודת זמן.

דומיין:
הדומיין של כל המשתנים זהה ושווה לקבוצת הקודקודים V בגרף

אילוצים:
t0=s
tk=g
הקודקודים בהשמה של כל זוג משתנים ti,t(i+1) חייבים ליהיות שכנים לפי G

 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2015B\aibgu2015b---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
מבחן  ב"ישומי בינה מלאכותית"  372.1.3502
מועד ב.    24/2/2014
מרצה: פרופסור אריאל פלנר
מתרגל: מר גוני שרון
משך המבחן שעתיים וחצי

יש לענות כל השאלות. 
ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים

שאלה 1  : מושגים  (16 נקודות)

הסבירו בקצרה (לא יותר מכמה משפטים) 4 מתוך 5 המושגים הבאים.
מבחן טיורינג. (נא לתת הגדרה מדויקת)
Hill climbing
Simple reflex agent
e-greedy
KNN
כפי שנלמד בכיתה

שאלה 2:  חיפוש (21 נקודות)
בעיית הטנק - הטנק יכול לנוע קדימה בלבד או לשנות את הצידוד (זווית אליה פונה). ביחידת זמן אחת ניתן לנוע צעד אחד קדימה או להסתובב 90 מעלות. 
בהינתן:
- 4-connected grid  
- נקודת התחלה (על ה GRID)
- צידוד התחלתי של הטנק
יש למצוא סדרת פעולות (סיבוב, תנועה קדימה) שיובילו את הטנק מהמצב ההתחלתי למצב סופי רצוי.
מדלו את בעיית הטנק כבעיית חיפוש, הגדירו:
א. מצב (במרחב החיפוש) 
1. מיקום הטנק
2. צידוד
ב. אופרטורים (כיצד לייצר מצבים שכנים למצב נתון)
1. סע קדימה
2. צדד 90 ימינה
3. צדד 90 שמאלה
ג. נניח שבחלק מהתאים של ה GRID יש כביש סלול ובחלק יש בוץ. בתנועה על כביש סלול הטנק יכול לעבור 2 תאים ביחידת זמן אחת ובתנועה בבוץ נדרשים 2 יחידות זמן ע"מ לעבור תא אחד. הציעו היוריסטיקה אדמיסיבילית וקונסיסטנטית לבעיה זו שתהא מדוייקת ככל שניתן ולוקחת בחשבון את מירב אילוצי הבעיה (ניקוד יינתן לפי רמת הדיוק של הפונקציה)
מרחק מנהטן חלקי 2

שאלה 3: MDP (21 נק')

בכל שנה חברת "תפוח" יכולה להיות במצב "חדשני" או "מיושן". בנוסף, בכל שנה החברה בוחרת במה להשקיע, מחקר או פרסום. הרווח שלה מהבחירה תלויה במידת החדשנות שלה ונתונה בטבלה הבאה:

כש"תפוח" מיושנת יש סיכוי של 0.9 שתהפוך לחדשנית בשנה הבאה אם תשקיע במחקר וסיכוי של 0.1 אם תשקיע בפרסום.
כש"תפוח" חדשנית יש סיכוי של 0.1 שתהפוך למיושנת בשנה הבאה אם תשקיע במחקר וסיכוי 0.9 אם תשקיע בפרסום.
א. מדלו את הבעיה כבעיית MDP. הגדירו: מרחב מצבים, סט אופרטורים, פונקציות מעבר, פונקציות פרס (reward function).
מצבים: חדשנית (N), מיושנת  (O) 
אופרטורים: מחקר (R), פרסום (P)
פונקציות מעבר:
T(N,R,N)=0.9
T(N,P,N)=0.1
T(N,R,O)=0.1
T(N,P,O)=0.9
T(O,R,N)=0.9
T(O,P,N)=0.1
T(O,R,O)=0.1
T(O,P,O)=0.9
פונקציות פרס כמפורט בנתוני השאלה (טבלה)


ב. פתרו את הבעיה בעזרת 2 איטרציות של value iteration. הניחו =0.5 כלומר, הראו את הUtility  של כל מצב אחרי כל איטרציה בטבלה כזו




 (4) (21 נק')
א)  נתון עץ משחק בינארי מאוזן בגובה 4. ערכי העלים הם:  
ימין-->   5,6,4,3,7,8,9,10,13,14,15,15,2,11,3,12<--  שמאל
בצעו סריקת אלפא-ביתא משמאל לימין. (הניחו שהשחקן בשורש הוא שחקן המקסימום)
מה הערך שהתקבל בשורש? 5
אילו תתי עצים נגזמו?  העלים הבאים3, (9,10), 11, 12 
כדי לבצע צעד במשחק על השחקן להטיל קוביה. אם יצא אי זוגי (1,3,5) יש לו שלשה מהלכים אפשריים שערכם 4, 5 ו10 . אם יצא 2 או  4  יש לו שני מהלכים אפשריים שערכם 4, 8. אם יצא 6 יש לו שלשה מהלכים אפשריים שערכם  5,7,9ציירו את עץ הexpectimax  המתאים וחשבו את הערך של השורש כאשר 
השחקן הוא שחקן המקסימום.  9.166
השחקן הוא שחקן המינימום 4.166 

ג)   בוריס ומיטל משחקים אחד נגד השני. אנו מניחים כי יש להם את אותן פונקציות ההערכה וכי הם נוהגים בהגיון (לא עושים טעויות ו\או שטויות). בוריס (שחקן המקסימום) פרש עץ משחק מלא (כל העלים הם קודקודים טרמינליים בהם המשחק הסתיים) וקיבל 4 בשורש.
          1) מה תוכלו להגיד לו אם המשחק היה אותלו   (Othello)
יקבל לפחות 4
מה תוכלו להגיד לו אם המשחק היה שש-בש

בממוצע יקבל לפחות 4
				(5) (21 נק')
ידועים הפרטים הבאים
יונדאי אמינה
פורד חסכונית ויותר מהירה ממאזדה
מאזדה  הוא אמינה  או חסכונית
מאזדה  יותר מהירה מיונדאי

בטאו את א'-ה' כפסוק בתחשיב הפסוקים. 
      השתמשו בפרדיקטים Faster(x,y)  Amina(x)  Cheap(x) 

Amina (Yunday)
Cheap (Ford) and Faster (Ford,Mazda)
Amina (Mazda)  or Cheap (Mazda)
Faster (Mazda, Yunday)
הפכו ל- clausal form  

רק משפט 2 הופך לשני עובדות: 2a) Cheap (Ford) 2b) Faster (Ford,Mazda)

הוכיחו כי קיימת מכונית חסכונית המהירה יותר ממכונית אמינה

Exist X ,Exist Y Cheap (x) and Amina (y) and Faster (x,y) 

נשלול ונהפוך לclosal form:

Amina (Yunday)
Cheap (Ford)
Faster (Ford,Mazda)
Amina (Mazda)  , Cheap (Mazda)
Faster (Mazda, Yunday)
Not Cheap (x), Not Amina (y), not Faster (x,y)
7. 6+3) not Cheap(Ford), not Amina (Mazda)
8. 7+2) not Amina (Mazda)
9. 8+4) Cheap (Mazda)
10. 5+6) not Cheap(Mazda), not Amina (Yunday)
11) 10+1) not Cheap(Mazda)
12) (11+9) Contradiction.
 




 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2016A\aibgu2016a---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
מבחן  ב"ישומי בינה מלאכותית"  372.1.3502
מועד א.    11/2/2016
מרצה: פרופסור אריאל פלנר
מתרגל: מר דור עצמון
משך המבחן שעתיים וחצי

יש לענות כל השאלות. 
ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים


שאלה 1:  מושגים  (16 נקודות)

הסבירו בקצרה (לא יותר מכמה משפטים) 4 מתוך 5 המושגים הבאים.
Goal-based  MDP
Ant robotics
Delete Relaxation/Ignore delete list
Nash Equilibrium
Explore vs. Exploit
כפי שנלמד בהרצאה










שאלה 2:  רזולוציה (21 נקודות)
ידועים הפרטים הבאים:
כל אדם גר בישראל או גר בחו”ל (אך לא בשניהם)
אם אדם מגדל קוף הוא לא גר בישראל
אבי מגדל קוף
רון גר בישראל

בטאו את א'-ד' כפסוק בתחשיב הפסוקים. 
      השתמשו בפרדיקטים Israel(x,)  Abroad(x)  Monkey(x) 
הפכו ל- clausal form  

הוכיחו  שרון לא גר בחול ואבי כן גר בחו"ל.


א.


ב.


ג.









שאלה 3:  חיפוש (21 נקודות)


TopSpin Puzzle, הינו משחק המורכב משני חלקים:
טבעת חיצונית, המכילה 20 דיסקיות הממוספרות מ-1 עד 20.
טבעת פנימית, המכילה 4 מהדיסקיות של הטבעת החיצונית.

אופרטור 1 (OP1): את הדיסקיות בטבעת החיצונית ניתן להזיז במעגל כך שהפרמוטציה נשארת אבל מסתובבת (עד 19 אפשרויות לסיבוב). 
אופרטור 2  (OP2): את הטבעת הפנימית ניתן לסובב כך שסדר הדיסקיות בה יתהפך (לדוגמא: בתמונה המצורפת ניתן לסובב את הטבעת הפנימית כך שסדר הדיסקיות בה יתהפך מ-19,20,1,2 ל-2,1,20,19). 
מצב סופי הינו מצב שבו הפרמוטציה המעגלית היא של מספרים עוקבים כאשר 1  ו-20 נמצאים באמצע (בדיוק כמו בתמונה).
הגדירו היוריסטיקה אדמיסבילית לכל אחד מהמקרים הבאים:
OP1 נעשה בחינם (ללא עלות), רק OP2 מחירו 1.
OP1 מחירו 1 (לכל אורך הסיבוב - סיבוב של יותר ממקום 1), OP2 מחירו 1.
OP1 מחירו כמספר המקומות שהגלגל הסתובב, OP2 מחירו 1.

נגדיר:
שכנים סופיים – שכנים של המצב הסופי.
Gap – מספר השכנים שאינם שכנים סופיים.




אם ניתן לסדר את האיברים הצדדיים (בטבעת הפנימית) של המצב ע"י סיבוב הטבעת הפנימית: h2--


x1- מרחק מהשכנים הלא סופיים הרחוקים ביותר כאשר מסובב עם כיוון השעון  + המרחק מדיסקית 19.
x2- מרחק מהשכנים הלא סופיים הרחוקים ביותר כאשר מסובב נגד כיוון השעון + המרחק מדיסקית 2.


שאלה 4:  משחקים (21 נק')

כדי לבצע צעד במשחק על השחקן להטיל קוביה הוגנת ולאחר מכן לשחק את תורו. אם יצא זוגי (2,4,6) יש לו שלשה מהלכים אפשריים שערכם 6, 8 ו-12 . אם יצא 3 או 5 יש לו שני מהלכים אפשריים שערכם 6, 18. אם יצא 1 יש לו שלשה מהלכים אפשריים שערכם  6,12,24. ציירו את עץ ה-expectimax  המתאים וחשבו את הערך של השורש כאשר השחקן הוא שחקן המקסימום.

נניח וכעת בדקנו וגילינו כי הקוביה איננה הוגנת וכי הסיכויים שייצאו 1,2,3,4,5 שווים אך הסיכוי שיצא 6 גדול פי 7 (כלומר, הסיכוי שיצא 6 גדול פי 7 מכל ערך אחר, למשל: יש סיכוי פי 7 גדול יותר שיצא 6 מאשר שיצא 1), ציירו את עץ ה-expectimax המתאים וחשבו את הערך של השורש כאשר השחקן הוא שחקן המקסימום.

ללא קשר לסעיפים א' ו-ב'.
נתון העץ הבא:



סמנו את התשובה הנכונה.
בהנחה ש- 7=E, בעבור אילו ערכים של A,B,C,D אלגוריתם  לא יפתח את קודקוד E?
A=4,B=6,C=5,D=4
A=9,B=1,C=1,D=8
A=7,B=5,C=8,D=4
A=8,B=8,C=7,D=7









ג.




שאלה 5:  למידה (21 נק')
נתון מדגם מתוייג (training set) בו לכל דגימה יש 3 מאפיינים: משקל, גובה ושימוש בקרם הגנה מפני השמש. לכל אחד משלושת המאפיינים יש שני ערכים אפשריים. בוחרים להפעיל את אלגוריתם  ID3 על נתונים אלו.
רשום ערכי ה- Information Gain של המאפיינים )3 ספרות אחרי הנקודה). 

איזה מאפיין יבחר להיות בשורש העץ (הקף בעיגול)?
  Lotion/ Height /  Weight 

נניח שאני רוצה היפותזה שתטעה בלא יותר מ10% מהמקרים בודאות של 95%. כמה דגימות מבעיה הנ"ל עלי לקחת? נמקו

 -  PAC





Lotion



עלינו לקחת לפחות 86 דגימות.
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2016B\aibgu2016b---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
מבחן  ב"ישומי בינה מלאכותית"  372.1.3502
מועד ב.    3/3/2016
מרצה: פרופ' אריאל פלנר
מתרגל: מר דור עצמון
משך המבחן שעתיים וחצי
יש לענות כל השאלות. 
ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים


שאלה 1:  מושגים  (16 נקודות)

הסבירו בקצרה (לא יותר מכמה משפטים) 4 מתוך 5 המושגים הבאים.
Sussman anomaly
Cooperative agent
Turing Test
Bias (in neurons)
אסטרטגיה שלמה (במשחקים).
כפי שנלמד בהרצאה









שאלה 2:  רזולוציה (21 נקודות)
ידועים הפרטים הבאים
גאלאקסי מהיר
G5 אמין ויקר יותר מאייפון
אייפון הוא אמין או מהיר
אייפון יותר יקר מגאלקסי

בטאו את א'-ה' כפסוק בתחשיב הפסוקים. 
      השתמשו בפרדיקטים fast(x), reliable(x), more-expensive(x,y)
הפכו ל- clausal form  
הוכיחו כי קיים סמארטפון אמין היקר יותר מסמארטפון מהיר. 


א.


ב.



ג.







שאלה 3:  משחקים (21 נק')


עבור עץ ה-Minimax הבא:
לכל אחת מהאפשרויות הבאות ציינו אלו יחסי גדלים צריכים להתקיים בין הקודקודים השונים כדי שאלו בלבד לא יפותחו ע"י alpha-beta  (כלומר מי ייגזם).
בכל אחת מהאפשרויות יש לתת אפשרות אחת המכילה את מינימום הקודקודים המשפיעים שיגרמו לגזימת הקודקודים הנ"ל (לדוגמא: a<b<c).
D E
DEG
EG
G



שאלה 4: למידה (21 נק')

תן דוגמה לעץ החלטה שיש בו קודקוד S ותכונה A כך ש
א.   GAIN(S,A)=1
ב. GAIN(S,A)=1/2
ג.     GAIN(S,A)=0
ב) נסחו והוכיחו את נוסחת ה-PAC LEARNING
כלומר, כמה דוגמאות צריך לדגום כדי לקבל את הודאות הדרושה.

1)

כפי שהוכחנו בכיתה



שאלה 5:  MDP (21 נק')



במשחק הקלפים: High-Low קיימת ערמה אינסופית של קלפים ובה הקלפים 2,3,4 
כך שיש פי 2 יותר קלפי 2 מאשר קלפי 3 ומספר זהה של קלפי 4 לקלפי 3.

בכל תור עליך להגיד High או Low, האם לדעתך הקלף הבא יהיה גבוה או נמוך יותר מזה שעל השולחן  
במידה ואתה צודק, אתה מקבל ניקוד כמספר הקלף. במידה ואתה טועה, המשחק נגמר.

(במקרה של שווין הנך מקבל את הניקוד, כלומר מדובר בקטן או שווה וכו).
לדוגמא: אם הקלף שעל השולחן הינו 3 ואמרת High אז:
אם יצא 2, טעית ונגמר המשחק.
אם יצא 3 או 4 אז אתה מקבל את הניקוד בהתאם לקלף שיצא והמשחק נמשך.

הגדירו את מרחב המצבים של הבעיה (ע"י ציור, רשימת מצבים או טבלה)
בצעו איטרציה של Value Iteration, ציינו ערכי U עבור כל מצב בכל באיטרציה. הציגו את התשובה בטבלה כזו: (אין חובה שהטבלה תהיה מלאה)
מה המדיניות העדיפה עבור כל מצב ע"פ הטבלה? 



 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2017A\aibgu2017a---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
 פתרון מבחן ב"יישומי בינה מלאכותית"  372.1.3502
מועד  א', 2/2/2017
מרצה: פרופ' אריאל פלנר
מתרגל: מר דור עצמון
משך המבחן: שעתיים וחצי

יש לענות כל השאלות במחברת הבחינה.
ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים

שאלה 1  מושגים  (16 נקודות, 4 נקודות לסעיף)
הסבירו בקצרה (לא יותר מכמה משפטים) או פתרו  4מתוך 5 הסעיפים הבאים?

מהי האנטרופיה של  39 ו-75?    0.927
Ockham’s razor
מהו POMDP? הסבירו בקצרה.
Horizon problem (במשחקים)
Activation Function (ANN)
 
כפי שנלמד בכיתה
שאלה 2  חיפוש (21 נקודות)
בעיית הפנקייקים – נתונה ערימה של  פנקייקים, כל פנקייק בגודל שונה (הקטן בגודל  והגדול בגודל ). המטרה היא לסדר את הערימה בסדר עולה לפי הגודל כך שהפנקייק הגדול ביותר (שמספרו  ) יהיה בתחתית והקטן ביותר (שמספרו ) יהיה עליון. לצורך סידור הערימה ניתן להפוך בכל פעולה את הסדר של  הפנקייקים העליונים. ראו דוגמה הממחישה הפיכה של  הפנקייקים העליונים. יש לבצע את הסידור בעלות מינימלית.

הגדירו יוריסטיקה אדמיסבילית לא טריוויאלית לכל אחד מהמקרים הבאים.
עלות כל פעולה נקבעת על פי גודל הפנקייק הגדול יותר מאלה שנפרדים. כלומר, אם הופכים  פנקייקים אזי מדובר במיקומים  ו-.
עלות כל פעולה נקבעת על פי גודל הפנקייק הגדול יותר מהקצוות שמתהפכים. כלומר אם הופכים m פנקייקים אזי הקצוות במיקום  ובמיקום .
עלות כל פעולה נקבעת על פי גודל הפנקייק הקטן ביותר בקבוצה שמתהפכת. כלומר אם הופכים m פנקייקים אזי הקטן ביותר מבין m הפנקייקים.
עלות כל פעולה נקבעת על פי גודל הפנקייק הגדול ביותר בקבוצה שמתהפכת.

עבור כל פנקייקים שכנים, אם מתקיים הפרש הגדול מ-1
 	הוסף את הפנקייק הגדול יותר
אם הפנקייק הגדול ביותר לא במיקום n
 	הוסף את הפנקייק במיקום n
עבור כל פנקייקים שכנים, אם מתקיים הפרש הגדול מ-1
 	הוסף את הפנקייק הקטן יותר
אם הפנקייק הגדול ביותר לא במיקום n
 	הוסף את הפנקייק במיקום n
עבור כל פנקייקים שכנים, אם מתקיים הפרש הגדול מ-1
 	הוסף 1
אם הפנקייק הגדול ביותר לא במיקום n
 	הוסף 1
עבור כל פנקייקים שכנים, אם מתקיים הפרש הגדול מ-1
 	הוסף את הפנקייק הקטן יותר
אם הפנקייק הגדול ביותר לא במיקום n
 	הוסף n



שאלה 3  רזולוציה (21 נקודות)
ידועים הפרטים הבאים:
אם אדם אוהב ירוק אז הוא אוהב צהוב
אבי אוהב ירוק וגם אוהב סגול
רק מי שאוהב אדום אוהב סגול
אם אדם אוהב צהוב אז הוא אוהב כתום

בטאו את א'-ד' כפסוק בתחשיב הפסוקים. 
      השתמשו בפרדיקטים: 
הפכו ל- clausal form  (לכתוב רק את הביטוי הסופי)

הוכיחו שקיים אדם שאוהב ירוק, אדום וכתום. הראו את כל שלבי ההוכחה. 

 


 

 



שאלה 4  MDP (21 נק')
יורם הינו אב לשני ילדים: מיכל ודניאל.
בכל יום, על יורם לאסוף את מיכל מהגן ודניאל מביה"ס.
אם יורם נוסע קודם לאסוף את מיכל מהגן, 40% שיגיע לגן ו-60% שיתבלבל בדרך ויחזור לביתו. 
אם יורם נוסע קודם לאסוף את דניאל מביה"ס, 30% שיגיע ו-70% שיתבלבל בדרך ויחזור לביתו. 
לאחר שיורם אסף אחד מילדיו וכעת עליו לאסוף את השני. מכיוון שילדיו יודעים את הדרך למיקום השני. כעת, האחוזים משתנים.
אם יורם נוסע כעת לאסוף את מיכל מהגן, 60% שיגיע לגן ו-40% שיתבלבל בדרך ויחזור לביה"ס. 
אם יורם נוסע כעת לאסוף את דניאל מביה"ס, 70% שיגיע ו-30% שיתבלבל בדרך ויחזור לגן. 
עלות נסיעה לגן (מכל מקום) הינה 7 ועלות נסיעה לביה"ס (מכל מקום) הינה 5.
תועלתו של יורם במידה ואסף את שני ילדיו הינה 30.

רשמו את תשובתכם במחברת הבחינה (כולל הטבלה)
הגדירו את מרחב המצבים של הבעיה בגרף. כל קודקוד מתאים למצב. צלע מהווה פעולה, והיא יכולה להתפצל ע"פ אחוזים.
בצעו 2 איטרציות של Value Iteration, ציינו ערכי U עבור כל מצב בכל באיטרציה. הציגו את התשובה בטבלה כזו: (אין חובה שהטבלה תהיה מלאה. איפוס התועלות אינה איטרציה)

מה המדיניות העדיפה עבור כל מצב אחרי שתי איטרציות ע"פ הטבלה? 







שאלה 5  Planning (21 נק')
פרדיקטים:
Sells(x,y) – חנות x מוכרת את מוצר y
At(x) – אנו נמצאים במיקום x
Have(y) – יש ברשותנו את מוצר y
מצב התחלתי:
At(Home), Sells(Supermarket,Milk), Sells(Supermarket,Banana), Sells(Homedepot,Drill)
מצב סופי:
 At(Home), Have(Milk), Have(Banana), Have(Drill)
הגדר את שני האופרטורים הבאים בעזרת Strips (יש לרשום את כל הרשימות הדרושות לפעולה)
Go(Here,There) – הליכה מ-Here ל-There
Buy(Store,x) – קניית המוצר x בחנות Store

רשום את האופרטורים שיביאו מהמצב ההתחלתי למצב הסופי.

 
Go(Here,There)
Preconditions – {At(Here)}
Add List – {At(There)}
Delete List – {At(Here)}
Buy(Store,x)
Preconditions – {At(Store), Sells(Store,x)}
Add List – {Have(x)}
Delete List – {}
  
Go(Home, Supermarket)
Buy(Supermarket, Milk)
Buy(Supermarket, Banana)
Go(Supermarket, Homedepot)
Buy(Homedepot, Drill)
Go(Homedepot, Home)

 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2018A\aibgu2018aV3.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
מבחן  ב"ישומי בינה מלאכותית"  372.1.3502
מועד א.    4/2/2018
מרצה: ד"ר רוני שטרן
מתרגל: מר דור עצמון
משך המבחן שעתיים וחצי

יש לענות כל השאלות ורק על טופס הבחינה. 
ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים


שאלה 1:  מושגים  (16 נקודות)

הסבירו בקצרה (לא יותר מכמה משפטים) 4 מתוך 5 המושגים הבאים.
General Game Playing _______________________
____________________________________________
Overfitting __________________________________
____________________________________________
TD( ______________________________________
____________________________________________
שווי משקל Nash ______________________________
____________________________________________
Sussman's anomaly __________________________
____________________________________________



שאלה 2:  רזולוציה (21 נקודות)
במפעל בעל מכונות לייצור רכיבים אלקטרוניים ידועים הפרטים הבאים:
לכל מכונה בעלת תכונה  קיימת מכונה בעלת תכונה  (יכולה להיות אותה המכונה)
כל מכונה בעלת לפחות אחת מהתכונות הבאות -  או 
כל המכונות אינן בעלות התכונה 
כל המכונות אינן בעלות התכונה 
רק מכונות בעלות התכונה  הינן בעלות התכונה 

בטאו את 1-5 כפסוק בתחשיב הפסוקים. 
      השתמשו בפרדיקטים: 
__________________________________________

__________________________________________

__________________________________________

__________________________________________

__________________________________________

הפכו ל- clausal form  (לכתוב רק את הביטוי הסופי)












הוכיחו שקיימת מכונה בעלת התכונה 

















שאלה 3:  משחקים (21 נק')
משחק "הקופה" מוגדר באופן הבא:
כל שחקן בתורו יכול לבחור אחת משתי הפעולות הבאות:
לקחת 25% אחוז מהקופה אליו
לקחת 12.5% אחוז מקופה אליו ו-25% מהקופה לזרוק לפח

בתחילת המשחק ישנן 4096 נקודות. המשחק נגמר לאחר 3 מהלכים: קודם משחק שחקן א', אח"כ שחקן ב', ובסוף שחקן א'. מטרת המשחק מטרת הינה לצבור ניקוד גבוה ככל הניתן לעומת ניקוד היריב בסיום המשחק. 
מדלו את המשחק ע"י עץ (הענף השמאלי מייצג את פעולה 1). 
הריצו את אלגוריתם   על עץ החיפוש
רשמו בכל צומת את ערך בה בסיום הריצה. 
סמנו גיזומים המתרחשים (אם קיימים כאלו) במהלך הריצה. 

ניתן להניח שאנו רוצים למקסם את הניקוד של השחקן הראשון.












שאלה 4:  חיפוש ותכנון (21 נקודות)
איור 1 מציג רשת של תחנות רכבת ומסילות. 

כל עיגול מציין תחנה וכל קו בין עיגולים מייצג מסילה אחת בלבד. 
הזמן הדרוש כדי לעבור מתחנה לתחנה הקרובה הוא חצי שעה. 
כאשר רכבת נמצאת בתחנה, היא יכולה גם להחליט לחכות חצי שעה בתחנה. 
יש מקום בתחנה לכמה רכבות, אבל אסור לשתי רכבות להשתמש באותה המסילה באותו הזמן.
נרצה לכתוב מערכת שמסוגלת לתכנן מסלול לכמה רכבות. המערכת תקבל כקלט את תחנת המוצא ותחנת היעד של כל רכבת ותחזיר מסלול לכל רכבת. 
למען הפשטות, נניח כי יש רק שתי רכבות.

מדל את הבעיה כבעיית תכנון (planning) לפי STRIPS.  רמז: מצב בבעיה זו הוא זוג (x,y) כאשר x זו התחנה שבה נמצאת רכבת א' ו y זו התחנה שבה נמצאת רכב ב'. 
הגדר את פרדיקטים הנדרשים בשביל להגדיר את הבעיה. 


נניח כי רכבת א' נמצאת בתחנה A ורוצה להגיע לתחנה D ורכבת ב' נמצאת בתחנה C וגם רוצה להגיע לתחנה D. הגדר את המצב ההתחלתי והמצב הסופי בעזרת הפרדיקטים שהגדרת בסעיף 1. 



הגדר את הפעולות באופן פורמאלי (preconditions ו effects). 
שמו לב: הרכבות יכולות לנוע במקביל.




נניח כי אנו רוצים לפתור את הבעיה שהגדרתם לעיל עבור המצב ההתחלתי והמצב הסופי שהוגדרו בסעיף ב', כך שהזמן הנדרש עד שכל הרכבות תגענה ליעדן יהיה מינימלי. 
נשתמש בפונקציה יוריסטית שמחשבת לכל רכבת את המרחק הכי קצר ממנה אל היעד ומחזירה את המקסימום מבין המרחקים. 
האם יוריסטיקה זו אדמיסיבלית? אם כן – הוכחו, אחרת, הראו דוגמא נגדית. 
______________________________________________________________

______________________________________________________________

_____________________________________________________________

נניח ונפתור את הבעיה בעזרת יוריסטיקה זו ואלגוריתם A*. מה המספר המינימלי של קודקודים שנהיה חייבים לפתח _____________________________

נימוק קצר:______________________________________________________
שאלה 5:  מודלים מרקוביים ולמידה (21 נקודות)
נניח כי בסיפור משאלה 4 נתון כי כל רכבת שרוצה לצאת מתחנה כלשהי תתעכב חצי שעה בתחנה בסיכוי של 10%. תחת הנה זו, עליכם למדל את הבעיה בעזרת מודל MDP באופן פורמאלי, כלומר להגדיר את המצבים (כולל את מצב ההתחלה ומצב הסיום), הפעולות, פונ' המעבר, ופונ' ה reward. 




ידוע לנו הנתונים הבאים על הנסיעות ברכבת:


נרצה להשתמש בנתונים אלו כדי לחזות האם הרכבת תגיע בזמן או תאחר. 
צור עץ החלטה בעזרת אלגוריתם ID3 כדי לחזות בהנתן היום בשבוע ומזג האוויר האם הרכבת צפויה להגיע באיחור או לא. ליד כל קודקוד בעץ יש לציין את ה Information Gain שהתקבל עבור התכונה שנבחרה.





 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מבחנים-לדוגמא\2019A\aibgu2019a.pdf </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
 
 372.1.3502מבחן  ב"ישומי בינה מלאכותית"  
 28/1/2019.    אמועד 
 ד"ר רוני שטרןמרצה: 
 דור עצמוןמתרגל: מר 
 שעתיים וחצימשך המבחן 
 נוסחאות, מחשבון. עמודים(  2): דף חומר עזר
 
 . כל השאלות ורק על טופס הבחינהיש לענות 
 ניקוד יינתן על כל השאלה כמכלול ולא על פי הסעיפים
 
 
 נקודות( 16מושגים  )  :1שאלה 
 
 המושגים הבאים. 5מתוך  4הסבירו בקצרה )לא יותר מכמה משפטים( 
 _______________________________________ Occam's Razor .א
_____________________________________________________ 
_____________________________________________________ 
 _________________________________  Partial order planning .ב
_____________________________________________________ 
_____________________________________________________ 
 _______________________________________________ (TD(λ .ג
_____________________________________________________ 
_____________________________________________________ 
 ________________________________________________ UCB .ד
_____________________________________________________ 
_____________________________________________________ 
 ______________________________________ Zero-sum game .ה
_____________________________________________________ 
_____________________________________________________ 
 
 נקודות( 21רזולוציה )  :2שאלה 
 נתון הידע הבא:
 אפרסקיםכל מי שאוהב לשתות מיץ תפוזים או שוקו אוהב לשתות חלב או מיץ  .1
 חלבהוא גם לא אוהב לשתות ואפרסקים אבי לא אוהב לשתות מיץ  .2
 נועה אוהבת לשתות מיץ תפוזים ולא אוהבת לשתות חלב .3
 אפרסקיםרק מי שאוהב לשתות סודה, אוהב לשתות מיץ  .4
 
 כפסוק בתחשיב הפסוקים.  1-4בטאו את  .א
  :ובקבועים הבאים השתמשו בפרדיקטים      
 M(x) – x אוהב לשתות חלב 
 C(x) – x אוהב לשתות שוקו 
 O(x) – x אוהב לשתות מיץ תפוזים 
 A(x) – x  אפרסקיםאוהב לשתות מיץ 
 S(x) – x אוהב לשתות סודה 
 AVI – אבי NOA - נועה 
 
 
 
 
 )לכתוב רק את הביטוי הסופי(  clausal form -הפכו ל .ב
 
 
 
 
 
 
 
 
 
 
 
 
 שגם קיים אדם שאוהב לשתות סודה וגם קיים אדם שלא אוהב לשתות שוקוהוכיחו  .ג
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 נק'( 21) משחקים:  3שאלה 
בעץ המשחק הבא שחקן המקסימום מיוצג על ידי ריבועים ושחקן המינימום על ידי עיגולים. עלי 
ידוע שערכי העלים שונים אחד העץ מיוצגים על יד מספרים המייצגים את תוצאת המשחק. 
 מהשני.
 
 ענו על השאלות הבאות:
𝐴 -בהינתן ש .א = 21, 𝐵 = 18, 𝐶 = 16, 𝐷 = 20, 𝐸 = 17, 𝐹 = 14, 𝐺 = 15 
  _______של עץ זה?  minimax-הו ערך המ
−αאלגוריתם בעץ החיפוש יגזמו ע"י  עליםכמה בהינתן ערכי העלים מסעיף א'.  .ב β ? 
 תשובה: ______
 עובר על העץ משמאל לימין. בכל סעיפי שאלה זו שהאלגוריתם להניח שמו לב, ניתן 
,𝐵והערך של העלים  1000הוא  𝐴לה רך של העעהש כעת נניח .ג 𝐶, 𝐷, 𝐸, 𝐹, 𝐺 
αעל ידי אלגוריתם  מהי כמות העלים המקסימלית שיגזמו. 1000קטן מ   − 𝛽_____ ? 
שיגזמו על ידי אלגוריתם מהי כמות העלים המינימלית סעיף ג'. תחת אותם ההנחות שב .ד
α − 𝛽  ? _______ 
αעל ידי אלגוריתם מהי כמות העלים המקסימלית שיגזמו  .ה − 𝛽  ,בעץ החיפוש הנ"ל
,𝐴בהנחה שניתן לתת כל ערך שרירותי לעלים  𝐵, 𝐶, 𝐷, 𝐸, 𝐹, 𝐺_______ ?  
תקבל הגיזום שעבורם יבהמשך לסעיף ה'. תנו דוגמא ליחס גדלים בין ערכי העלים  .ו
𝐴מקסימלי שמוצג בסעיף ה' )לדוגמא: ה < 𝐵 < 𝐶 < 𝐷 < 𝐸 < 𝐹 < 𝐺.) 
___________________________. 
 
 
 
 נקודות( 21)ותכנון  חיפוש:  4שאלה 
 
 
היא להעביר חבילות מהמחסן אל  נים. מטרת הרחפניםאנו מעוניינים לממש מערכת שליטה ברחפ
 בית הלקוח. 
 . רחפן יכול להמריא לאוויר ולנחות .1
 . רק כאשר הוא באווירלעוף מהמחסן לבית הלקוח וחזרה רחפן יכול  .2
 . על הרחפן קודם כל לנחות, וכדי להניח חבילה בבית הלקוחכדי לאסוף חבילה מהמחסן  .3
 רחפן אחד יכול לסחוב לא יותר מחבילה אחת בו זמנית.  .4
 רחפנים יכולים לשהות יחד באותו המקום, ואין צורך לחשוש מהתנגשויות. .5
 
  . STRIPS( לפי planningמדל את הבעיה כבעיית תכנון )חלק א': 
יתאר את מיקום הרחפנים, איזה רחפנים באוויר ואיזה רחפנים על הקרקע, מצב בבעיה זו  רמז:
 ומיקום החבילות. חבילה יכולה להיות בבית הלקוח או במחסן או על אחד הרחפנים.
 . הגדר את פרדיקטים הנדרשים בשביל להגדיר את הבעיה .א
 
 
הגדר את אחד ורק חבילה, ושניהם נמצאים כעת על הקרקע במחסן.  יש רק רחפןנניח כי  .ב
 . פי בעזרת הפרדיקטים שהגדרת בסעיף הקודםהמצב ההתחלתי והמצב הסו
 
 
 
לפי  בעזרת הפרדיקטים שהגדרתם בסעיף א', הגדירו באופן פורמאלי את הפעולות הבאות .ג
STRIPS  כלומר הגדירו את ה(preconditions  וeffects  כל פעולהשל)  . 
FlyUp(drone) 
Preconditions:  
Effects:  
FlyDown(drone) 
Preconditions:  
Effects:  
FlyTo(drone, from, to) 
Preconditions 
Effects 
PickUp(drone, location, package) 
Preconditions 
Effects 
PutDown (drone, location, package) 
Preconditions:  
Effects:  
  
 פתרון הבעיה. ':בחלק 
 
לקוחות,  ושני , חבילה א' וחבילה ב',שתי חבילות, רחפן א' ורחפן ב', רחפניםשני  נניח כי יש .ד
במחסן, וכל לקוח גר בבית אחרת. על הקרקע לקוח א' ולקוח ב'. הרחפנים והחבילות נמצאים 
 המטרה היא להביא את חבילה א' ללקוח א' ואת חבילה ב' ללקוח ב'. 
 
 ________________________מהו גודל מרחב המצבים? __________. הסבר קצר: _ .1.ד
 
 ________________________ המקסימלי במרחב המצבים?  branching factorמהו ה  .2.ד
 
 __________________________________________________________________הסבר קצר: 
 ____ מהו עומק הפתרון הכי קצר?בעץ החיפוש המתאים לבעיה זו,  
 _____________הסבר קצר: _____________________________________________________
__________________________________________________________________________ 
 , והוכיחו כי היא אכן אדמיסיבילית. הציעו יוריסטיקה אדמיסיבילית לבעיה זו .3.ד
 
__________________________________________________________________________ 
__________________________________________________________________________ 
__________________________________________________________________________ 
 נקודות( 21)מודלים מרקוביים ולמידה   :5שאלה 
, נניח כי כאשר רחפן א' ממריא עם חבילה, הוא עלול להפיל אותה על הרצפה ד' 4בהמשך לסיפור בשאלה 
 . 5%. רחפן ב' הוא אמין יותר, והסיכוי שהוא יפיל את החבילה כאשר הוא ממריא הוא רק 10%בסיכוי של 
החבילות ליעדן בכמה שפחות פעולות. אפשר להניח שכל פעולה מזיזה רק רחפן המטרה היא להביא את 
 אחד. 
 .MDPכ   שלב א': הגדרת הבעיה
 (. Markov Decision Problem (MDPעליכם למדל את הבעיה כבעיית 
 .הגדירו את פונקציית המעבר .א
 
 
 
 
 
 
 
 .rewardהגדירו את פונקציית ה  .ב
 
 למידה: שלב ב'
נניח כי החליפו את הרחפנים מהסעיף הקודם ברחפנים חדשים, ואנו לא יודעים את הסיכוי שהם יפילו 
או במשקלה )קל, כבד, ו/בגודל החבילה )גדול או קטן( הסיכוי להפיל את החבילה תלוי כי חבילות. ייתכן 
 מאד כבד(. 
 .לאחר כשבוע של פעילות, נצפו הנתונים הבאים
 
גודל  תאריך
 החבילה
משקל 
 החבילה
 האם החבילה נפלה?
 כן קל גדול 1.1.18
 כן קל קטן 2.1.18
 כן כבד גדול 3.1.18
 לא מאד כבד קטן 4.1.18
 כן מאד כבד גדול 5.1.18
 כן קל קטן 6.1.18
 לא קל  גדול 7.1.18
 לא מאד כבד קטן 8.1.18
 לא כבד  גדול 9.1.18
 לא כבד קטן 10.1.18
 כן כבד גדול 11.1.18
 כן כבד קטן 12.1.18
 
גודל  נתןיבההאם הרחפן יפיל את החבילה או לא, כדי לחזות  ID3צור עץ החלטה בעזרת אלגוריתם 
יש ההחלטה שיווצר ליד כל קודקוד בעץ החבילה )גדול או קטן( ומשקל החבילה )קל, כבד, או כבד מאד(. 
 שהתקבל עבור התכונה שנבחרה. Information Gainלציין את ה 
 
 
 
 
 
 
 
 
 
 בהצלחה!
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מטלות-עיוניות-(לא-להגשה)\Assignment-1---Solution\Assignment-1---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
יישומי בינה מלאכותית
סמסטר חורף תשע"ט
מטלה 1 - פתרון


הוכח או הפרך: פונקציה אדמיסיבילית הינה בהכרח פונקציה קונסיסטנטית.
* תזכורת. יוריסטיקה תקרא קונסיסטנטית כאשר:
עבור כל שני מצבים שכנים s ו-s’ מתקיים-
	 
וכן עבור מצב המטרה-
	

תשובה:
נפריך ע"י דוגמא של פונקציה אדמיסיבילית שאינה קונסיסטנטית:









	
h1 ו-h2 פונקציות אדמיסיביליות, ענה והסבר(הוכח במידת הצורך):
א) האם בהכרח MIN(h1,h2) פונקציה אדמיסיבילית?
	ב) האם בהכרח MAX(h1,h2) פונקציה אדמיסיבילית?
	ג) האם h1+h2 בהכרח אדמיסיבילית?
	ד) עבור אילו ערכים h1*h2 אדמיסיבילית?

כן, עבור כל קודקוד מתקיים- או  
מכיוון ש- 
וגם-מהגדרת האדמיסיביליות,
אזי עבור כל קודקוד מתקיים גם-
  
ולכן אדמיסיבילית.
כן, עבור כל קודקוד מתקיים- או  
מכיוון ש- 
וגם-מהגדרת האדמיסיביליות,
אזי עבור כל קודקוד מתקיים גם-
  
ולכן אדמיסיבילית.
לא, דוגמא נגדית:

בלי הגבלת הכלליות, h1  בתחום [1,0], h2 בתחום [0,∞] ולכן-

ומיכוון ש- h2 אדמיסיבילית ו-, 
אזי גם  אדמיסיבילי.
3) הראה דוגמא כי: בהינתן יוריסטיקה לא אדמיסיבילית, A* אינו בהכרח מחזיר את המסלול האופטימלי.  (צייר גרף והסבר במילים את ניהול תור העדיפויות של האלגוריתם על פי הגרף)

תשובה:


תחילה נכניס את S לתור העדיפויות
נשלוף את S מהתור ונכניס את שכניו: A, B עם משקלים 5, 2 בהתאמה (f)
נשלוף את B מהתור (משקל f נמוך יותר) ונכניס את שכנו G עם משקל 3 (f)
נשלוף את G מהתור וכן נחזיר את המסלול אליו (S->B->G)









ענה על 5 הסעיפים (א-ה) שבסוף המטלה, עבור 2 הבעיות הבאות: 
4) בעיית מציאת מסלול ב-8 connected grid
מוגדרת באופן הבא: נתונה מפה (כמו בדוגמא הבאה), נק' התחלה וסיום, יש למצוא מסלול קצר ביותר בין שתי הנקודות. בכל צעד ניתן לזוז למשבצת שכנה פנויה כלשהי (עד 8 משבצות שכנות - ניתן לזוז גם באלכסון).

תשובה:
מצב: מיקום  על ה-grid.
אופרטורים: שינוי המיקום על ה-grid למיקום סמוך (אם ניתן)
.
מצב התחלה: מיקום  על פי הקלט.
מצב מטרה: 
פונקציה יוריסטית: 
הוכחת אדמיסיביליות:
נניח בשלילה שקיים פתרון ממצב  בעל מספר צעדים קטן מההיוריסטיקה.
עבור המצב ,  ומספר הצעדים לפתרון הוא  וכן .
בצעד יחיד ניתן לשנות את  או  בלכל היותר 1 ולכן  יכול להיות קטן יותר ב-1 לכל היותר עבור צעד יחיד.
ב- צעדים ניתן להגיע ל- שאינו קטן מ- .
 לפי ההנחה ש- .
לפי ההיוריסטיקה, במצב המטרה  וכן  ולכן 
סתירה לכך שלאחר  צעדים  ולכן אדמיסיבילית.





5) בעיית כיסוי צלעות ממושקלת - Weighed edge cover
נתון - גרף ממושקל ולא מכוון G (משקלי הצלעות מ-1 עד |E|, לכל צלע משקל שונה).
המטרה - מציאת קבוצת צלעות המכסה את כלל הקודקודים בעלות מינימלית.
לדוגמא, בהינתן הגרף הבא:


הפתרון יהיה: קבוצת הצלעות {AB,AC}, שמכסה את כלל הקודקודים בעלות מינימלית.

תשובה:
מצב: קבוצת צלעות.
אופרטורים: הוספת צלע שאינה בקבוצה לקבוצת הצלעות. עלות האופרטור כמחיר הצלע.
מצב התחלה:  (קבוצה ריקה).
מצב מטרה: קבוצת צלעות כך שכל קודקוד בגרף מחובר לפחות לאחת מהן.
נסמן-  - קבוצת הצלעות המשלימה ל-
פונקציה יוריסטית:



 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מטלות-עיוניות-(לא-להגשה)\Assignment-1\Assignment-1.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
יישומי בינה מלאכותית 
סמסטר חורף תשע"ט
מטלה 1
לא להגשה


הוכח או הפרך: פונקציה אדמיסיבילית הינה בהכרח פונקציה קונסיסטנטית.
* תזכורת. יוריסטיקה תקרא קונסיסטנטית כאשר:
עבור כל שני מצבים שכנים s ו-s’ מתקיים-
	 
וכן עבור מצב המטרה-
	
	
h1 ו-h2 פונקציות אדמיסיביליות, ענה והסבר(הוכח במידת הצורך):
א) האם בהכרח MIN(h1,h2) פונקציה אדמיסיבילית?
	ב) האם בהכרח MAX(h1,h2) פונקציה אדמיסיבילית?
	ג) האם h1+h2 בהכרח אדמיסיבילית?
	ד) עבור אילו ערכים h1*h2 אדמיסיבילית?

3) הראה דוגמא כי: בהינתן יוריסטיקה לא אדמיסיבילית, A* אינו בהכרח מחזיר את המסלול האופטימלי.  (צייר גרף והסבר במילים את ניהול תור העדיפויות של האלגוריתם על פי הגרף)



ענה על 5 הסעיפים (א-ה) שבסוף המטלה, עבור 2 הבעיות הבאות: 
4) בעיית מציאת מסלול ב-8 connected grid
מוגדרת באופן הבא: נתונה מפה (כמו בדוגמא הבאה), נק' התחלה וסיום, יש למצוא מסלול קצר ביותר בין שתי הנקודות. בכל צעד ניתן לזוז למשבצת שכנה פנויה כלשהי (עד 8 משבצות שכנות - ניתן לזוז גם באלכסון).
 

5) בעיית כיסוי צלעות ממושקלת - Weighed edge cover
נתון - גרף ממושקל ולא מכוון G (משקלי הצלעות מ-1 עד |E|, לכל צלע משקל שונה).
המטרה - מציאת קבוצת צלעות המכסה את כלל הקודקודים בעלות מינימלית.

לדוגמא, בהינתן הגרף הבא:


הפתרון יהיה: קבוצת הצלעות {AB,AC}, שמכסה את כלל הקודקודים בעלות מינימלית.
 
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מטלות-עיוניות-(לא-להגשה)\Assingment-2---Solution\Assignment-2---sol.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
יישומי בינה מלאכותית
סמסטר חורף תשע"ט
מטלה 2 - פתרון

שאלה 1
מוגדרים הפרדיקטים הבאים:
Sells(x,y) – חנות x מוכרת את מוצר y
At(x) – אנו נמצאים במיקום x
Have(y) – יש ברשותנו את מוצר y
מצב התחלתי:
{ At(Home), Sells(Supermarket,Milk), Sells(Supermarket,Banana), Sells(Homedepot,Drill) }
מצב סופי:
{ At(Home), Have(Milk), Have(Banana), Have(Drill) }
הגדירו את שני האופרטורים הבאים לפי STRIPS. 
Go(Here,There) – הליכה מ-Here ל-There
Buy(Store,x) – קניית המוצר x בחנות Store
רשמו את רצף האופרטורים שיביאו מהמצב ההתחלתי למצב הסופי.
תשובה:
 
Go(Here,There)
Preconditions – {At(Here)}
Add List – {At(There)}
Delete List – {At(Here)}
Buy(Store,x)
Preconditions – {At(Store), Sells(Store,x)}
Add List – {Have(x)}
Delete List – {}


Go(Home, Supermarket)
Buy(Supermarket, Milk)
Buy(Supermarket, Banana)
Go(Supermarket, Homedepot)
Buy(Homedepot, Drill)
Go(Homedepot, Home)



שאלה 2
הדגימו אלגוריתם גיזום אלפא-ביטא על העץ הבא (מלאו בטבלאות המצורפות ערכי אלפא, ביטא ו-V: לפני ביקור בצומת (1), אחרי הביקור בבן השמאלי (2) ולאחר הביקור בשני הבנים (3)) הראו גם אילו ענפים נגזמים. בתוך הקודקודים רשמו את הערך הסופי בקודקוד (אם לא נגזם). הריבועים מייצגים קודקודי מקסימום והעיגולים קודקודי מינימום.




שאלה 3
נתון תת עץ המשחק הבא:
נניח כי בהרצת אלגוריתם אלפא-ביטא קודקוד C לא יפותח, מה ניתן לומר על (בהתייחס ל- ו-):
1) MAX(A,B)
2) MIN(A,B)
עבור אילו ערכי E אלגוריתם אלפא-ביטא יגזום את הקודקודים F,G,H (הסבר עבור כל אחד משלושת הקודקודים בנפרד) לאחר בדיקת קודקוד E (E אכן נבדק)?
יש לבטא את ערך E ביחס לערכי שאר הקודקודים באופן הכללי ביותר.
יש להניח  עבור סעיף זה כי  ו- .
תשובה:
1) על MAX(A,B) לא ניתן להגיד דבר, מכיוון שהקודקוד שבוחר בין A ל-B הינו קודקוד מינימום.
2) MIN(A,B) ≥ Y , מכיוון שהקודקוד שחותך הוא קודקוד מקסימום, צריך להתקיים: V≥ .b
קודקוד F) מכיוון ש-E נבדק, קודקוד F יבדק עבור כל ערך של E.
קודקוד G) אם MIN(E,F)≥MAX(MIN(A,B),MIN(C,D)) אזי G לא ייבדק.
קודקוד H) בדומה לקודקוד G, ובנוסף אם MIN(E,F)≥G אזי H לא ייבדק. 
שאלה 4
ידוע כי: 
לכל מי שאין טלויזיה בבית, יש רדיו 
כל מי שיש ברשותו טלויזיה בבית, אינו הולך בשנתו.
קיים אדם שהולך בשנתו.
בטא את הידע בעזרת First order logic
הוכח בעזרת רזולוציה (כולל כל השלבים) כי קיים אדם שברשותו רדיו.
השתמש בפרדיקטים הבאים:
Have(x,y) – ל-x יש ברשותו את y
SleepWalker(x) – x הולך בשנתו
ובקבועים הבאים:  TV, RADIO
תשובה:
 

 




שאלה 5
ידוע כי: 
מיכל אוהבת מתמטיקה
נועה נולדה בחורף
אם אדם נולד בחורף אז הוא לא אוהב מתמטיקה
כל אדם אוהב מתמטיקה או פיזיקה (אך לא שניהם)
בטא את הידע בעזרת First order logic
הוכח בעזרת רזולוציה (כולל כל השלבים) כי מיכל לא אוהבת פיזיקה ונועה וכן אוהבת פיזיקה.
השתמש בפרדיקטים הבאים:
Winter(x) – x נולד בחורף
Math(x) – x אוהב מתמטיקה
Physics(x) – x אוהב פיזיקה
ובקבועים הבאים:  NOA, MICHAL
תשובה:
 

 


 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מטלות-עיוניות-(לא-להגשה)\Assingment-2\Assignment-2.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
יישומי בינה מלאכותית 
סמסטר חורף תשע"ט
מטלה 2
לא להגשה


שאלה 1
מוגדרים הפרדיקטים הבאים:
Sells(x,y) – חנות x מוכרת את מוצר y
At(x) – אנו נמצאים במיקום x
Have(y) – יש ברשותנו את מוצר y
מצב התחלתי:
{ At(Home), Sells(Supermarket,Milk), Sells(Supermarket,Banana), Sells(Homedepot,Drill) }
מצב סופי:
{ At(Home), Have(Milk), Have(Banana), Have(Drill) }
הגדירו את שני האופרטורים הבאים לפי STRIPS. 
Go(Here,There) – הליכה מ-Here ל-There
Buy(Store,x) – קניית המוצר x בחנות Store
רשמו את רצף האופרטורים שיביאו מהמצב ההתחלתי למצב הסופי.





שאלה 2
הדגימו אלגוריתם גיזום אלפא-ביטא על העץ הבא (מלאו בטבלאות המצורפות ערכי אלפא, ביטא ו-V: לפני ביקור בצומת (1), אחרי הביקור בבן השמאלי (2) ולאחר הביקור בשני הבנים (3)) הראו גם אילו ענפים נגזמים. בתוך הקודקודים רשמו את הערך הסופי בקודקוד (אם לא נגזם). הריבועים מייצגים קודקודי מקסימום והעיגולים קודקודי מינימום.

















שאלה 3
נתון תת עץ המשחק הבא:
נניח כי בהרצת אלגוריתם אלפא-ביטא קודקוד C לא יפותח, מה ניתן לומר על (בהתייחס ל- ו-):
1) MAX(A,B)
2) MIN(A,B)
עבור אילו ערכי E אלגוריתם אלפא-ביטא יגזום את הקודקודים F,G,H (הסבר עבור כל אחד משלושת הקודקודים בנפרד) לאחר בדיקת קודקוד E (E אכן נבדק)?
יש לבטא את ערך E ביחס לערכי שאר הקודקודים באופן הכללי ביותר.
יש להניח  עבור סעיף זה כי  ו- .








שאלה 4
ידוע כי: 
לכל מי שאין טלויזיה בבית, יש רדיו 
כל מי שיש ברשותו טלויזיה בבית, אינו הולך בשנתו.
קיים אדם שהולך בשנתו.
בטא את הידע בעזרת First order logic
הוכח בעזרת רזולוציה (כולל כל השלבים) כי קיים אדם שברשותו רדיו.
השתמש בפרדיקטים הבאים:
Have(x,y) – ל-x יש ברשותו את y
SleepWalker(x) – x הולך בשנתו
ובקבועים הבאים:  TV, RADIO


שאלה 5
ידוע כי: 
מיכל אוהבת מתמטיקה
נועה נולדה בחורף
אם אדם נולד בחורף אז הוא לא אוהב מתמטיקה
כל אדם אוהב מתמטיקה או פיזיקה (אך לא שניהם)
בטא את הידע בעזרת First order logic
הוכח בעזרת רזולוציה (כולל כל השלבים) כי מיכל לא אוהבת פיזיקה ונועה וכן אוהבת פיזיקה.
השתמש בפרדיקטים הבאים:
Winter(x) – x נולד בחורף
Math(x) – x אוהב מתמטיקה
Physics(x) – x אוהב פיזיקה
ובקבועים הבאים:  NOA, MICHAL

 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מטלות-עיוניות-(לא-להגשה)\Assingment-3\Assignment-3.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
יישומי בינה מלאכותית 
סמסטר חורף תשע"ט
מטלה 3
ללא הגשה

שאלה 1
נתון הלוח הבא בו ניתן לזוז ממשבצת למשבצת סמוכה לה, אך לא באלכסון.
המצבים 100+ ו-200- הינם מצביים סופיים.
כאשר סוכן מנסה ללכת ממשבצת לזו הסמוכה לה 80% שהמהלך יצליח ו-20% שלא, אם המהלך אינו מצליח, הסוכן עובר למשבצת שנמצאת מצדו של המהלך.
לדוגמא, 
אם הסוכן מנסה ללכת מ-1 ל-2 - 80% שיעבור ל-2 ו-20% שיעבור ל-3.
אם הסוכן מנסה ללכת מ-2 ל-4 - 80% שיצליח, 10% שיעבור ל-1 ו-10% שיעבור ל-100+. 
אם סוכן מנסה ללכת מ-2 ל-1 - 80% שיצליח ו-20% שיעבור ל-4.
עלות כל צעד שיבצע הסוכן הינה 3-. המהלכים האפשריים הינם החצים הכחולים.
עליכם להראות 4 איטרציות של Value Iteration בין המצבים השונים, 1-4 (איפוס המצבים אינו נחשב לאיטרציה).
בסוף כל איטרציה יש להראות את הלוח ועליו חצים המציינים את מדיניות תנועת הסוכן בכל משבצת.
יש להציג חישובים מפורטים של כל איטרציה.

נניח ו- (discount-reward) , הראה כי כעת המדיניות אחרי 4 איטרציות תהיה שונה מזו שקיבלנו בסעיף הקודם.

שאלה 2
בצעו 3 פרקים של אלגוריתם  בהינתן הלוח מהשאלה הקודמת.
, , . כאשר מנסים לבצע פעולה מסוימת – הפעולה מצליחה. בכל פעם מבצעים את הפעולה הטובה ביותר (ללא explore). טבלת ה- הנוכחית הינה:



שאלה 3
נתונה רשת הנוירונים המאומנת הבאה.











כמו כן נתונות טבלת המשקולות ופונקציית האקטיבציה הבאות.


פונ' האקטיבציה לכל הנוירונים:








מהו הפלט של כל נוירון בהינתן הקלט הבא?
A=5, B=8.2, C=3.1, D=-11, E=0.7
(רשום תחילה את משוואת כל נוירון לפני ההצבה, בפרמטרים)

שאלה 4
חזי החזאי רוצה לחזות האם למחרת ירד גשם בהינתן הטמפ', הלחות והרוח של היום הנוכחי.
נתונים הנתונים הבאים:


נניח ובחרו עבורנו באלגוריתם NN3 עם נירמול נתונים לפי טווח 
ערכים (בין 0 ל-1) ולפי מרחק אוקלידי מהתצפית.
כיצד נסווג את התצפית הבאה: טמפ' ממוצעת 21 מעלות, 40% לחות ורוח במהירות של 73 קמ"ש? (ציינו מרחק עבור כל תצפית, רשמו\סמנו מיהן התצפיות שעל פיהן סיווגתם את התצפית וכן מה סיווגה).
ערכי הנרמול: טמפ' מקסימלית: 52 מינימלית: 5
לחות מקסימלית: 100 מינימלית: 0
רוח מקסימלית: 180 מינימלית: 0

שאלה 5
בהינתן הטבלה משאלה 4, נקבע את הערכים הבדידים הבאים: 
Temp: (High: x>23) | (Low:x<23)
Humidity: (High: x>41) | (Low: x<41)
Wind: (High: x>100) | (Med: 35<x<100) | (Low: x<35)
הפעילו  את אלגוריתם id3 לבניית עץ החלטה, יש לבצע 2 רמות של פיצולים בלבד, של השורש ושל שני\שלושת בניו (במידת הצורך). במידה ומתקיים שיוויון בין שני מאפיינים – ניתן לבחור אחד מהם בצורה שרירותית.
הצג את העץ לאחר הפיצולים, רשום בו על פי אילו תכונות פוצל ובעלים רשום את הסיווגים שהתקבלו.
הצג את החישובים ורשום את הערכי ה-IG עבורם נבחרו התכונות.

כיצד נסווג את התצפית הבאה: טמפ' ממוצעת 21 מעלות, 50% לחות ורוח במהירות של 22 קמ"ש?

ללא קשר לסעיפים א' ו-ב', תן דוגמה ל S training set -עם מאפיין,A  
כך שה -Information gain  של המאפיינים השונים יהיה: 
א. IG(S,A)=1
ב. IG(S,A)=1/2
ג. IG(S,A)=0

שאלה 6
נניח עולם ובו 4 תכונות. 3 תכונות מתוך ה-4 בעלות 2 ערכים אפשריים ותכונה אחת בעלת 5 ערכים אפשריים. 
ישנן שלוש התנהגויות שונות בעולם (clasiffications). 
אנו מעוניינים ללמוד היפותזה שבוודאות של לפחות 97% תהיה עם טעות של לכל היותר 2%. בכמה דוגמאות, לכל הפחות, עלינו לאמן את המערכת שלנו? 
	




 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\מטלות\Programming-assignment--3\עבודה-3---Value-Iteration-and-Q-Learning.docx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>

Department of Software and Information Systems Engineering
Artificial Intelligence
(372-1-3502)
Exercise #3 – MDP and Reinforcement Learning
Due date: 15.1.2019


Coffee World
Problem Description

You would like to drink coffee. However, the coffee machine is in a different room and you do not want to go and get it yourself. So, you would like to build a robot and train it to get you coffee. The floor, unfortunately, is slippery, and so the robot may spill the coffee while going from the coffee machine to you. 

You goal: build a robot that can plan its path intelligently so as to maximize the expected utility of drinking coffee. Note that while drinking hot coffee is worth 100 points to you, every step the robot moves cools down the coffee, effectively reducing the number of points by half. So, if the robot performs two steps from the coffee machine and gives you the coffee, you get 25 points. 

Some details:
The reward for drinking a hot cup of coffee is 100. The reduced reward due to the time spent by the robot getting you the coffee is handled by a discount factor of 0.5. 
The probability of spilling the coffee depends on the specific location. For example, the probability of spilling the coffee at location (1,1) may be 0.5 while the probability of spilling the coffee at location (2,1) may be 0.25. 

To complete this assignment, you have to download the code from the following Git repository
https://github.com/ronistern/AAI-RL.git
Task #1: Reinforcement learning with Q-Learning
In this task, the agent does not know the probability of spilling the coffee in each grid cell and it needs to learn this over time. To this end, you will build an agent that runs Q learning and implements the -greedy action policy. 
Almost everything is already implemented for you in the EpsilonGreedyAgent class. You only need to fill in details in two methods:
computeNewQValue(state, action, newState, reward)
This method computes the Q value update rule. As a reminder, this rule is:

	Where  is the learning rate and  is the discount factor. Both of these values are already given to you in the code (see the code). 

chooseAction(state)
This method chooses which action to perform in the given state. You are suppose to implement the -greedy method, which means with probability  you choose a random action and with  probability you choose the action that maximize the Q value. 

To check your implementation, you can run the Runner class and observe the average discounted reward you get by running your agent on a randomly generated problem. These will be shown in the lines starting with "RL:". 

Task #2: Markov decision process and Value Iteration

In this task, the agent knows the probability of spilling the coffee in each grid cell. So, it can plan before acting, and then choose the best action. To this end, you will build an agent that runs the Value Iteration algorithm, and then choose the optimal action. 
Almost everything is already implemented for you in the ValueIterationAgent class. You only need to fill in details in one method:
bellmanUpdate(state)
This method computes the new V value or a state, using the current V values of all states. As a reminder, the Bellman update rule is as follows:
 
	Where  is the discount factor, which is already given to you in the code (see the code).
Also note that in the summation part, you only need to sum the states you may reach by performing a legal action in the current state.  

To solve this task, it is strongly recommended that you observe the code in the chooseAction(state) method that is already properly implemented. 


To check your implementation, you can run the Runner class and observe the average discounted reward you get by running your agent on a randomly generated problem. These will be shown in the lines starting with "MDP:". 

Scoring and submission instructions.

Solving one of the tasks will earn you 85 points. If you wish to earn 100 points, you need to solve both tasks. Exact submission instructions will be sent via Moodle. 



 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-10\Practice-10.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 





Practice session 10


Machine Learning

Machine learning
תחום העוסק בפיתוח אלגוריתמים המיועדים לאפשר למחשב "ללמוד" מתוך דוגמאות וניסיון



3
מורכב מ:
מצבים ()
פעולות ()
פונקציית מעבר ()
-          ההסתברות שאעבור ל-s’ בהינתן שאני ב-s ומבצע a
פונקציית שכר - Reward -   - שכר שאקבל מלהיות ב-s
                                   - - שכר שאקבל מלהיות ב-s ואבצע a
MDP (Markov Decision Processes)
A
B
C
D
T(A,a1,C)
a1
a2
a3
a4
אם פונקציות המעבר והשכר אינן ידועות?


4
Reinforcement learning
הסוכן מגיב לסביבה, הוא מקבל הערכה לפעולותיו (חיזוק)
לסוכן לא נאמר במפורש האם הפעולה היא הנכונה להשגת המטרה

סוכן
סביבה


פעולה
מצב
תגמול


5
Q-Learning
חזור פעמים רבות (כל פעם נקראת פרק)
אתחל מצב 
בצע עד אשר  הינו מצב סופי
בחר בפעולה  הטובה ביותר עבור  (על פי )
בצע פעולה  (אבחן )


  - קצב הלמידה (כאשר העולם לא דטרמיניסטי)
בביצוע  אנו עוברים מ- ל- ומקבלים שכר 


6
Q-Learning – פרק 1
		
		
				
				
				
				
				

טבלת ערכי 


הפעולה שנבחרה - 
עברנו ל-





7
Q-Learning – פרק 2
		
		
				
				
				
				
				

טבלת ערכי 


הפעולה שנבחרה - 
עברנו ל-





8
Q-Learning – פרק 2
		
		
				
				
				
				
				

טבלת ערכי 


הפעולה שנבחרה - 
עברנו ל-





9
Q-Learning
		
		
				
				
				
				
				

טבלת ערכי 


יכול להיות שלאחר  פרקים נתמקד בפעולה אחת ולא נתבונן בשאר הפעולות. למשל, ללכת מ- ל- ואז ל-


10
קבלת החלטות בזמן אמת משלבת שתי בחירות בסיסיות:
Exploitation – ביצוע הבחירה הטובה ביותר בהינתן המידע הנתון (הידוע)
Exploration – איסוף מידע נוסף


האסטרטגיה הטובה ביותר לטווח הארוך יכולה לשלב הקרבות בטווח הקצר
קיים צורך לאסוף מספיק מידע בשביל לקיים החלטות כוללניות, כאלו שיהיו 
טובות גם להחלטות עתידיות
Exploration vs. Exploitation


11
דוגמאות:
בחירת מסעדה
Exploitation – ללכת למסעדה המועדפת
Exploration – לנסות מסעדה חדשה
פרסומות און-ליין
Exploitation – הצגת הפרסומות המוצלחת ביותר
Exploration – הצגת פרסומת שונה\חדשה
קידוח נפט
Exploitation – לקדוח במקום בידוע הטוב ביותר
Exploration – לקדוח במקום חדש


Exploration vs. Exploitation


12

Exploitation – בחר בפעולה  בעלת ערך  מקסימלי (בהסתברות )
Exploration – חקור פעולה חדשה (בהסתברות )


13
Q-Learning
חזור פעמים רבות (כל פעם נקראת פרק)
אתחל 
בצע עד אשר  הינו מצב סופי
בחר בפעולה  הטובה ביותר עבור  (על פי )
בצע פעולה  (אבחן )


  - קצב הלמידה (כאשר העולם לא דטרמיניסטי)
בביצוע  אנו עוברים מ- ל- ומקבלים שכר 
אבל ב- מהמקרים
בחר רנדומלית
פעולה אחרת


14
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-11\Practice-11.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 





Practice session 11 


Machine Learning

Supervised learning
בהינתן זוגות של קלט ופלט תואמים, אלגוריתם למידה מנתח אותם ומסיק פונקציית מיפוי עבור דוגמאות חדשות 
Input	Output
	An arrow
	An arrow
	Not an arrow
	An arrow
	Not an arrow
	Not an arrow
	An arrow
Data

Supervised learning
Predictive Model

	?








3
רשת נוירונים – Artificial Neural Network
מודל חישובי המאפשר לבצע הדמיה של תהליכים המתרחשים במוח

רשת המכילה בדרך כלל מספר רב של יחידות קלט ופלט המקושרות זו לזו
 
צורת הקישור בין היחידות מדמה את אופן חיבור הנוירונים במוח




4
רשת נוירונים – Artificial Neural Network
רשת נוירונים מורכבת מ:
הנוירון – יחידת עיבוד המידע של הרשת
מבנה – קבוצת נוירונים וקישורים בינהם (לכל קישור יש משקל)
אלגוריתם למידה – שינוי המשקולות כדי לפתור משימת למידה ע"י סט אימון




5
רשת נוירונים – Artificial Neural Network
הנוירון - יחידת עיבוד המידע של הרשת
משקולות: משפיעות על איכות הרשת, 
 	      בדר"כ מאותחלות רנדומלית
הטיה: קלט קבוע עם משקולת מסויימת
פונקציית סכום: חישוב סכום משקל הקלט
פונקציית אקטיבציה: להגבלת גודל הטווח של הפלט


6

מבנה רשת הנוירונים
קיימים 3 סוגי מבני רשתות:

single-layer feed-forward

multi-layer feed-forward

recurrent
רשת נוירונים – Artificial Neural Network





























































z-1
z-1
z-1



input
hidden
output




7

נתונה רשת הנוירונים המאומנת הבאה.
כמו-כן נתונה טבלאות המשקולות הבאות.
מהו הפלט של כל נוירון בהינתן הקלט הבא?
רשת נוירונים – Artificial Neural Network
Attribute A = 0.5
Attribute B = -1.3
Attribute C = 3.2
Attribute D = 0.2

פונקציית ההפעלה המשותפת לכל הנוירונים:


	
	
	
	
	
	
	


8


רשת נוירונים

	
	


	
	


	
	

Attribute A = 0.5
Attribute B = -1.3
Attribute C = 3.2
Attribute C = 0.2

פונקציית ההפעלה המשותפת לכל הנוירונים:


	
	
	
	
	
	
	


9
אימון רשת נוירונים
נשים ב-W (המשקולות) ערכים רנדומליים
נעבור על סט האימון עד אשר עבור כל סט האימון השגיאה הריבועית 
הממוצעת (MSE) קטנה מערך סף כלשהו 
2.1. נשנה את המשקולות בהתבסס על הטעות ועל פי אלגוריתם הלמידה
רשת נוירונים – Artificial Neural Network


10
אימון Perceptron











11
כל עוד לא כל סט האימון מסווג נכון
בחר דגימה מסט האימון
אם הסיווג נכון, אל תבצע כלום
אם הסיווג הינו 0 במקום 1, שנה את הווקטור  כך:
					
אם הסיווג הינו 1 במקום 0, שנה את הווקטור  כך:
					

אימון Perceptron
פלט רצוי

 – קצב הלמידה


12


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
נתונות התצפיות הבאות לגבי לקוחות מועדפים בבנק 
ע"פ 2 התכונות שבטבלה (גיל, הכנסה חודשית)

מעוניינים לחזות מי יהיה לקוח מועדף לפי גילו והכנסתו

עליכם לאמן את רשת הנוירונים כך שתהיה קונסיסטנטית 
עם התצפיות 
גיל
הכנסה





 – כן
 – לא


13


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
גיל
הכנסה



 – כן
 – לא


=
    =  =
    = 


 










14


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
גיל
הכנסה



 – כן
 – לא


=
    =  =
    = 

 









15


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
גיל
הכנסה



 – כן
 – לא


=
    =  =
    = 






16


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
גיל
הכנסה



 – כן
 – לא


=
    =  =
    = 






17


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
גיל
הכנסה



 – כן
 – לא


=
    =  =
    = 

 











18


רשת נוירונים – Artificial Neural Network
לקוח מועדף	הכנסה חודשית (אש"ח)	גיל
לא	9	39
כן	16	40
כן	8	18
כן	12.2	24
לא	5	29
גיל
הכנסה



 – כן
 – לא













19
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-12\Practice-12.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 





Practice session 12


Machine Learning

Supervised learning
בהינתן זוגות של קלט ופלט תואמים, אלגוריתם למידה מנתח אותם ומסיק פונקציית מיפוי עבור דוגמאות חדשות 
Input	Output
	An arrow
	An arrow
	Not an arrow
	An arrow
	Not an arrow
	Not an arrow
	An arrow
Data

Supervised learning
Predictive Model

	?








3
 (K-Nearest Neighbors) K-NN
התצפיות המוכרות הדומות/קרובות לה ביותר Kסיווג תצפית חדשה לפי 
* מתאים לטווח ערכים רציף
מרחק מתצפית:
1) מרחק אוקלידי


Cosine similarity2) 


 

 A, B1) מרחק אוקלידי - בהינתן 2 וקטורים/תצפיות  
 - המרחק נקבע לפי הזווית בין הווקטורים Cosine similarity2) 


4
 (K-Nearest Neighbors) K-NN
דמיון בין בני אדם:

 גובה: 1.65 מ'	גובה: 1.77 מ'
משקל: 67 ק"ג	משקל: 82 ק"ג

הפרש גבהים: 0.12 מ'
הפרש משקלים: 15 ק"ג
מה נעשה? ננרמל!			



5
 (K-Nearest Neighbors) K-NN
i נרמול ערכי התצפית עבור ערך

1) לפי טווח הערכים (לערכים בין 0 ל-1)

2) לפי סטיית התקן




6
 (K-Nearest Neighbors) K-NN
   דמיון בין בני אדם:

 גובה: 1.65 מ'	גובה: 1.77 מ'
משקל: 67 ק"ג	משקל: 82 ק"ג

נרמול לפי טווח ערכים:
    גובה מנורמל:גובה מנורמל:  
משקל מנורמל:    משקל מנורמל: 		
1) לפי טווח הערכים (לערכים בין 0 ל-1)


נקבע:
גובה מקסימלי: 2.5 מ'
משקל מקסימלי: 200 ק"ג
גובה מינימלי: 0 מ'
משקל מינימלי: 0 ק"ג


7
 (K-Nearest Neighbors) K-NN
נתונות התצפיות הבאות לגבי אנשים שסבלו או לא סבלו מהתקף לב, ע"פ 4 התכונות שבטבלה (דופק, גיל, גובה, משקל),  מס"ד נתון לצרכי נוחות וזו אינה תכונה.

				

התקף לב	משקל	גובה	גיל	דופק	מס"ד
כן	72	170	35	70	1
לא	70	181	42	75	2
כן	82	165	50	80	3
לא	91	187	22	55	4
לא	65	174	30	60	5
כן	69	178	32	66	6


8
 (K-Nearest Neighbors) K-NN
בהינתן שמעוניינים לחזות נטייה להתקף לב. 
נניח שבחרו עבורנו באלגוריתם  ללא נירמול נתונים ולפי מרחק אוקלידי.
למרפאה הגיע אדם בן 37, עם דופק 59, גובהו 190 ומשקלו 87. 

כיצד המודל שנבחר יסווג את אותו אדם? 

 
				

התקף לב	משקל	גובה	גיל	דופק	מס"ד
כן	72	170	35	70	1
לא	70	181	42	75	2
כן	82	165	50	80	3
לא	91	187	22	55	4
לא	65	174	30	60	5
כן	69	178	32	66	6


9
מרחק מ-7	התקף לב	משקל	גובה	גיל	דופק	מס"ד
27.4	כן	72	170	35	70	1
25.5	לא	70	181	42	75	2
35.5	כן	82	165	50	80	3
16.3	לא	91	187	22	55	4
28.1	לא	65	174	30	60	5
23.3	כן	69	178	32	66	6
-	?	87	190	37	59	7
מרחק מ-7	התקף לב	משקל	גובה	גיל	דופק	מס"ד
	כן	72	170	35	70	1
	לא	70	181	42	75	2
	כן	82	165	50	80	3
	לא	91	187	22	55	4
	לא	65	174	30	60	5
	כן	69	178	32	66	6
-	?	87	190	37	59	7
 (K-Nearest Neighbors) K-NN
ב) בהינתן שמעוניינים לחזות נטייה להתקף לב. 
נניח שבחרו עבורנו באלגוריתם  ללא נירמול נתונים ולפי מרחק אוקלידי.
למרפאה הגיע אדם בן 37, עם דופק 59, גובהו 190 ומשקלו 87. 

כיצד המודל שנבחר יסווג את אותו אדם? 

שלוש התצפיות הקרובות 
הן – 2,4,6
והסיווג שיתקבל הוא 'לא'

				


מרחק מ-7	התקף לב	משקל	גובה	גיל	דופק	מס"ד
27.4	כן	72	170	35	70	1
25.5	לא	70	181	42	75	2
35.5	כן	82	165	50	80	3
16.3	לא	91	187	22	55	4
28.1	לא	65	174	30	60	5
23.3	כן	69	178	32	66	6
-	?	87	190	37	59	7
דופק
גיל
גובה
משקל

לא חלק מהטבלה, רק לצורך בדיקה


10
 - Entropyאנטרופיה

מדד לגודלו האפקטיבי של מרחב התפלגות 
(מדד לאי ודאות)


אםS  הוא מרחב הסתברות סופי עם ההסתברויות 
הבאות  המייצגות את המאורעות השונים 
במרחב, אזי האנטרופיה של S:

לדוגמא: כאשר יש 2 מאורעות (+,-)


11
 - Entropyאנטרופיה
נניח ונטיל מטבע הוגן (0.5 - פלי, 0.5 - עץ)


נניח ונטיל מטבע שאינו הוגן (0.8 - פלי, 0.2 - עץ)


נניח ונטיל מטבע נוסף שאינו הוגן (0.99 - פלי, 0.01 - עץ)

חוסר ודאות גבוה
חוסר ודאות נמוך



12
Information Gain

Aלפי  S- "הרווח" שמקבלים מהאינפורמציה מסיווג IG(S,A)





Sהאנטרופיה של 
(לפני הפיצול)
A לאחר פיצול לפי S סכום האנטרופיה של 
(אחרי הפיצול)


13
Information Gain - דוגמא

נרצה לדעת עבור איזה מאפיין כדאי לפצל

רשומה מספר	ממוצע בגרויות	פסיכומטרי	סיים את התואר
1	גבוה	גבוה	כן
2	גבוה	נמוך	לא
3	גבוה	גבוה	כן
.....	.....	.....	.....
פסיכומטרי
ממוצע בגרויות
נמוך
גבוה
נמוך
גבוה
[+72, -28]
[+72, -28]
[+17, -8]
[+55, -20]
[+25, -17]
[+47, -11]


14
Information Gain - דוגמא

נרצה לדעת עבור איזה מאפיין כדאי לפצל

נסמן:
מ.בגרויות - A
פסיכומטרי - P

פסיכומטרי
ממוצע בגרויות
נמוך
גבוה
נמוך
גבוה
[+72, -28]
[+72, -28]
[+17, -8]
[+55, -20]
[+25, -17]
[+47, -11]


לפני הפיצול



נבחר לפצל לפי A


15
(Iterative Dichotomiser 3) ID3

אלגוריתם היוצר עץ החלטה מבסיס נתונים
בכל קודקוד נבחר את המאפיין שממקסם את ה-IG
נעצור כאשר: 
בקודקוד מסוים כל הדגימות מאותה החלטה
לא קיימים מאפיינים נוספים לפצל לפיהם ואז
נלך על פי חוק הרוב 


16
ID3 - דוגמא
נתון סט דוגמאות מתוייגות ('+' או '-') 
לכל אחד משלושת המאפיינים יש שני ערכים אפשריים

א( ציירו את העץ המתקבל בריצת אלגוריתם ID3 
מספר התצפיות המינימאלי בעלה הוא 1 
בכל קודקוד בעץ ציינו מה ה-information gain של התכונה שנבחרה 
בכל עלה ציינו את הסיווג הניתן
	Temp	Humidity	Cloudy	Rain
Ex1	High	High	Yes	+
Ex2	High	Low	Yes	-
Ex3	High	High	Yes	+
Ex4	High	Low	No	-
Ex5	High	High	No	-
Ex6	Low	Low	Yes	-
Ex7	Low	High	No	+
Ex8	Low	Low	Yes	+


17
ID3

[+4,-4]


18
ID3

	Temp	Humidity	Cloudy	Rain
Ex1	High	High	Yes	+
Ex2	High	Low	Yes	-
Ex3	High	High	Yes	+
Ex4	High	Low	No	-
Ex5	High	High	No	-
Ex6	Low	Low	Yes	-
Ex7	Low	High	No	+
Ex8	Low	Low	Yes	+








19
ID3
Humidity
0.189



High
Low
[+3,-1]
[+1,-3]
[+4,-4]


20
ID3

	Temp	Humidity	Cloudy	Rain
Ex1	High	High	Yes	+
Ex2	High	Low	Yes	-
Ex3	High	High	Yes	+
Ex4	High	Low	No	-
Ex5	High	High	No	-
Ex6	Low	Low	Yes	-
Ex7	Low	High	No	+
Ex8	Low	Low	Yes	+








21
ID3
Humidity
0.189
Cloudy
0.311


High
Low
[+3,-1]
[+1,-3]

+
No
Yes
[+2,0]
[+1,-1]
[+4,-4]


22
ID3

	Temp	Humidity	Cloudy	Rain
Ex1	High	High	Yes	+
Ex2	High	Low	Yes	-
Ex3	High	High	Yes	+
Ex4	High	Low	No	-
Ex5	High	High	No	-
Ex6	Low	Low	Yes	-
Ex7	Low	High	No	+
Ex8	Low	Low	Yes	+








23
ID3
Humidity
0.189
Cloudy
0.311
Temp
0.311
High
Low
[+3,-1]
[+1,-3]
No
Yes
-

High
Low

+
[+2,0]
[+1,-1]
[0,-2]
[+1,-1]
[+4,-4]


24
ID3
	Temp	Humidity	Cloudy	Rain
Ex1	High	High	Yes	+
Ex2	High	Low	Yes	-
Ex3	High	High	Yes	+
Ex4	High	Low	No	-
Ex5	High	High	No	-
Ex6	Low	Low	Yes	-
Ex7	Low	High	No	+
Ex8	Low	Low	Yes	+



אם  נסווג כ- '-'
אם  נסווג כ- '+'



25
ID3
Humidity
0.189
Cloudy
0.311
Temp
0.311
High
Low
[+3,-1]
[+1,-3]
Temp
1
+
No
Yes
-
+
Low
High
-

High
Low
[+2,0]
[+1,-1]
[0,-2]
[+1,-1]
[0,-1]
[+1,0]
[+4,-4]


26
ID3
	Temp	Humidity	Cloudy	Rain
Ex1	High	High	Yes	+
Ex2	High	Low	Yes	-
Ex3	High	High	Yes	+
Ex4	High	Low	No	-
Ex5	High	High	No	-
Ex6	Low	Low	Yes	-
Ex7	Low	High	No	+
Ex8	Low	Low	Yes	+


מכיוון שנגמרו המאפיינים, יש לבחור על פי הרוב
ומכיוון שיש שיוויון בין '+' ל-'-' ניתן לבחור שרירותית




27
ID3
Humidity
0.189
Cloudy
0.311
Temp
0.311
High
Low
[+3,-1]
[+1,-3]
Temp
1
+
No
Yes
-
+
Low
High
-
+/-
High
Low
[+2,0]
[+1,-1]
[0,-2]
[+1,-1]
[0,-1]
[+1,0]
[+4,-4]


28
ID3
ב( נניח והגיעה הדגימה הבאה:
איך נסווג אותה על סמך העץ מסעיף א'?
	Temp	Humidity	Cloudy	Rain
Ex9	High	High	No	?


29
ID3
Humidity
0.189
Cloudy
0.311
Temp
0.311
High
Low
[+3,-1]
[+1,-3]
Temp
1
+
No
Yes
-
+
Low
High
-
+/-
High
Low
[+2,0]
[+1,-1]
[0,-2]
[+1,-1]
[0,-1]
[+1,0]
[+4,-4]
	Temp	Humidity	Cloudy	Rain
Ex9	High	High	No	?






30
ID3
	Temp	Humidity	Cloudy	Rain
Ex9	High	High	No	?
נלך לעומק העץ שבנינו ונקבל כי יש לסווגה כ-'-'
כלומר, נסיק על פי העץ שבנינו כי לא ירד גשם
	Temp	Humidity	Cloudy	Rain
Ex9	High	High	No	-
ב( נניח והגיעה הדגימה הבאה:
איך נסווג אותה על סמך העץ מסעיף א'?


31
Overfitting
אחת הבעיות הגדולות בעצי החלטה:
המודל מתאר שגיאה אקראית או רעש
יכול להיגרם כאשר משתמשים במאפיינים רבים או בכאלו שאינם רלוונטים להחלטה
לדוגמא: שימוש בשם פרטי כדי לסווג תוצאות בדיקה


32
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-1\Practice-1.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 

דור עצמון
מייל: dorat@post.bgu.ac.il
שעות קבלה: יום ראשון 14:00-15:00 (בתאום מראש)

3 מטלות תכנותיות

בינה מלאכותית


2

Practice session 1

Blind Search
Graph Representation


3
חיפוש
בהינתן:
 גרף - 
 קודקוד התחלתי - 
 קודקוד סופי - 
מטרות:
 למצוא מסלול מ- ל-
 לענות האם קיים מסלול מ- ל-?
 למצוא מסלול אופטימאלי מ- ל- 
 למצוא את ה-





s
g


4
אלגוריתמי חיפוש
BFS (Breadth-first search)


DFS (Depth-first search)


UCS (Uniform Cost Search)

s
A
B
C
g
1
1
2
3
1
1
s
A
B
C
g
1
1
2
3
1
1
s
A
B
C
g
1
1
2
3
1
1


5
אתחל מבנה נתונים (נקרא )
הוסף את  ל-
כל עוד ה- לא ריק בצע:
 
 אם 
 החזר את המסלול ל-
 אחרת
הכנס את השכנים של  ל-

אלגוריתם חיפוש אבסטרקטי - רעיון
A
S
B
C
G
Open List:

Open List: S

Open List: S

current = S S

Open List: G, A, C



6
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
אלגוריתם חיפוש אבסטרקטי  - BFS


7
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):

A
S
B
C
G
1
1
1
1
3
2
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
אלגוריתם חיפוש אבסטרקטי  - BFS


8
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	          //Distance from Vs
3.	Vs.h = hFunc( Vs , Vg )   //Evaluation of distance to goal    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
אלגוריתם חיפוש אבסטרקטי  - BFS


9
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null	     //The previous vertex
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
אלגוריתם חיפוש אבסטרקטי  - BFS


10
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
אלגוריתם חיפוש אבסטרקטי  - BFS


11
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
Size = 1
אלגוריתם חיפוש אבסטרקטי  - BFS


12
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )   
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
Size = 0
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS


13
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 //Goal test 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
g= 
h= 
Size = 0
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS


14
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g=  
h= 
g= 
h= 
g= 
h= 
Size = 0
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS


15
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g=  
h= 
g= 
h= 
g= 
h= 
Size = 0
Current = S
Close List:


אלגוריתם חיפוש אבסטרקטי  - BFS


16
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g=  
h= 
g= 
h= 
g= 3 
h= 0 
Size = 0
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS
Close List:




17
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g=  
h= 
g= 
h= 
Size = 0
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




18
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S, G

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g=  
h= 
g= 
h= 
Size = 1
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




19
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	      
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
Size = 1
Current = S
Open List (Queue):
S, G

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




20
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 
h= 
g= 
h= 
g= 
h= 
Size = 1
Current = S
Open List (Queue):
S, G

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




21
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0 
g= 
h= 
g= 
h= 
Size = 1
Current = S
Open List (Queue):
S, G

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




22
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	      
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 
h= 
g= 
h= 
Size = 1
Current = S
Open List (Queue):
S, G

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




23
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
Open List (Queue):
S, G, A

A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 
h= 
g= 
h= 
Size = 2
Current = S
אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




24
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 
h= 
g= 
h= 
Size = 2
Current = S
Open List (Queue):
S, G, A

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




25
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 
h= 
g= 
h= 
Size = 2
Current = S
Open List (Queue):
S, G, A

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




26
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0 
g= 
h= 
Size = 2
Current = S
Open List (Queue):
S, G, A

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




27
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 2
Current = S
Open List (Queue):
S, G, A

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




28
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 3
Current = S
Open List (Queue):
S, G, A, C

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:




29
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	      
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 3
Current = S
Open List (Queue):
S, G, A, C

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:
S



30
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	  
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 3
Current = S
Open List (Queue):
S, G, A, C

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:
S



31
Open List (Queue):
S, G, A, C

Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	      
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 3
Current = G
אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:
S



32
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	      
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	 
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	 
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 3
Current = G
Open List (Queue):
S, G, A, C

אלגוריתם חיפוש אבסטרקטי  - BFS
g= 3 
h= 0 
Close List:
S



33
Search( G(V,E) , Vs , Vg )
1.	InitOpen()
2.	Vs.g = 0	   	 
3.	Vs.h = hFunc( Vs , Vg )    
4.	Vs.prev = null 	      
5.	AddToOpen( Vs )
6.	While( OpenSize() > 0 )
6.1	  Current = GetBest()
6.2	  If( Current == Vg )  	      
6.2.1	       Return GetPath( Current )
6.3	  Else
6.3.1	       Foreach neighbor Vn of Current
6.3.1.1	If(( !IsClosed( Vn ) AND !IsOpen( Vn ) ) OR 
			     Vn.g > current.g+E(current,Vn).cost)
6.3.1.1.1		Vn.g = Current.g + E(Current,Vn).cost
6.3.1.1.2		Vn.h = hFunc( Vn , Vg )
6.3.1.1.3		Vn.prev = Current
6.3.1.1.4		AddToOpen( Vn )
6.4	Close( current )
7.	Return false
A
S
B
C
G
1
1
1
1
3
2
g= 0
h= 0
g= 1
h= 0
g= 1 
h= 0
g= 
h= 
Size = 3
Current = G
Open List (Queue):
S, G, A, C

אלגוריתם חיפוש אבסטרקטי  - BFS
prev= S
prev= null
g= 3 
h= 0 
Close List:
S



34
אלגוריתם חיפוש אבסטרקטי

מה ניתן לשנות כדי שהאלגוריתם ייצג:

 DFS

Uniform Cost Search (UCS) 

					
אלגוריתם חיפוש אבסטרקטי

מה ניתן לשנות כדי שהאלגוריתם ייצג:

 DFS						  OpenList - Stack               

Uniform Cost Search (UCS) 		OpenList - Priority Queue

					
ייצוג ע"י גרף

 קודקוד - מייצג מצב כלשהו
 צלע - אופרטור, מייצגת מעבר ממצב למצב אחר
 מצב התחלתי (1) ומצבים סופיים (לפחות 1)

בהינתן בעיה כלשהי:
 נגדיר קודקודים 
 נגדיר צלעות
 נפתור את הבעיה באמצעות אלגוריתם חיפוש


37
בעיית הפנקייק
 
נתון - ערימת  פנקייקים, כל פנקייק בגודל שונה
המטרה - לסדר את הערימה בסדר עולה לפי הגודל
לצורך סידור הערימה ניתן להשתמש במרית
דוגמה להפיכה 3 הפנקייקים העליונים:


- הגדירו את המצבים, את המצב ההתחלתי, את המצב הסופי ואת האופרטורים


38
מצב: 		 
אופרטור: 	 
מצב התחלתי:  
מצב סופי:
מצב: 		מערך, במקום  במערך - ערך כגודל הפנקייק במקום  בערימה
אופרטור: 	הפיכת הסדר של  הפנקייקים העליונים ()
מצב התחלתי: בהתאם לקלט נבנה מצב התחלתי על פי הגדרת המצב
מצב סופי: 	 (מערך ממוין)
בעיית הפנקייק
ייצוג ע"י גרף
 
בעיית הפנקייק



Graph Representation

2	1	4	6	3	5
0	1	2	3	4	5

0	1	2	3	4	5

0	1	2	3	4	5

0	1	2	3	4	5

0	1	2	3	4	5

0	1	2	3	4	5
4	1	2	6	3	5
6	4	1	2	3	5
3	6	4	1	2	5
5	3	6	4	1	2
1	2	4	6	3	5

0	1	2	3	4	5
1	2	3	4	5	6
goal
בעיית הסוכן הנוסע 
 
נתון - גרף ממושקל ולא מכוון , מוגדרת נקודת התחלה 
המטרה - מציאת מסלול קצר ביותר העובר דרך כל הקדקודים ב-  
המתחיל ומסתיים ב- 
מותר לעבור בכל קודקוד ובכל קשת יותר מפעם אחת 


- הגדירו את המצבים, את המצב ההתחלתי, את המצב הסופי ואת האופרטורים
S
a
b
c
2
6
5
5
7
4


41
מצב:		1) קבוצת הקודקודים שכבר בוקרו ()
		2) מיקום נוכחי ()	 
אופרטור: 	עבור כל שכן  של קודקוד בגרף :
	 	1) נצרף את  לקבוצת הקודקודים שבוקרו (במידה ולא נמצא שם)
	 	2) נגדיר את  כ-
מצב התחלתי: 1) {} (קבוצה ריקה)				2)  (קודקוד התחלה)
מצב סופי: 	 1)  (קבוצת כל הקודקודים בגרף)		2) 
מצב:		
		 	 
אופרטור: 	 
	 	 
	 	 
מצב התחלתי:  
מצב סופי: 	 
בעיית הסוכן הנוסע
ייצוג ע"י גרף
 
בעיית הסוכן הנוסע

G


Graph Representation
{}
s
{s}
b
{s}
c
{s}
a
{s,a}
c
{s,a}
s
{s,a}
b
{s,a,b,c}
s
goal
S
a
b
c
2
6
5
5
7
4
2
7
5
2
6
5
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-2\Practice-2.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 


Practice session 2

Graph Representation
Heuristics
ייצוג ע"י גרף

 קודקוד - מייצג מצב כלשהו
 צלע - אופרטור, מייצגת מעבר ממצב למצב אחר
 מצב התחלתי (1) ומצבים סופיים (לפחות 1)

בהינתן בעיה כלשהי:
 נגדיר קודקודים 
 נגדיר צלעות
 נפתור את הבעיה באמצעות אלגוריתם חיפוש
ייצוג ע"י גרף
 
בעיית הסוכן הנוסע

G


Graph Representation
{}
s
{s}
b
{s}
c
{s}
a
{s,a}
c
{s,a}
s
{s,a}
b
{s,a,b,c}
s
goal
s
a
b
c
2
6
5
5
7
4
2
7
5
2
6
5
בעיית הטנק
 
נתון - , נקודת התחלה וצידוד התחלתי של הטנק
מטרה - מציאת סדרת פעולות (סיבוב, תנועה קדימה) שיובילו את הטנק מהמצב ההתחלתי למצב סופי רצוי
ניתן לנוע צעד אחד קדימה או להסתובב 90 מעלות


- הגדירו את המצבים, את המצב ההתחלתי, את המצב הסופי ואת האופרטורים
			
			
			
			

נתון – ערימת  פנקייקים, כל פנקייק בגודל שונה (הקטן בגודל 1 והגדול בגודל ). 
המטרה - לסדר את הערימה בסדר עולה לפי הגודל כך שהפנקייק הגדול ביותר (שגודלו ) יהיה בתחתית והקטן ביותר (שגודלו 1) יהיה עליון. 
לצורך סידור הערימה ניתן להשתמש במרית ולהפוך בכל פעולה את הסדר של  () הפנקייקים העליונים. 

5
מצב:		    1) מיקום הטנק		2) צידוד הטנק
אופרטור:	    1) סע קדימה		2) צדד  ימינה	3) צדד  שמאלה
מצב התחלתי:  בהתאם לקלט מיקום וצידוד התחלתיים
מצב סופי:	 בהתאם לקלט מיקום וצידוד סופיים
בעיית הטנק
מצב:		 
אופרטור:	 
מצב התחלתי:  
מצב סופי:	  
ייצוג ע"י גרף
 
בעיית הטנק


Graph Representation
(2,3)
RIGHT
			
			
			
			
(2,3)
UP
(2,3)
DOWN
(3,3)
RIGHT
בעיית כיסוי צלעות - Edge cover
 
נתון - גרף לא ממושקל ולא מכוון 
המטרה - מציאת קבוצת צלעות מינימאלית המכסה את כלל הקודקודים



- הגדירו את המצבים, את המצב ההתחלתי, את המצב הסופי ואת האופרטורים
a
b
c
d
a
b
c
d

נתון – ערימת  פנקייקים, כל פנקייק בגודל שונה (הקטן בגודל 1 והגדול בגודל ). 
המטרה - לסדר את הערימה בסדר עולה לפי הגודל כך שהפנקייק הגדול ביותר (שגודלו ) יהיה בתחתית והקטן ביותר (שגודלו 1) יהיה עליון. 
לצורך סידור הערימה ניתן להשתמש במרית ולהפוך בכל פעולה את הסדר של  () הפנקייקים העליונים. 

8
מצב:		    קבוצת צלעות
אופרטור:	    הוספת צלע שאינה בקבוצה לקבוצת הצלעות
מצב התחלתי: {} (קבוצה ריקה)
מצב סופי:	   קבוצת צלעות כך שכל קודקוד בגרף מחובר לפחות לאחת מהן
בעיית כיסוי צלעות - Edge cover
מצב:		 
אופרטור:	 
מצב התחלתי:  
מצב סופי:	
ייצוג ע"י גרף
 
בעיית כיסוי צלעות - Edge cover
G


Graph Representation
{}
a
b
c
d
{ab}
{ac}
{ad}
{bc}
{bd}
{cd}
goal
{cd,ab}
{ac,bd}
{bc,ad}
goal
goal
Blind (un-informed) Search

VS.

Heuristic (informed) Search 
היוריסטיקה ()
כלל חשיבה המבוסס על הגיון פשוט או אינטואיציה 
מציע דרך קלה ומהירה לקבלת החלטות ללא התעמקות ובמחיר דיוק נמוך
חוקרים הדגימו כיצד המח האנושי נוהג להשתמש בטכניקות היוריסטיות לקבלת החלטות במהירות

פוקציה היוריסטית
קלט: מצב
פלט: הערכה של המרחק מהמצב למטרה () הקרובה ביותר

היוריסטיקה ()
אדמיסיבליות ()
פונקציה היוריסיטית תקרא אדמיסיבילית אם אינה מעריכה אף פעם 
מעל ה"מחיר" האמיתי להגעה למטרה.

הגדרה פורמלית:
	
	כאשר: 
		-  פונקציה היוריסטית
		-  הינו מצב במרחב המצבים
		-  הינו המחיר המינימלי מ- למטרה () הקרובה ביותר


היוריסטיקה ()
אדמיסיבליות ()
	

	












אדמיסיבלי
לא אדמיסיבלי




היוריסטיקה ()
קונסיסטנטיות ()
פונקציה היוריסיטית תקרא קונסיסטנטיות אם הפרש ההיוריסטיקות בין כל זוג קודקודים אינו גדול ממחיר המעבר (הצלע) בינהם

הגדרה פורמלית:
	 		
	כאשר: 
		-  הינו היורש המיידי של 
		-  הינו המטרה ()
		- הינו המחיר של הצלע בין  ל-

היוריסטיקה ()
קונסיסטנטיות ()
	

	
S

G

S

G

קונסיסטנטי
לא קונסיסטנטי



















היוריסטיקה ()
הוכח: פונקציה קונסיסטנטית בהכרח גם אדמיסיבילית

אינדוקציה: על מספר הקשתות במסלול האופטימלי של כל קודקוד למטרה
בסיס:   אם המסלול האופטימלי מקודקוד  מכיל  קשתות, אז    
	     לפי הגדרה:  לכן ולכן אדמיסיבילי
הנחה:  נניח שכל קודקוד  שהמסלול האופטימלי שלו מכיל  צלעות 
	    מקיים: 	 ונוכיח עבור .
הוכחה: נניח קודקוד  שהמסלול האופטימלי שלו מכיל  קשתות,
	     המסלול מורכב מקשת לאחד השכנים  בעל מסלול אופטימלי המכיל  קשתות:
	    
אדמיסיבליות ()
	
קונסיסטנטיות ()




לפי הגדרת הקונסיסטנטיות 

  לפי הגדרת האדמיסיביליות:  

 שייך למסלול האופטימלי של  אחד מהשכנים 



בעיית הפנקייק
 
נתון - ערימת  פנקייקים, כל פנקייק בגודל שונה
המטרה - לסדר את הערימה בסדר עולה לפי הגודל
לצורך סידור הערימה ניתן להשתמש במרית
דוגמה להפיכה 3 הפנקייקים העליונים:


- הגדירו את המצבים, את המצב ההתחלתי, את המצב הסופי ואת האופרטורים

נתון – ערימת  פנקייקים, כל פנקייק בגודל שונה (הקטן בגודל 1 והגדול בגודל ). 
המטרה - לסדר את הערימה בסדר עולה לפי הגודל כך שהפנקייק הגדול ביותר (שגודלו ) יהיה בתחתית והקטן ביותר (שגודלו 1) יהיה עליון. 
לצורך סידור הערימה ניתן להשתמש במרית ולהפוך בכל פעולה את הסדר של  () הפנקייקים העליונים. 

18
מצב: 		 
אופרטור: 	 
מצב התחלתי:  
מצב סופי:
מצב: 		מערך, במקום  במערך - ערך כגודל הפנקייק במקום  בערימה
אופרטור: 	הפיכת הסדר של  הפנקייקים העליונים ()
מצב התחלתי: בהתאם לקלט נבנה מצב התחלתי על פי הגדרת המצב
מצב סופי: 	 (מערך ממוין)
בעיית הפנקייק
 
היוריסטיקה: היוריסטיקת ההפרשים
		עבור כל זוג פנקייקים שכנים (במיקום  ו-) :
		אם הפרש הגדלים בין הפנקייקים גדול מ-1
			הוסיפו 1 ליוריסטיקה הכללית
		אם הפנקייק התחתון בערימה אינו הפנקייק הגדול היותר 				הוסיפו 1 ליוריסיטקה הכללית
בעיית הפנקייק
 
היוריסטיקה:
 
היוריסטיקה:
בעיית הפנקייק
2
1
4
6
3
5













 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-3\Practice-3.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 


Practice session 3

Heuristics

 
היוריסטיקה: היוריסטיקת ההפרשים
		עבור כל זוג פנקייקים שכנים (במיקום  ו-) :
		אם הפרש הגדלים בין הפנקייקים גדול מ-1
			הוסיפו 1 ליוריסטיקה הכללית
		אם הפנקייק התחתון בערימה אינו הפנקייק הגדול היותר 				הוסיפו 1 ליוריסיטקה הכללית
בעיית הפנקייק
 
היוריסטיקה:
 
היוריסטיקה:
בעיית הפנקייק
2
1
4
6
3
5














  הוכחת אדמיסיביליות:
נניח בשלילה שקיים פתרון ממצב  בעל מספר צעדים קטן מההיוריסטיקה.
עבור המצב , כמות הפנקייקים השכנים שהפרשם גדול מ- הוא  ומספר הצעדים לפתרון הוא  כך ש- .
בצעד יחיד ניתן לשנות שכנות של  פנקייקים בלבד ולכן  קטן ב- לכל היותר.
ב- צעדים ניתן להגיע ל- שאינו קטן מ- 
 לפי ההנחה ש- .
לפי ההיוריסטיקה, במצב המטרה אין הפרשים בין השכנים ולכן , 
סתירה לכך שלאחר  צעדים  ולכן אדמיסיבילית

בעיית הפנקייק
בעיית כיסוי צלעות - Edge cover
 
נתון - גרף לא ממושקל ולא מכוון 
המטרה - מציאת קבוצת צלעות מינימאלית המכסה את כלל הקודקודים



- הגדירו את המצבים, את המצב ההתחלתי, את המצב הסופי ואת האופרטורים
a
b
c
d
a
b
c
d

נתון – ערימת  פנקייקים, כל פנקייק בגודל שונה (הקטן בגודל 1 והגדול בגודל ). 
המטרה - לסדר את הערימה בסדר עולה לפי הגודל כך שהפנקייק הגדול ביותר (שגודלו ) יהיה בתחתית והקטן ביותר (שגודלו 1) יהיה עליון. 
לצורך סידור הערימה ניתן להשתמש במרית ולהפוך בכל פעולה את הסדר של  () הפנקייקים העליונים. 

6
מצב:		    קבוצת צלעות
אופרטור:	    הוספת צלע שאינה בקבוצה לקבוצת הצלעות
מצב התחלתי: {} (קבוצה ריקה)
מצב סופי:	   קבוצת צלעות כך שכל קודקוד בגרף מחובר לפחות לאחת מהן
בעיית כיסוי צלעות - Edge cover
מצב:		 
אופרטור:	 
מצב התחלתי:  
מצב סופי:	
 
היוריסטיקה:	

 
בעיית כיסוי צלעות - Edge cover
 
היוריסטיקה:	
הוכחת אדמיסיביליות: 
בכל הוספת צלע, מספר הקודקודים שטרם כוסו קטן ב-,  או 
ההיוריסטיקה קטנה ב- , , בהתאם 
ולכן תמיד מתקיים: 
במצב המטרה,  מכיוון שכל הקודקודים מכוסים 
לכן קונסיסטנטית ומכך גם אדמיסיבילית 
בעיית שלושת הכדים
ישנם 3 כדים בעלי הנפחים הבאים: 8 ליטר, 5 ליטר, 3 ליטר
כד 8 הליטר מלא במים והכדים 5,3 ליטר ריקים 
המשימה: הכדים 5,8 ליטר יהיו מלאים ב-4 ליטר תוך העברת מינ' מים
בפעולה אחת ניתן לשפוך את כל המים מכד לכד אחר
8
5
3
 היוריסטיקה: 
 
  - כד 5 ליטר  - כד 8 ליטר

 היוריסטיקה:
בעיית שלושת הכדים
 
אלגוריתם המוצא מסלול אופטימלי בגרף (כאשר ההיוריסטיקה אדמיסיבילית)
נעזר בתור עדיפויות על פי פונקציית העלות 

 - המרחק בין קודקוד ההתחלה לקודקוד  
 - הערכה למרחק בין  לקודקוד הסיום

 

A*

בשוויון f מתעדף על פי h נמוך יותר
11
 




 

S
A
B
C
G
H
I
D
E
F
J
K
G
1
2
3
3
2
4
4
2
1
1
2
2
h=5
h=2
h=2
h=3
h=0
h=0
h=2
h=1
h=2
h=1
h=3
h=2
S									
4									
0									
4									
OpenList:
h=4
f
g
h
 




 

S
A
B
C
G
H
I
D
E
F
J
K
G
1
2
3
3
2
4
4
2
1
1
2
2
h=5
h=2
h=2
h=3
h=0
h=0
h=2
h=1
h=2
h=1
h=3
h=2
B	C	A							
4	5	6							
2	3	1							
2	2	5							
OpenList:
h=4
f
g
h

 

S
A
B
C
G
H
I
D
E
F
J
K
G
1
2
3
3
2
4
4
2
1
1
2
2
h=5
h=2
h=2
h=3
h=0
h=0
h=2
h=1
h=2
h=1
h=3
h=2
H	C	I	G	A					
5	5	5	6	6					
4	3	3	6	1					
1	2	2	0	5					
OpenList:
h=4
f
g
h

 

S
A
B
C
G
H
I
D
E
F
J
K
G
1
2
3
3
2
4
4
2
1
1
2
2
h=5
h=2
h=2
h=3
h=0
h=0
h=2
h=1
h=2
h=1
h=3
h=2
C	I	G	A						
5	5	6	6						
3	3	6	1						
2	2	0	5						
OpenList:
h=4
f
g
h

 

S
A
B
C
G
H
I
D
E
F
J
K
G
1
2
3
3
2
4
4
2
1
1
2
2
h=5
h=2
h=2
h=3
h=0
h=0
h=2
h=1
h=2
h=1
h=3
h=2
G	I	J	K	A					
5	5	6	6	6					
5	3	5	4	1					
0	2	1	2	5					
OpenList:
h=4
f
g
h


16

 

S
A
B
C
G
H
I
D
E
F
J
K
G
1
2
3
3
2
4
4
2
1
1
2
2
h=5
h=2
h=2
h=3
h=0
h=0
h=2
h=1
h=2
h=1
h=3
h=2
I	J	K	A						
5	6	6	6						
3	5	4	1						
2	1	2	5						
OpenList:
h=4
מסלול: 
S -> C -> G
משקל:
5
f
g
h


17
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-4\Practice-4.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 


Practice session 4

Heuristics
Planning


2
תרגיל
 

 
A  - שורש עץ חיפוש	   G - צומת המטרה
עלות מעבר בין צמתים סמוכים (ערך הקשתות) היא 1
הערך שמופיע בסוגריים הינו ההיוריסטיקה

לכל אחת מן האסטרטגיות החיפוש הבאות רשמו:
רשימת הצמתים המורחבים (expanded) על פי הסדר
המסלול שהוחזר


3
 



DFS (Depth First Search)
 

 

צמתים שהורחבו:

A									
OpenList:
(Stack)



4
 



DFS (Depth First Search)
 

 

צמתים שהורחבו: A 

D	C	B							
OpenList:
(Stack)





5
 



DFS (Depth First Search)
 

 

צמתים שהורחבו: A, B 

D	C	F	E						
OpenList:
(Stack)






6
 



DFS (Depth First Search)
 

 

צמתים שהורחבו: A, B, E 

D	C	F	G	K					
OpenList:
(Stack)







7
 



DFS (Depth First Search)
 

 

צמתים שהורחבו: A, B, E, K 

D	C	F	G						
OpenList:
(Stack)






8
 



DFS (Depth First Search)
 

 

צמתים שהורחבו: A, B, E, K, G 
מסלול שהוחזר: A, B, E, G
D	C	F							
OpenList:
(Stack)





9
 
אלגוריתם המחפש לעומק באיטרציות
בכל איטרציה מחפשים לעומק (DFS) עד עומק ערך הסף
בכל איטרציה נגדיל את ערך הסף ב-1
DFID (Depth first Iterative deepening)
 

DFID
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו:

A									
OpenList:
(Stack)
Threshold: 0



11
DFID (Depth first Iterative deepening)
									
OpenList:
(Stack)
Threshold: 0
 

צמתים שהורחבו: 
A



12
DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A

A									
OpenList:
(Stack)
Threshold: 1



13
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A

D	C	B							
OpenList:
(Stack)
Threshold: 1





14
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B

D	C								
OpenList:
(Stack)
Threshold: 1




15
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C

D									
OpenList:
(Stack)
Threshold: 1



16
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D

									
OpenList:
(Stack)
Threshold: 1


17
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D

A									
OpenList:
(Stack)
Threshold: 2



18
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D, A

D	C	B							
OpenList:
(Stack)
Threshold: 2





19
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D, A, B

D	C	F	E						
OpenList:
(Stack)
Threshold: 2






20
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D, A, B, E

D	C	F							
OpenList:
(Stack)
Threshold: 2





21
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D, A, B, E, F

D	C								
OpenList:
(Stack)
Threshold: 2




22
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D, A, B, E, F, C

D	H	G							
OpenList:
(Stack)
Threshold: 2





23
 



DFID (Depth first Iterative deepening)
 

 

צמתים שהורחבו: 
A, A, B, C, D, A, B, E, F, C, G
מסלול שהוחזר: A, C, G

D	H								
OpenList:
(Stack)
Threshold: 2




24
 
אלגוריתם הנעזר בתור עדיפויות על פי פונקציית העלות 
פתרון מהיר, אך לא בהכרח יחזיר פתרון אופטימלי
PHS (Pure heuristic search)
 

PHS

מתעדף לפי היוריסטיקה הקטנה ביותר.
פתרון מהיר, אך לא בהכרח יחזיר פתרון אופטימלי.
25
h
	OpenList:

(Priority Queue)
 



PHS (Pure heuristic search)
 

 

צמתים שהורחבו: 

A									
3									



26
 



PHS (Pure heuristic search)
 

 

צמתים שהורחבו: A 

B	C	D							
2	4	5							
h
	OpenList:

(Priority Queue)





27
 



PHS (Pure heuristic search)
 

 

צמתים שהורחבו: A, B 

E	F	C	D						
3	3	4	5						
h
	OpenList:

(Priority Queue)






28
 



PHS (Pure heuristic search)
 

 

צמתים שהורחבו: A, B, E 

G	K	F	C	D					
0	3	3	4	5					

h
	OpenList:

(Priority Queue)






29
 



PHS (Pure heuristic search)
 

 

צמתים שהורחבו: A, B, E, G 
מסלול שהוחזר: A, B, E, G
K	F	C	D						
3	3	4	5						
h
	OpenList:

(Priority Queue)






30
גרסאת ה-informed שלDFID 
בכל איטרציה מבצעים חיפוש לעומק 
נגזום ענפים בהם ערך ה- עולה על ערך הסף
בכל איטרציה נעדכן את ערך הסף ל- המינימלי הבא בגודלו
יחזיר פתרון אופטימלי אם ההיוריסטיקה אדמיסיבילית
IDA* (Iterative deepening A*)
 

IDA* 


31
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: 

A									
3									
0									
3									
f
g
h
Threshold(cost): 3
OpenList:
(Stack)
Min f:



32
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו:A 

B									
3									
1									
2									
OpenList:
(Stack)
f
g
h
Threshold(cost): 3
Min f: 5 



33
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: A, B 

									
									
									
									
OpenList:
(Stack)
f
g
h
Threshold(cost): 3
Min f: 5 


34
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: A, B 

A									
3									
0									
3									
OpenList:
(Stack)
f
g
h
Threshold(cost): 5
Min f: 



35
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: A, B, A 

C	B								
5	3								
1	1								
4	2								
OpenList:
(Stack)
f
g
h
Threshold(cost): 5
Min f: 6 




36
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: A, B, A, B 

C	F	E							
5	5	5							
1	2	2							
4	3	3							
OpenList:
(Stack)
f
g
h
Threshold(cost): 5
Min f: 6 





37
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: A, B, A, B, E 

C	F	G							
5	5	3							
1	2	3							
4	3	0							
OpenList:
(Stack)
f
g
h
Threshold(cost): 5
Min f: 6 





38
 



IDA* (Iterative deepening A*)
 

 

צמתים שהורחבו: A, B, A, B, E, G 
מסלול שהוחזר: A, B, E, G


C	F								
5	5								
1	2								
4	3								
OpenList:
(Stack)
f
g
h
Threshold(cost): 5
Min f: 6 




39
 
מאפייני אסטרטגיות חיפוש
 

שלמות: מבטיח למצוא פתרון אם קיים כזה. אחרת, מחזיר שלא קיים פתרון

אופטימליות: מוצא פתרון בעלות מינימלית

סיבוכיות זמן ריצה: מספר האופרטורים ש"מופעלים" במהלך החיפוש

סיבוכיות מקום: מספר הקודקודים שנשמרים במהלך החיפוש
שלמות:

אופטימליות:

סיבוכיות זמן ריצה:

סיבוכיות מקום:


40
 



מאפייני אסטרטגיות חיפוש
 

 

ציינו את הקריטריון המסביר בצורה הטובה ביותר כל טענה. הניחו שמרחב החיפוש סופי. (שלמות, אופטימאליות, סיבוכיות זמן ריצה וסיבוכיות זכרון)

א.Iterative-Deepening Search   בדרך כלל עדיף על Breadth-First Search - זכרון
ב.Iterative-Deepening Search   בדרך כלל עדיף על Depth-First Search  - אופטימליות
ג.A* Search  עדיף בדרך כלל על חיפוש חמדן - אופטימליות

 

ציינו את הקריטריון המסביר בצורה הטובה ביותר כל טענה. הניחו שמרחב החיפוש סופי. (שלמות, אופטימאליות, סיבוכיות זמן ריצה וסיבוכיות זכרון)

א.Iterative-Deepening Search   בדרך כלל עדיף על Breadth-First Search -
ב.Iterative-Deepening Search   בדרך כלל עדיף על Depth-First Search  -
ג.A* Search  עדיף בדרך כלל על חיפוש חמדן -



41
שפה לייצוג העולם בשביל Planning
אלגוריתם לפתרון Planning

כל המשתנים בוליאניים
מצב: רשימה של משתנים המקבלים השמת "True"
אופרטור: 
Preconditions (תנאי קדם)
Add list (תנאים שיש להוסיף)
Delete list (תנאים שיש למחוק)
Goal – מצב מטרה
STRIPS



42
קיימים 3 בלוקים: A, B, C
מצב התחלתי: A ו-B על השולחן, C על A, אין בלוקים מעל C ו-B
מצב סופי: C על השולחן, A על B, B על C, אין בלוקים מעל A
פרדיקטים:
ON(x,y) – x נמצא על y
ON-TABLE(x) – x נמצא על השולחן
CLEAR(x) – לא קיים בלוק על x
ניתן להגדיר מספר אופרטורים:
1. Move(x,y,z) – להעביר את x מ-y ל-z
Preconditions – {ON(x,y),CLEAR(z),CLEAR(x)}
Add list – {ON(x,z),CLEAR(y)}
Delete list – {ON(x,y),CLEAR(z)}
STRIPS  - דוגמא


43
,ON(x,y) ,ON-TABLE(x)  CLEAR(x)
ניתן להגדיר מספר אופרטורים:
2. Move-to-table(x,y) – להעביר את x מ-y לשולחן
Preconditions – {ON(x,y),CLEAR(x)}
Add list – {ON-TABLE(x),CLEAR(y)}
Delete list – {ON(x,y)}
3.  Move-from-table(x,y) – להעביר את x מהשולחן ל-y
Preconditions – {ON-TABLE(x), CLEAR(x),CLEAR(y)}
Add list – {ON(x,y)}
Delete list – {ON-TABLE(x),CLEAR(y)}
STRIPS  - דוגמא


44
מצב התחלתי:
	{ON-TABLE(A), ON-TABLE(B), 
	ON(C,A), CLEAR(C), CLEAR(B)}
מצב סופי:
	{ON-TABLE(C), ON(A,B), ON(B,C),CLEAR(A)}
להשגת המטרה יש לבצע:
Move-to-table(C,A)	
Move-from-table(B,C)
Move-from-table(A,B)
STRIPS  - דוגמא


45

השגת תת-מטרה (sub-goal)
מעבר לתת-המטרה הבאה
עד אשר כל תתי-המטרות הושגו

בעיה שעלולה להיווצר:
כשנשיג תת-מטרה אחת נגרום למצב גרוע יותר עבור 
תת-מטרה אחרת
(Sussman anomaly)

Linear planning


46
להשגת המטרה יש לבצע:
Move-to-table(C,A)	
Move-from-table(B,C)
Move-from-table(A,B)

אם היינו משתמשים בתכנון לינארי יכל להיות מצב
בו היינו מבצעים תחילה:
Move-from-table(B,C)
.......
במצב זה חלק חלק מהתת-מטרות הושגו 
אך חלק הורחקו מהשגה
STRIPS  - דוגמא (Sussman anomaly)


47

פותרים קבוצה של תת-מטרות 
בפועל מבצעים חיפוש על מרחב החיפוש הסופי

מתגבר על הבעיה שנוצרה בתכנון הלינארי
Non-Linear planning




48
שימוש ב-Non-Linear planning, לדוגמא: עץ חיפוש


STRIPS 
{ON-TABLE(A), ON-TABLE(B), ON(C,A), CLEAR(C), CLEAR(B)}
{ON-TABLE(A), ON-TABLE(B), ON-TABLE(C), CLEAR(C), CLEAR(B) , CLEAR(A)}
{ON-TABLE(A), ON(B,C), ON(C,A), CLEAR(B)}
Move-to-table(C,A)
Move-from-table(B,C)
{ON-TABLE(A), ON-TABLE(B), , ON(C,B), CLEAR(C), CLEAR(A)}
Move (C,A,B)
{ON-TABLE(C), ON(A,B), ON(B,C),CLEAR(A)}
Goal


49
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-5\Practice-5.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 





Practice session 5


Planning

שפה לייצוג העולם בשביל Planning
אלגוריתם לפתרון Planning

כל המשתנים בוליאניים
מצב: רשימה של משתנים המקבלים השמת "True"
אופרטור: 
Preconditions (תנאי קדם)
Add list (תנאים שיש להוסיף)
Delete list (תנאים שיש למחוק)
Goal – מצב מטרה
STRIPS



3
נתונות  C ערים,  Mמשאיות וP- חבילות
לכל חבילה עיר מוצא ועיר יעד
לכל משאית יש עיר מוצא אליה היא צריכה לשוב בתום יום העבודה
משאית יכולה לנסוע מעיר לעיר להעמיס ולפרוק חבילות
In(a,b)- משאית/חבילה a נמצאת בעיר b או כשחבילה a נמצאת על משאית b
Free(a)- חבילה a אינה מועמסת על משאית או כשעל משאית a 
לא מועמסת חבילה (המשאית פנויה)
 יש לייצג את הבעיה בשפת STRIPS
בעיית הלוגיסטיקה 

אם חבילה נמצאת על משאית ומשאית נמצאת בעיר מסויימת, אין צורך לרשום שהחבילה גם נמצאת בעיר
4
In(a,b)- משאית/חבליה a נמצאת בעיר b או כשחבילה a נמצאת על משאית b
Free(a)- חבילה a אינה מועמסת על משאית או 
	    כשעל משאית a לא מועמסת חבילה (המשאית פנויה)

עזרו למהנדס והגדירו את האופרטורים הבאים:
operator MOVE-TRUCK <city-c1> <city-c2><truck-t>
	העברת משאית t מעיר c1 לעיר c2
operator LOAD-PARCEL <package-p> <truck-t> <city-c>
	העמסת חבילה p על משאית t בעיר c
operator UNLOAD-PARCEL <package-p> <truck-t> <city-c>
	פריקת חבילה p ממשאית t בעיר c
בעיית הלוגיסטיקה 


5
In(a,b)- משאית/חבליה a נמצאת בעיר b או כשחבילה a נמצאת על משאית b
Free(a)- חבילה a אינה מועמסת על משאית או 
	    כשעל משאית a לא מועמסת חבילה (המשאית פנויה)

עזרו למהנדס והגדירו את האופרטורים הבאים:
operator MOVE-TRUCK <city-c1> <city-c2><truck-t>
	העברת משאית t מעיר c1 לעיר c2
Preconditions – {In(t,c1)}
Add list – {In(t,c2)}
Delete list – {In(t,c1)}
בעיית הלוגיסטיקה  


6
In(a,b)- משאית/חבליה a נמצאת בעיר b או כשחבילה a נמצאת על משאית b
Free(a)- חבילה a אינה מועמסת על משאית או 
	    כאשר כשעל משאית a לא מועמסת חבילה (המשאית פנויה)

עזרו למהנדס והגדירו את האופרטורים הבאים:
operator LOAD-PARCEL <package-p> <truck-t> <city-c>
	העמסת חבילה p על משאית t בעיר c
Preconditions – {In(t,c), In(p,c), Free(t), Free(p)}
Add list – {In(p,t)}
Delete list – {In(p,c),Free(t), Free(p)}
בעיית הלוגיסטיקה  


7
In(a,b)- משאית/חבליה a נמצאת בעיר b או כשחבילה a נמצאת על משאית b
Free(a)- חבילה a אינה מועמסת על משאית או 
	    כאשר כשעל משאית a לא מועמסת חבילה (המשאית פנויה)

עזרו למהנדס והגדירו את האופרטורים הבאים:
operator UNLOAD-PARCEL <package-p> <truck-t> <city-c>
	פריקת חבילה p ממשאית t בעיר c
Preconditions – {In(t,c), In(p,t)}
Add list – {In(p,c), Free(t), Free(p)}
Delete list – {In(p,t)}
בעיית הלוגיסטיקה  


8
יש לדחוף את ארגז המטרה אל ה-X
פרדיקטים: At(p,x1,y1) – p נמצא במשבצת (x1,y1), Free(x1,y1) – משבצת (x1,y1) פנויה
הגדירו את האופרטורים הבאים:
    operator PUSH_BOX_LEFT <box-b><player-p><X-x><Y-y>
operator PUSH_BOX_RIGHT …
operator PUSH_BOX_UP …
operator PUSH_BOX_DOWN …
operator MOVE_LEFT <player-p><X-x><Y-y>
operator MOVE_RIGHT … 
operator MOVE_UP … 
operator MOVE_DOWN … 
משחק הארגזים (Sokoban) 


9
יש לדחוף את ארגז המטרה אל ה-X
פרדיקטים: At(p,x1,y1) – p נמצא במשבצת (x1,y1), Free(x1,y1) – משבצת (x1,y1) פנויה
הגדירו את האופרטורים הבאים:
 operator PUSH_BOX_LEFT <box-b><player-p><X-x><Y-y>
Preconditions – {At(p,x,y), At(b,x-1,y), Free(x-2,y)}
Add list – {At(p,x-1,y), At(b,x-2,y), Free(x,y)}
Delete list – {At(p,x,y), At(b,x-1,y), Free(x-2,y)}
operator MOVE_LEFT <player-p><X-x><Y-y>
Preconditions – {At(p,x,y), Free(x-1,y)}
Add list – {At(p,x-1,y), Free(x,y)}
Delete list – {At(p,x,y), Free(x-1,y)}
משחק הארגזים (Sokoban) 


10
קיימות  דיסקיות בגדלים שונים 
יש לסדרן על אחד העמודים (pegs) בסדר יורד 
(כאשר הדיסקית בתחתית היא הגדולה ביותר) 
אפשר להעביר דיסקית רק אם אין מעליה דיסקית אחרת 
אפשר להעביר דיסקית לעמוד אחר אם הוא ריק או בראשו 
דיסקית אחרת הגדולה מהדיסקית אותה רוצים להעביר
תרגמו את הבעיה לשפת STRIPS
מגדלי האנוי 


11
פרדיקטים:
Clear(x) – לא קיימת דיסקית מעל x (או שהעמוד ריק – x העמוד)
On(x,y) – דיסקית x נמצאת על דיסקית y
Smaller(x,y) – דיסקית x קטנה מדיסקית y 
אופרטורים:
Move(x,y,z) – העברת דיסקית x מ-y ל-z
Preconditions – {Clear(x), Clear(z), On(x,y), Smaller(x,z)}
Add list – {Clear(y), On(x,z)}
Delete list – {Clear(z), On(x,y)}

מגדלי האנוי 


12

domain.pddl

(define (domain HANOI)
  (:requirements :strips)
  (:predicates (on ?x ?y)
	       (smaller ?x ?y)
	       (clear ?x)
	       )

  (:action move
	:parameters (?x ?y ?z)
	:precondition (and (on ?x ?y) (clear ?z) (clear ?x) (smaller ?x ?z))
	:effect
	 (and (on ?x ?z)
	 (clear ?y)
	 (not (on ?x ?y))
	 (not (clear ?z)))))
מגדלי האנוי – pddl 

problem.pddl

(define (problem HANOI-4-0)
(:domain HANOI)
(:objects A B C D E1 E2 E3)

(:init 
(ON A B) (ON B C) (ON C D) (ON D E1) 
(CLEAR A) (CLEAR E2) (CLEAR E3) 
(SMALLER A B) (SMALLER A C) (SMALLER A D) (SMALLER B C) (SMALLER B D) (SMALLER C D) 
(SMALLER A E1) (SMALLER A E2) (SMALLER A E3)
(SMALLER B E1) (SMALLER B E2) (SMALLER B E3)
(SMALLER C E1) (SMALLER C E2) (SMALLER C E3)
(SMALLER D E1) (SMALLER D E2) (SMALLER D E3))

(:goal (AND (ON A B) (ON B C) (ON C D) (ON D E3))))
http://editor.planning.domains/#


13
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-6\Practice-6.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 


Practice session 6

Two-players Games

Two-players Games
 
משחק סכום אפס (Zero-sum game)
ייצוג מתמטי של מצב בו הרווח (או ההפסד) של צד אחד 
מאוזן ע"י ההפסד (או הרווח) של האחר
סכום הרווח וההפסד ("תועלת") של כל הצדדים הוא אפס 
משחק שאינו סכום אפס:
קיימת לפחות תוצאה אפשרית אחת בה סכום התועלות אינו אפס
דוגמאות למשחקי סכום אפס: 
שח מט, דמקה, שש-בש

ייצוג מתמטי של מצב בו הרווח (או ההפסד) של צד אחד מאוזן ע"י ההפסד (או הרווח) של האחר
סכום הרווח וההפסד ("תועלת") של כל הצדדים הוא אפס.
כלומר, הרווח של משתתף אחד בא על חשבונו של משתתף אחר.

3
Two-players Games
צורה פורמאלית:
 – תועלת () 
	תוצאה כלשהי לשחקן מסוים  (כמה התוצאה טובה לשחקן)

משחק שאינו סכום אפס



4
Two-players Games
אסטרטגיה ()
דרך פעולה נבחרת או קבוצה של פעולות נבחרות בהן השחקן בוחר לנקוט

שיווי משקל נאש ()
פתרון של משחק בו אין שיתוף פעולה בין השחקנים )שני שחקנים או יותר(
אף שחקן לא יכול להגדיל את התועלת שלו בשינוי אסטרטגיה חד-צדדי
לכל שחקן אסטרטגיה ולא כדאי לו לשנות אותה בהנחה ששאר 
השחקנים לא שינו את האסטרטגיות שלהם


5
דילמת האסיר (The Prisoner’s Dilemma)
המשטרה עצרה שני עבריינים שביצעו פשע משותף ומפרידה ביניהם לצורך חקירה
במידה ושני העבריינים יעידו אחד כנגד השני - ייכלאו למשך 4 שנים
במידה ורק אחד מהם יעיד כנגד חברו - ישוחרר וחברו ייכלא למשך 5 שנים
במידה ואף אחד מהם לא יעיד - ייכלאו למשך שנה אחת


6
דילמת האסיר (The Prisoner’s Dilemma)

אסיר ב ב                          
                      אסיר א	שותק (שיתוף פעולה)	בוגד

שותק

(שיתוף פעולה)	(-1,-1)	
(-5,0)
בוגד	(0,-5)	(-4,-4)

נזהה שיווי משקל נאש ע"י מצב שממנו אין חיצים יוצאים
((אסיר ב', אסיר א'


7
מלחמת המינים (Battle of the sexes)
 

זוג נשוי מתכננים ללכת לבלות אך אינם יכולים לתקשר לפני כן
האישה מעדיפה ללכת למשחק כדורגל והבעל מעדיף ללכת למופע בלט
במידה וכל אחד ילך למקום אחר, הרווח של כל אחד מהם יהיה - 0
במידה ויילכו למקום מועדף על אחד הצדדים, הרווחים שלהם יהיו - 3 ו-2


8
מלחמת המינים (Battle of the sexes)
 

 
בעל                         
                     אישה	כדורגל	בלט
כדורגל	(3,2)	(0,0)
בלט	(0,0)	(2,3)
מתקיימות שתי נקודות שיווי משקל נאש 


((בעל, אישה


9
מינימקס – Minimax
 
אלגוריתם לבחירת אסטרטגיה שממקסמת את תועלת השחקן
בהנחה שהיריב בוחרת אסטרטגיה שממזערת את תועלת השחקן

מינימקס במשחקי סכום אפס 
= 
שיווי משקל נאש


10
מינימקס – Minimax
7
5
7
7
7
9
5
8
7
8
5
2
8
1
6
7
0
9
3
7
2
8
MAX
MIN
MIN
MAX












11








Alpha Beta Pruning
 

שיטת אופטימיזציה עבור עצי-חיפוש מסוג מינמקס


?
MAX
MAX
MIN



12
Alpha Beta Pruning
 
 - ערך הקודקוד הנוכחי  (מאותחל על פי סוג הקודקוד)
ערך אלפא: מעודכן ע"י קודקוד  (מאותחל כ- ∞-)
ערך ביתא: מעודכן ע"י קודקוד  (מאותחל כ- ∞)
גיזום: אם 
 


13

Alpha Beta Pruning
MAX
MIN









3
6
7
4
8
2
12
MAX
MIN
8









3
3


6



7





8



2

2
3
8


MAX

MIN

Cut if 
If 
If 



14
תרגיל 1
 
השוואה בין אסטרטגיות חיפוש

אלפא-ביטא עדיף בדרך כלל על מינימקס:

1) שלמות			 3) זמן
2) אופטימליות	  	 4) זכרון


תשובה: 3
15
תרגיל 2
 
בהנחה ש- 7=E, בעבור אילו ערכים שלA,B,C,D אלגוריתם  לא יפתח את קודקוד E?
א.	A=4,B=6,C=5,D=4
ב.	A=9,B=1,C=1,D=8
ג.	A=7,B=5,C=8,D=4
ד.	A=8,B=8,C=7,D=7


תשובה: 3
16
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-7\Practice-7.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 


Practice session 7

Two-players Games

Expectimax/Expectiminimax
 
קיימים משחקים בהם המצב נקבע 
ע"פ הסתברות מסויימת (למשל: הטלת קוביה)

Expectimax דומה למינימקס בצמתים
לא הסתברותיים (מקסימום\מינימום)

בצמתים הסתברותיים נעבוד על פי התוחלת


3
Expectimax/Expectiminimax
 
דוגמא למשחק שה-CHANCE נקבע על
פי הטלת מטבע הוגן:



4
10


MAX
CHANCE
2
6
0.5
0.5
0.5
0.5
7
4
7


4


תרגיל
כדי לבצע צעד במשחק על השחקן להטיל קוביה
אם יצא אי זוגי (1,3,5) קיימים שלשה מהלכים אפשריים שערכם 6, 8 ו-12  
אם יצא 2 או 4 קיימים שלושה מהלכים אפשריים שערכם 6, 12 ו-24 
אם יצא 6 קיימים שני מהלכים אפשריים שערכם 6 ו-18 
ציירו את עץ הexpectimax- המתאים כאשר השחקן הוא שחקן מקסימום
6
8
12
6
18
6
12
24
12
18
24
1/2
1/3
1/6
17




5








Alpha Beta Pruning
 

שיטת אופטימיזציה עבור עצי-חיפוש מסוג מינמקס


?
MAX
MAX
MIN



6
תרגיל 1
1) 
2) 
3) 


 

נתון עץ המשחק הבא עליו הופעלה ריצת אלפא ביטא

עבור אילו ערכים של  Aלא נחשוף את   ?B 
3
7
A
B
C
D
E
F










7
7

תשובה: 2
7
תרגיל 2
נכון             לא נכון

לא ניתן לגזום פה
 

נתון עץ המשחק הבא עליו הופעלה ריצת אלפא-ביטא

קיימים ערכים מסוימים של  A ו-  Bכך 
שתת העץ המכיל את C, D לא ייחשף ? 
3
7
A
B
C
D
E
F











תשובה: לא נכון
8
תרגיל 3
1) 
2) 
3) 


 

נתון עץ המשחק הבא עליו הופעלה ריצת אלפא-ביטא

בהינתן A=1 B=2
עבור אילו ערכי  C, Dתת העץ המכיל את  E, F
לא ייחשף? (בחרו בתשובה המדוייקת ביותר) 
3
7
A
B
C
D
E
F










7
2
2
2

יגזום כאשר-


תשובה: 1
9
תרגיל 4
1) 
2) 
3) 


 

נתון עץ המשחק הבא עליו הופעלה ריצת אלפא-ביטא

מהו מספר העלים המקסימאלי שלא יחשפו בהנחה 
שאפשר לתת ל A-F כל ערך שרירותי?
3
7
A
B
C
D
E
F











תשובה: 3
10
תרגיל 5
 
עבור אלו ערכי  Aאלגוריתם         לא יפתח את קודקוד ? B
א)	עבור כל A<8
ב)	עבור כל A<9
ג)	עבור כל A≥8
ד)	עבור כל A≥9
ה)	עבור כל ערך של A
ו)	אין ערך  Aעבורו  Bלא יפותח

MIN
MAX
MAX

תשובה: ו
11
תרגיל 6
 
עבור אלו ערכי A,B,C אלגוריתם           יפתח את קודקוד D ? 
א) 	A=2,B=8,C=2
ב)	A=2,B=8,C=9
ג)	A=2,B=9,C=2
ד)	A=2,B=2,C=9
ה)	A=9,B=9,C=9

MIN
MAX
MAX
8
9
8


יגזום כאשר-

יגזום כאשר-



תשובה: ג
12
תרגיל 7
 
בעבור אלו ערכי A  ו  B-אלגוריתם          לא יפתח את קודקוד ? C
א)	Max(A,B) ≥6 
ב)	Max(A,B) ≥9 
ג)	Min(A,B) ≥6 
ד)	Min(A,B) ≥9
ה)	Max(A,B) <6 
ו)	Max(A,B) <9 
ז)	Min(A,B) <6 
ח)	Min(A,B) <9

MIN      α=6,  β=9
MIN
MAX
V=∞
V= MIN(A,B)
α=6
β=9

MIN(A,B)


MAX

MIN

Cut if 
If 
If 


תשובה: ד
13
תרגיל 8
 
בהנתן ש- min{A, B, C, D}=10, max{A,B, C, D}=15 
עבור אלו ערכי  Eאלגוריתם          יגזום את תת העץ 
המכיל את שני צמתי '3' ?
א) תלוי במשתנים A, B, C, D  
    ולכן לא ניתן לומר מראש
ב) עבור כל ערך של E
ג) אין ערך של E  כזה
ד)	 

MIN      α=6,  β=9
MIN
MAX
V=∞
10-15
V= MIN(E,6)
α=6
β=9
V=-∞
α=6
β=9
V=MIN(E,6)
α=6
β=9

V= 10-15
α=6
β=9


MAX

MIN

Cut if 
If 
If 


תשובה: ג
14
תרגיל 9
 

בעבור אלו ערכי A,B,C,D  אלגוריתם          לא יפתח 
את קודקוד E   בוודאות? 
א) 	Min(A,B) ≥9 
ב)	Max(A,B) ≥9 
ג)	Min(A,B,C,D) ≥6 
ד)	Max(A,B,C,D)≥9
ה)	Max(A,B,C,D) ≤6

MIN      α=6,  β=9
MIN
MAX
V=∞
   
Max(A,B,C,D)

V Max(A,B,C,D)
α=6
β=9


MAX

MIN

Cut if 
If 
If 


תשובה: ה
15
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-8\Practice-8.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 





Practice session 8

Resolution

Resolution
 
1. יש לי כלב או חתול
2. אין לי כלב
מסקנה:	
יש לי חתול

רזולוציה: דרך יעילה להוכחת משפטים לוגים בעזרת המחשב 



3
Resolution
 
First order logic (FOL) to clausal normal forms (CNF)
8 שלבים שמטרתם היא העברת נוסחאות לצורת פסוקיות

CNF
FOL



4
FOL  to  CNF
 
שלב 1: הסרת סימני הגרירה → (Replace Implications)




אם היום יום חמישי 
אז מחר שישי
או שהיום לא יום חמישי 
או שמחר שישי
יכול להיות ששניהם מתקיימים!


5
FOL  to  CNF
 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים (Distribute negations)










6
FOL  to  CNF
 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו שם בשני כמתים (Standardize variables)








7
FOL  to  CNF
 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה (Replace existential)
סקולומיזציה: כל משתנה  מוחלף בפונ' סקולם שונה על פי המשתנה של הכמת . מסירים את .





)





8
FOL  to  CNF
 
שלב 5:  הסרת כל הכמתים  (Remove universals)

)





9
FOL  to  CNF
 
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם   (Distribute disjunctions)







10
FOL  to  CNF
 
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' (Replace operators)





11
FOL  to  CNF
 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה זהה בשתי פסוקיות שונות (Rename variables)





12
FOL  to  CNF - דוגמא
העבר את הנוסחא הבאה מ-FOL ל-CNF:





13
FOL  to  CNF - דוגמא
שלב 1: הסרת סימני הגרירה → (Replace Implications)



]






14
FOL  to  CNF - דוגמא
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים (Distribute negations)








15
FOL  to  CNF - דוגמא
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו שם בשני כמתים (Standardize variables)










16
FOL  to  CNF - דוגמא
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה (Replace existential)
סקולומיזציה: כל משתנה  מוחלף בפונ' סקולם שונה על פי המשתנה של הכמת , מסירים את .

)







17
FOL  to  CNF - דוגמא
שלב 5:  הסרת כל הכמתים  (Remove universals)






18
FOL  to  CNF - דוגמא
שלב 6:  הפוך את הביטוי לפסוקיותשבינהן   (Distribute disjunctions)





[




19
FOL  to  CNF - דוגמא
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' (Replace operators)









20
FOL  to  CNF - דוגמא
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה זהה בשתי פסוקיות שונות (Rename variables)








21
 
כלל הרזולוציה (Resolution Principle)





22
 
כלל הרזולוציה (Resolution Principle)
הסבר:
נניח כי: A  נכון, 
אז  וגם .

בודאות  או . אם שניהם  אז קיימת סתירה
להנחה כי A נכון.




A
B


23
 
כלל הרזולוציה (Resolution Principle)
 
נשים לב למקרה הבא:





24
תרגיל 1
ידוע כי:
יובל או גיא אוהבים לרוץ 
כל מי שאוהב לרוץ אוהב ספורט
כל מי שאוהב ספורט הוא לא עצלן
גיא עצלן

יש להוכיח בעזרת רזולוציה (כולל כל השלבים) כי יובל אוהב לרוץ. 
בטא את הידע בעזרת First-order logic ,יש להשתמש בפרדיקטים הבאים:  Running(x),Sport(x),Lazy(x) 
א)	העבר את המשפטים ל  Clausal form כפי שנלמד.
 


25
תרגיל 1
ידוע כי:
יובל או גיא אוהבים לרוץ 
כל מי שאוהב לרוץ אוהב ספורט
כל מי שאוהב ספורט הוא לא עצלן
גיא עצלן
נניח בשלילה: יובל לא אוהב לרוץ

יש להשתמש בפרדיקטים הבאים:  
Running(x),Sport(x),Lazy(x) 
 
 








26
תרגיל 1
 

שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




27
תרגיל 1
 


שלב 1:

שלב 5:

שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




28
תרגיל 1
 


שלב 1:


שלב 5:


שלב 7:


 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




29
תרגיל 1
 


שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




30
תרגיל 1
 


שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




31
תרגיל 1
 שלב 8:




32
תרגיל 1
 

       
       
       
       
ולכן סתירה להנחה כי יובל לא אוהב לרוץ   


ב) הוכח או הפרך את המטרה 
ע"י שימוש בחוקי הרזולוציה.


33
תרגיל 2
מומחה סיפק את הידע הבא:
כל מי שנדבק בכולרה סובל מכאבי בטן
קיים אדם הסובל מכאבי בטן שלא נדבק בכולרה
רק מי שסובל מכולרה ימות או יקיא
 
בטאו את הידע בעזרת first order logic  , נא להשתמש בפרידקטים: 
C(x) - x has cholera
S(x) - x has stomachache
WD(x) - x will die
WV(x) - x will vomit
הוכיחו בעזרת רזולוציה: קיים אדם הסובל מכאב בטן שלא ימות ולא יקיא. 

 


34
תרגיל 2
מומחה סיפק את הידע הבא:
כל מי שנדבק בכולרה סובל מכאבי בטן
קיים אדם הסובל מכאבי בטן שלא נדבק בכולרה
רק מי שסובל מכולרה ימות או יקיא
נניח בשלילה: לא קיים אדם הסובל מכאב בטן 
                    שלא ימות ולא יקיא  
פרידקטים: 
C(x) - x has cholera
S(x) - x has stomachache
WD(x) - x will die
WV(x) - x will vomit

 
 






35
תרגיל 2
 

שלב 1:

שלב 5:

שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




36
תרגיל 2
 

שלב 4:


שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




37
תרגיל 2
 

שלב 1:
3)
שלב 2:
3)
שלב 5:

שלב 6:

שלב 7:

   
 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




38
תרגיל 2
 

שלב 2:
4) 
שלב 5:

שלב 7:


 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




39
תרגיל 2
 שלב 8:





40
תרגיל 2
 
 

         
              
              
            
                                         
ולכן סתירה להנחה כי לא קיים אדם הסובל מכאב בטן שלא ימות ולא יקיא  

ב) הוכח או הפרך את המטרה 
ע"י שימוש בחוקי הרזולוציה


41
תרגיל 3
ידוע כי:
כל תוכניתן כותב באגים.
רק תוכניתנים כותבים תוכנות.
כל המועסקים אצל תומר אינם כותבים באגים  
 
יש להוכיח בעזרת רזולוציה (כולל כל השלבים) כי כל המועסקים אצל תומר אינם כותבים תוכנות. 
א) בטא את הידע בעזרת First-order logic והעבר ל-CNF
יש להשתמש בפרדיקטים הבאים:
Programmer(x),WritesBugs(x),WritesPrograms(x),Employs(x,y)

 


42
תרגיל 3
ידוע כי:
כל תוכניתן כותב באגים.
רק תוכניתנים כותבים תוכנות.
כל המועסקים אצל תומר אינם כותבים באגים  
נניח בשלילה: לא כל המועסקים אצל תומר אינם כותבים תוכנות. 
קבוע: T - TOMER
פרדיקטים:
P(x) - Programmer(x)
WB(x) - WritesBugs(x)
 WP(x) - WritesPrograms(x)
E(x,y) - Employs(x,y)
 
 






43
תרגיל 3
 

שלב 1:

שלב 5:

שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




44
תרגיל 3
 

שלב 1:

שלב 2:

שלב 5:

שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




45
תרגיל 3
 

שלב 1:

שלב 5:

שלב 7:

 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




46
תרגיל 3
 

שלב 1:

שלב 2:

שלב 4:

שלב 7:



 
שלב 1: הסרת סימני הגרירה → 
שלב 2:  הקטן את טווח השלילות לפסוקים אטומיים 
שלב 3: שנה את שמות המשתנים כך שלא יופיע אותו 
            שם בשני כמתים 
שלב 4:  הסרת הכמת  בתהליך סקולומיזציה 
שלב 5:  הסרת כל הכמתים  
שלב 6:  הפוך את הביטוי לפסוקיותשבינהם  
שלב 7:  שינוי סינטקס, מ-  ל- ','  ,  מ-' ' ל-'{}' 
שלב 8:  שינוי שמות משתנים כך שלא יהיה משתנה 
            זהה בשתי פסוקיות שונות




47
תרגיל 3
 שלב 8:








48
תרגיל 3
 
 

          
    
    
                                        
ולכן סתירה להנחה כי לא כל המועסקים אצל תומר אינם כותבים תוכנות  


ב) הוכח או הפרך את המטרה 
ע"י שימוש בחוקי הרזולוציה.


49
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\מבוא-לבינה-מלאכותית-סמ-1\תרגולים\Practice-9\Practice-9.pptx </DOCNO>
<F P=104> מבוא-לבינה-מלאכותית-סמ-1 </F>
<TEXT>
Artificial Intelligence
 





Practice session 9 

MDP

תהליך החלטה מרקובי

תהליך החלטה בו ההסתברות לעבור למצב מסוים תלויה רק בפעולה הנוכחית

MDP (Markov Decision Processes)



1
0.6
0.7
0.3
0.4


3
כלל התועלת המקסימלית – MEU (Maximum expected utility)
סוכן הינו רציונלי אם תמיד בוחר בפעולה שתוביל לתועלת מקסימלית

פעולות - Actions ()
תוצאות - Outcome ()
הסתברות - שנקבל '' 
               כשנבצע '' ()
תועלת - Utility ()

קבלת החלטות  - עקרונות
תעולת צפויה- Expected utility

סוכן שפועל על פי MEU יבחר בפעולה שממקסמת EU





4
מורכב מ:
מצבים ()
פעולות ()
פונקציית מעבר ()
 -          ההסתברות שאעבור ל-s’ בהינתן שאני ב-s ומבצע a
פונקציית שכר - Reward -    - שכר שאקבל מלהיות ב-s
                                   -  - שכר שאקבל מלהיות ב-s ואבצע a
קיימים שני סוגים:
Goal-state MDP – קיימים מצבים סופיים ונעצור כאשר נגיע אליהם
Discount-reward MDP – השכר שנקבל מושפע מהזמן שבו נקבל אותו, אין מצבים סופיים
MDP (Markov Decision Processes)
A
B
C
D
T(A,a1,C)
a1
a2
a3
a4


5
Goal-state MDP – 
קיימים מצבים סופיים ונעצור כאשר נגיע אליהם

Discount-reward MDP – 
השכר שנקבל מושפע מהזמן שבו נקבל אותו, אין מצבים סופיים
אם הסוכנים ימשיכו לחיות לעד, השכר שלהם יהיה אינסופי. מה נעשה במקרים כאלו?
השכר בעתיד נמוך מהשכר שנקבל עכשיו, עם פרמטר  ()
השכר בנקודת זמן עתידית  נמוך פי 
נהוג להשתמש ב- 

סוגי MDP


6

Value Iteration
Policy Iteration
Linear Programming

טכניקות לחישוב מדיניות (Policy) אופטימלית


7

בכל איטרציה:
עדכן את תועלת מצב I באמצעות התועלות הקודמות של מצבים שכנים J ,בהינתן הפעולות A


 - ההסתברות שיקרה J בהינתן שאני ב-I ומבצע a

Value Iteration - רעיון
Value Iteration 


8
אתחל:  (במידה ולא הוגדר אחרת)
כל עוד    
עבור כל מצב I בצע:  
עבור כל מצב I בצע:  
Value Iteration - אלגוריתם
Value Iteration 


9
נתון מרחב מצבים בין 4 מצבים (A-D) 
נתון רובוט שיכול לנוע בין המצבים בכיוון השעון. 
בכל פעם שהרובוט יוצא ממצב A  הוא זוכה ב 10 דולר. 
בכל פעם שהרובוט יוצא ממצב C  הוא מפסיד 10 דולר. 
לרובוט שלוש פעולות אפשריות:
1. התקדם מצב אחד קדימה – לפעולה זו יש סיכוי של 70% להצליח ובסיכוי של 30% הרובוט יתקדם שני מצבים קדימה.
2. התקדם שני מצבים קדימה – לפעולה זו יש סיכוי של 40% להצליח, בסיכוי 30% הרובוט יתקדם שלושה מצבים ובסיכוי 30% הוא יתקדם רק מצב אחד.
3. התקדם שלושה מצבים קדימה – לפעולה זו יש סיכוי של 70% להצליח ובסיכוי של 30% הרובוט יתקדם רק שני מצבים.
עלות כל פעולה 1 דולר.

Value Iteration

בצעו שתי איטרציות של Value Iteration הניחו מדיניות לפיה מבצעים את פעולה 1 בכל מצב. 
רשמו את ה-utility  עבור כל מצב.


10
איטרציה
מצב	0	1	2
A	0		
B	0		
C	0		
D	0		
איטרציה
מצב	0	1	2
A	0	9	
B	0	-1	
C	0	-11	
D	0	-1	
איטרציה
מצב	0	1	2
A	0	9	5
B	0	-1	-9
C	0	-11	-9
D	0	-1	5
איטרציה
מצב	0	1	2
A			
B			
C			
D			
יוצא ממצב A  זוכה ב 10 דולר. 
יוצא ממצב C  מפסיד 10 דולר. 
שלוש פעולות אפשריות:
1. מצב אחד קדימה –70% הצלחה, 30% שני מצבים קדימה.
2. שני מצבים קדימה –40% הצלחה, 30% שלושה מצבים קדימה, 30% מצב אחד קדימה.
3. שלושה מצבים קדימה –70% הצלחה, 30% שני מצבים קדימה.
עלות כל פעולה 1 דולר.

Value Iteration


1
1





]


11
יוצא ממצב A  זוכה ב 10 דולר. 
יוצא ממצב C  מפסיד 10 דולר. 
שלוש פעולות אפשריות:
1. מצב אחד קדימה –70% הצלחה, 30% שני מצבים קדימה.
2. שני מצבים קדימה –40% הצלחה, 30% שלושה מצבים קדימה, 30% מצב אחד קדימה.
3. שלושה מצבים קדימה –70% הצלחה, 30% שני מצבים קדימה. עלות כל פעולה 1 דולר.
נניח שלאחר פתרון המשוואות 
התקבל:
U(A)=2 ,U(B)=4
U(C)=-6 ,U(D)=5
מה תהיה מדיניות B באיטרציה הבאה?
Value Iteration
איטרציה
מצב	0	1	2
A			
B			
C			
D			

איטרציה
מצב	..	t-1	t
A	..	2	
B	..	4	
C	..	-6	
D	..	5	


]


12
יוצא ממצב A  זוכה ב 10 דולר. 
יוצא ממצב C  מפסיד 10 דולר. 
שלוש פעולות אפשריות:
1. מצב אחד קדימה –70% הצלחה, 30% שני מצבים קדימה.
2. שני מצבים קדימה –40% הצלחה, 30% שלושה מצבים קדימה, 30% מצב אחד קדימה.
3. שלושה מצבים קדימה –70% הצלחה, 30% שני מצבים קדימה. עלות כל פעולה 1 דולר.
נניח שלאחר פתרון המשוואות 
התקבל:
U(A)=2 ,U(B)=4
U(C)=-6 ,U(D)=5
מה תהיה מדיניות B באיטרציה הבאה בהנחה ש- ?
איטרציה
מצב	0	1	2
A			
B			
C			
D			

איטרציה
מצב	..	t-1	t
A	..	2	
B	..	4	
C	..	-6	
D	..	5	


]
 Value Iteration – עם Discount


13
ליורם הסטודנט יש יומיים להתכונן למבחן בבינה מלאכותית. 
בכל בוקר עליו להחליט בין 2 אפשרויות
1. ללמוד למבחן – בסיכוי של 0.8 הוא ילמד 40% מהחומר לבחינה אבל בסיכוי של 0.2 הוא יירדם ולא ילמד כלום.
2. לנסוע לים – יורם לא ילמד אבל ירוויח תועלת של 10.

אחוזי הסיכוי של יורם לעבור את המבחן זהים לאחוז החומר אותו הוא למד. 
אם יורם יעבור את המבחן הוא ירוויח תועלת של 30. 
א. הגדירו את מרחב המצבים של הבעיה (ע"י ציור או רשימת מצבים)

Value Iteration


14
1. ללמוד – 0.8 הוא ילמד 40% מהחומר, 0.2 לא ילמד.   
2. לנסוע לים – לא ילמד, ירוויח תועלת  10.
יעבור את המבחן - ירוויח תועלת 30. 
א. הגדירו את מרחב המצבים של הבעיה (ע"י ציור או רשימת מצבים)

Value Iteration
0%,1
40%,1
80%,2
0%,0
ללמוד
0.8
0.2
1
לים
R=+10
40%,2
0%,2
ללמוד
0.8
0.2
1
לים
R=+10
ללמוד
0.2
1
לים
R=+10
עבר
R=+30
נכשל
R=0
0.8
0.2
0.4
0.6
1
0.8
נגדיר:
כל מצב מייצג את אחוז ידיעת החומר ומספר היום
- מצבים סופיים: עבר/נכשל במבחן


15
1. ללמוד– 0.8 הוא ילמד 40% מהחומר, 0.2 לא ילמד.   2. לנסוע לים – לא ילמד, ירוויח תועלת  10.
יעבור את המבחן - ירוויח תועלת 30. 
ב. בצעו 3 אטרציות של Value Iteration
Value Iteration

]
איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0
איטרציה
מצב	0	1	2	3
0%,0	0			
40%,1	0			
0%,1	0			
80%,2	0			
40%,2	0			
0%,2	0			
איטרציה
מצב	0	1	2	3
0%,0				
40%,1				
0%,1				
80%,2				
40%,2				
0%,2				


16
Value Iteration

איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0
איטרציה
מצב	0	1	2	3
0%,0	0			
40%,1	0			
0%,1	0			
80%,2	0			
40%,2	0			
0%,2	0			






1. ללמוד– 0.8 הוא ילמד 40% מהחומר, 0.2 לא ילמד.   2. לנסוע לים – לא ילמד, ירוויח תועלת  10.
יעבור את המבחן - ירוויח תועלת 30. 
ב. בצעו 3 אטרציות של Value Iteration
]


17
Value Iteration

איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0
איטרציה
מצב	0	1	2	3
0%,0	0	10		
40%,1	0	10		
0%,1	0	10		
80%,2	0	24		
40%,2	0	12		
0%,2	0	0		






1. ללמוד– 0.8 הוא ילמד 40% מהחומר, 0.2 לא ילמד.   2. לנסוע לים – לא ילמד, ירוויח תועלת  10.
יעבור את המבחן - ירוויח תועלת 30. 
ב. בצעו 3 אטרציות של Value Iteration
]


18
Value Iteration

איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0
איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0






איטרציה
מצב	0	1	2	3
0%,0	0	10	20	
40%,1	0	10	22	
0%,1	0	10	10	
80%,2	0	24	24	
40%,2	0	12	12	
0%,2	0	0	0	
1. ללמוד– 0.8 הוא ילמד 40% מהחומר, 0.2 לא ילמד.   2. לנסוע לים – לא ילמד, ירוויח תועלת  10.
יעבור את המבחן - ירוויח תועלת 30. 
ב. בצעו 3 אטרציות של Value Iteration
]


19
Value Iteration

איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0
איטרציה
מצב	0	1	2	3
0%,0	0	10	20	20
40%,1	0	10	22	22
0%,1	0	10	10	10
80%,2	0	24	24	24
40%,2	0	12	12	12
0%,2	0	0	0	0
π	State
לים	0%,0
לים	40%,1
לים	0%,1
-	80%,2
-	40%,2
-	0%,2
1. ללמוד– 0.8 הוא ילמד 40% מהחומר, 0.2 לא ילמד.   2. לנסוע לים – לא ילמד, ירוויח תועלת  10.
יעבור את המבחן - ירוויח תועלת 30. 
ב. בצעו 3 אטרציות של Value Iteration
]


20
 
</TEXT>
</DOC>
