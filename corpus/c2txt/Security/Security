<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\Assignment1_PartA\Assignment1_PartA\Assignment-1---Part-A.docx </DOCNO>
<F P=104> Security </F>
<TEXT>

The Department of Information Systems Engineering
אבטחת מחשבים ורשתות תקשורת
עבודה מס' 1

הוראות הגשה

לעבודה יש שני חלקים.
את החלק הראשון (WIRESHARK), אתם מתבקשים להגיש עד לתאריך 20/5/19 בשעה 23:00 במערכת מודל לתיבת ההגשה המתאימה.
את החלק השני (קריפטוגרפיה), אתם מתבקשים להגיש עד לתאריך 10/4/19 בשעה 23:00 במערכת מודל לתיבת ההגשה המתאימה.
יש להגיש את כל קבצי העבודה לתיבת ההגשה המיועדת במודל, מכווצים ב ZIP כאשר שם הקובץ מכיל את שתי הת.ז של בני הזוג מופרדים בקו תחתון. לדוגמא:   ass1_id1_id2.zip 
שאלות על העבודה יש לשאול בפורום העבודה במודל.
כל יום איחור יוריד 5 נקודות מציון העבודה.
הארכות ינתנו רק במקרים מיוחדים.














חלק א – WIRESHARK
בשאלות הבאות תלמדו לחקור קובץ PCAP שמכיל הקלטה של משתמש ולהסיק מה המשתמש עשה בגלישתו. לטובת השאלה הנ"ל יש להתקין WIRESHARK  על המחשב. 
אנא הורד את הקובץ mystery.pcapng מהקישור הבא
טען את הקובץ PCAP המצורף לעבודת בית (mystery.pcapng) ב - WIRESHARK. הקובץ הנ"ל מכיל הקלטה (פקטות שנשלחו והתקבלו) של משתמש. ידוע כי במהלך ההקלטה שבוצעה המשתמש ביצע את ארבעת הפעולות הבאות: גלש ב-YNET, גלש ב-ONE, והוריד פעמיים קבצים של סרטים שצולמו באיכות  4kמגוגל דרייב.

שאלה מס' 1 (15 נק'):
היכנס לStatistics -> I/O Graph .
הצג את כמות הנתונים שנצרכה במהלך ההקלטה ע"י בחירת השדה המתאים. 
מה ה- display.filter שהשתמשת? (5 נק')
הוסף צילום מסך של הגרף עם אגרגציה של 10 שניות. (5 נק')
חזור לארגרגציה של שניה בודדת.
האם ניתן להפריד בין הסשנים של הגלישה באתרי אינטרנט לסשנים של הורדת הקבצים על בסיס ניתוח ויזואלי של הגרף? (5 נק')
שאלה מס' 2 (10 נק'): 
איך ניתן לזהות איזה מהסשנים שייך לכל אתר אינטרנט? (2 נק')
אחרי כמה שניות מתחילת ההקלטה נכנס המשתמש לאתר ONE? ( 2נק')
אחרי כמה שניות מתחילת ההקלטה נכנס המשתמש לאתר YNET? ( 2נק')
באיזה אתר נוסף ביקר המשתמש בתחילת ההקלטה? ( 2נק')
השלם זמני התחלה וסיום של הפעולות שביצע המשתמש ( 2נק'):






 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\Assignment1_PartB\Assignment1_PartB\Assignment-1---Part-B.docx </DOCNO>
<F P=104> Security </F>
<TEXT>

The Department of Information Systems Engineering
אבטחת מחשבים ורשתות תקשורת
עבודה מס' 1

הוראות הגשה

לעבודה יש שני חלקים.
את החלק הראשון (WIRESHARK), אתם מתבקשים להגיש עד לתאריך 20/5/19 בשעה 23:00 במערכת מודל לתיבת ההגשה המתאימה.
את החלק השני (קריפטוגרפיה), אתם מתבקשים להגיש עד לתאריך 10/4/19 בשעה 23:00 במערכת מודל לתיבת ההגשה המתאימה.
יש להגיש את כל קבצי העבודה לתיבת ההגשה המיועדת במודל, מכווצים ב ZIP כאשר שם הקובץ מכיל את שתי הת.ז של בני הזוג מופרדים בקו תחתון. לדוגמא:   ass1_id1_id2.zip 
שאלות על העבודה יש לשאול בפורום העבודה במודל.
כל יום איחור יוריד 5 נקודות מציון העבודה.
הארכות ינתנו רק במקרים מיוחדים.














חלק ב' – קריפטוגרפיה
שאלה מס' 3 (15 נק'):
נגדיר פונקציה כללית חדשה Δ  ע"י  (a,b,c) = b,c,a Δ. הוכיחו כי Δ3 היא פונקציית הזהות. 
כלומר הוכיחו  (a,b,c) = a,b,c Δ3   (5 נק')

התבונן בסכמה הבאה:

הקלטים x,y,z הם מחרוזות בינאריות באורך n, והפעולות דומות לפעולות ב – DES.  בתשובתכם אין להסתמך על תכונות f. נגדיר את הסכמה למעלה ע"י הפונקציה x',y',z'=(x,y,z)π.
הוכיחו כי 4π היא פונקציית הזהות. כלומר הוכח x,y,z=(x,y,z) 4π. (5 נק')

אליס מגדירה מערכת הצפנה סימטרית  ע"י 1πΔπ2Δ π3. בכל πj משתמשים במפתחות סיבוב k1j, k2j של הסיבוב ה-j. מהו אלגוריתם הפענוח המתאים למערכת של בוב? (5 נק')


שאלה מספר 4 ( 20נק'): 
להלן סכמה של פרוטוקול דיפי הלמן כפי שתוארה במהלך הקורס:


תאר כיצד תוקף בעל יכולת Man in the middle יכול לתקוף את פרוטוקול Diffie-Hellman (DH). בתשובתך צייר תרשים המראה במדויק את סדר שליחת ההודעות (מיספור כרונולוגי של החיצים) והמניפולציה אשר באמצעותה מצליח התוקף ליישם את ההתקפה על הפרוטוקול (5 נק')
אליס ובוב מתכננים להחליף מפתחות באמצעות פרוטוקול DH, מאחר והפרוטוקול חשוף להתקפת Man in the middle סטודנט בקורס אבטחת מידע הציע להשתמש במנגנון זיהוי מבוסס  (יפורט בהמשך). על כן, אליס ובוב פנו לשרת צד ג' אמין בדרישה להנפקת . שרת האמון הנפיק לאליס ולבוב שני  אשר כל אחד מהם כולל מפתח פרטי ופומבי (זוג אחד לאליס והזוג השני לבוב).
נגדיר את הסימונים הבאים:

להלן תיאור התהליך
אליס ובוב יוצרים מפתח משותף  תוך שימוש בפרוטוקול DH
אליס בוחרת מספר רנדומי  ושולחת לבוב את ההודעה –   
בוב בוחר מספר רנדומי  ושולח לאליס את ההודעה – 
אליס מוודא את  ה –   של בוב, במידה הווידוא הצליח היא שולחת לבוב את ההודעה –
בוב מוודא את ה –   של אליס, במידה הווידוא הצליח הוא שולח לאליס את ההודעה –
אליס ובוב מוודאים את החתימות שהם קיבלו, במידה והווידוא הצליח הם ממשיכים בהתקשרות מוצפנת באמצעות המפתח 

בהסתמך על סעיף א', תאר כיצד תוקף בעל יכולת Man in the middle יכול לתקוף את המנגנון אותו הציע הסטודנט. בתשובתך צייר תרשים המראה את תרשים של סדר שליחת ההודעות (מספור כרונולוגי) ואת המניפולציה אשר באמצעותה מצליח התוקף ליישם את ההתקפה על המנגנון אותו תיאר הסטודנט באופן בו הוא מצליח לקרוא את ההודעות מבלי שאליס ובוב מודעים לכך (10 נק').

כיצד ניתן לתקן את המנגנון אותו הציע הסטודנט ללא שינוי פרוטוקול DH וללא הוספת שלבים נוספים למנגנון. בתשובתך מנה את השינויים הנדרשים בהתייחסות לשלבי הפרוטוקול. בנוסף, צייר תרשים מעודכן של ההתקפה אותה תיארת בסעיף ב' והראה מדוע התקפה זו אינה ניתנת ליישום (5 נק').


שאלה מספר 5 (15 נק'): 
בפקולטה לניהול תעשייתי הוחלט למחשב את תהליך הזנת הציונים. לשם כך הוחלט לעשות שימוש בצופן  המפתח הפומבי RSA. לפקולטה יש זוג מפתחות פומבי - פרטי אחד. המפתח הפומבי (e,n) ידוע לכולם. המפתח הפרטי (d,n) ידוע לשרת הפקולטה ולכל המרצים בלבד. הפרמטר n הינו בגודל 2048 ביטים. בשאלה זו נניח שהסטודנטים אינם יודעים את המפתח הפרטי של הפקולטה.
להל הפרוטוקול שהוצע עבור תהליך הזנת הציונים:

RSApub() הינה הצפנת RSA תחת המפתח הפומבי של הפקולטה.
הנתון IDcourse הוא מספר באורך 128 ביטים המזהה את הקורס (למשל 094011). ניתן להניח שערכי ה-IDcourse של כל הקורסים ידועים לכולם.
הנתונים RANDL ו-RANDS הם מספרים אקראיים באורך 28 ביטים כל אחד שהמרצה והשרת מגרילים בכל הפעלה של הפרוטוקול.
הנתון StudentID הוא מספר שלם המזהה את הסטודנט ואורכו הוא 128 ביטים. כל מספר שלם הוא מספר זהות חוקי.
הנתון Grade הינו הציון (מספר שלם בין 0 ל 100), ואורכו הוא 128 ביטים.
אין הגבלה על מספר ההרצות של הפרוטוקול. אם לסטודנט מסוים מוזן הציון לקורס כלשהו יותר מפעם אחת, ציונו נקבע עפ"י הפעם האחרונה שבה הפרוטוקול הסתיים בהצלחה.
ניתן להניח שכל סטודנט יודע את ציונו בקורס ויודע מתי המרצה יזין את הציון לשרת.
ניתן להניח שכל סטודנט כבר האזין להזנות של ציוניו בלבד בקורסים אחרים.

הסבר כיצד השרת מוודא שאכן אחד המרצים הזין את הציון ולא אחד הסטודנטים (5 נק').

הסטודנט מרכוס יודע שלא הצליח כל כך בקורס "אתיקה למהנדסים" שניתן בשנה ג' וכי ציונו הסופי שיוזן ע"י המרצה הוא 2 מתוך 100 (הציון הנמוך ביותר בתואר שלו). האם מרכוס יכול לבצע התקפת man in the middle להעלות את ציונו? אם כן תאר את ההתקפה היעילה ביותר שהוא יכול לבצע ונתח זמן ריצה וזיכרון. אחרת, נמק מדוע הפרוטוקול המוצע חסין להתקפות man in the middle. (5 נק')

הסטודנט שמואל הציע להתבסס על ניצול החולשה של אלגוריתם RSA לבעית הכפליות בפרוטוקול המוצע מעלה לטובת עדכון הציון. לטענתו ההתקפה הנ"ל משיגה את אותו האפקט ויעילה יותר מההתקפה של מרכוס. האם שמואל צודק? נמק/י (5 נק')

שאלה מספר 6 (25 נק'):
בשאלה זו אתם צריכים לשבור צופן AES  פשוט, המסומן  . בגרסה הפשוטה הזו של AES ישנם 3 מפתחות שונים המוגדרים כ  , השימוש במפתחות הללו הוא כפי שהם (כלומר אין שום מניפולציה על המפתחות).  מבצע 3 פעמים (איטרציות iterations) של   אשר גם הוא גירסא פשוטה של צופן AES.  מוגדר כדלקמן:

M – הודעה לא מוצפנת Plain-text
C – הודעה. מוצפנת Cipher-text
K – מפתח הצפנה/פענוח


ולכן הגדרה של  היא:



בהינתן הודעה M והודעה מוצפנת C כך ש:  , הנכם צריכים לממש שיטה יעילה למציאת 3 המפתחות K1,K2,K3 המקיימת: .
 
האלגוריתם הצפנה  ממומש כך:









שימו לב כי במימוש שלכם לפריצה של  עליכם להתייחס ל  כקופסא שחורה המקבלת הודעה M ו3 מפתחות כקלט ומוציאה כפלט הודעה מוצפנת C לפי ההגדרה נ״ל. אינכם יכולים להשתמש בהודעות הביניים C1 ו C2! כמו כן מפתחות K1 K2 K3  חייבים להיות שונים  אחד מהשני

רשום פתרון תיאורטי לשיטה שאתה מציע (5 נק').
ממש את הפתרון שהצעת ב- JAVA לפי הדגשים הבאים (20 נק'):


דגשים למימוש:
הודעה M יכולה להיות ארוכה יותר מ 128 ביט, המימוש שלכם צריך לקחת בחשבון שאורך הודעה יכול להיות יותר ארוך מ 128 ביט, לחלק את ההודעה לבלוקים של 128 ביט ולהפעיל את האלגוריתם על כל בלוק, לשם הפשטות ניתן להניח כי אורך ההודעה היא מכפלה של 128 ביט.
עליכם לממש ממשק (interface) הצפנה/פענוח כדלקמן:

–e : instruction to encrypt the input file 
–d: instruction to decrypt the input file 
 –k <path>: path to the keys, the key should be 384 bit (128*3) for . and should be divided into 3 separate keys. 
 –i <input file path>: a path to a file we want to encrypt/decrypt 
 –o <output file path>: a path to the output file 
 Usage: Java –jar aes.jar -e/-d –k <path-to-key-file > -i <path-to-input-file> -o <path-to-output-file> 
           Java –jar aes.jar –e –k key.txt –i message.txt –o cypther.txt 

עליכם לממש ממשק (interface) לשבירה של ההצפנה כדלקמן:

o 	–b : instruction to break the encryption algorithm 
o	 –m <path>: denotes the path to the plain-text message 
o 	–c <path>: denotes the path to the cipher-text message 
o	 –o <path>: a path to the output file with the key(s) found. 
o 	Usage: Java –jar aes.jar -b –m <path-to-message> –c <path-to-cipher> -o < output-path> 

פורמט הפלטים והקלטים:
הנכם מתבקשים לכתוב ולקרוא מקבצים בבתים Bytes ולא כטקסט.
שימו לב לסדר בתים (Endianness) ,ניתן לוודא את סדר הבתים בשקופיות של ההרצאה.
השתמשו בקבצי בדיקה שסופקו לכם ביחד עם התרגיל על מנת לבדוק את התוכנית שלכם.

שימו לב כי זמן ריצה של התוכנית צריך להיות בזמן סביר הלא עולה מעל דקה אחת. 
אין להשתמש ב brute force.
עליכם להגיש את כל קבצי המקור וקובץ jar מקומפל של התוכנית שלכם.
הבדיקה מתבצעת בתוכנה אוטומטית, אנא בדקו היטב כי התוכנית שלכם עונה על כל הדרישות הנמצאות בקובץ הזה.
שימו לב כי תוכנה אוטומטית תצליב בין כל קבצי המקור לזיהוי קוד דומה, אנא הימנעו מהעתקות.
ההגשה היא במודל, יש להגיש קובץ zip בלבד בפורמט הבא: ass1_id1_id2.zip בתוך הקובץ יש לשים את כל קבצי המקור וקובץ jar. קובץ jar חייב להיות בשם aes.jar

 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\Lab1\Lab1\Lab_1.pdf </DOCNO>
<F P=104> Security </F>
<TEXT>
Computer & Information 
Security
PRACTICAL SESSION NO. 1
INTRO & INFORMATION GATHERING
Agenda
q Welcome, Assignments and Labs requirements
qInformation Gathering
General Information
q Course team
§ Lectures
• Prof. Yuval Elovici - elovici@bgu.ac.il
• Dr. Asaf Shabtai – shabtaia@bgu.ac.il
• Dr. Mordehai Guri – gurim@post.bgu.ac.il
§ Teaching Assistants
• Ron Bitton – ronbit@post.bgu.ac.il
• Ben Nassi – nassib@post.bgu.ac.il
• Aviad Elishar aviade@post.bgu.ac.il
• Noam moscovich noammosc@post.bgu.ac.il
• Assignments: Vitaly Dyadyuk- vitalyd@post.bgu.ac.il
q Course’s mail - itns.ise@gmail.com
q Course’s site  - Moodle 
General Information
q Any question with regards to assignments, lectures, practical-
sessions or labs should be directed to the appropriate forum in the 
course web-site.
q Administrative questions should be directed to the course email.
qFor the very urgent topics, or if you haven’t received an answer 
from the course email within three days - you can directly 
approach to Ron Bitton (ronbit@post.bgu.ac.il).  
Practical Sessions and Labs
q The course include both theoretical sessions (5) and labs (8)
q Each student require to submit a solution to 7 out of 8 labs.
Responsible TADateTopicLab/Theoretical-session#
Ron BittonFeb 24th weakInformation GatheringLab (1)1
Ben NassiMar 3th weakIntroduction to cryptographyTheoretical-session (1)2
Ben NassiMar 10th weakSymmetric key cryptography Theoretical-session (2)3
Ben NassiMar 24th weakPublic key infrastructureTheoretical-session (3)4
Ron BittonMar 31th weakAuthentication ProtocolsTheoretical-session (4)5
Ron BittonApr 7th weakIntroduction to Linux access controlLab (2)6
Ron BittonApr 28th weakPOSIX interface and social engineering attacks Lab (3)7
Aviad ElisharMay 12th weakFirewallsTheoretical-session (5)8
Noam MoskovichMay 19th weakUnderstanding buffer overflow attacksLab (4)9
Noam MoskovichMay 26th weakWeb application security using OWASP(1)Lab (5)10
Noam MoskovichJun 2th weakWeb application security using OWASP (2)Lab (6)11
Aviad ElisharJun 10th weakMalware analysis using Cuckoo sandboxLab (7)12
Aviad ElisharJun 17th weakVulnerability assessment  and penetration testing using OpenVAS and MetasploitLab (8)13
Assignments
q The course include 4 assignments (submitted in pairs)
qDelay will not be allowed
Responsible LectureResponsible TADatesTopic#
Asaf ShabtaiBen Nassi17/03/2019 – 04/04/2019 (23:59)Cryptography and Wireshark1
Asaf ShabtaiRon Bitton28/04/2019 – 16/05/2019 (23:59)Authentication protocols and 
Linux access control
2
Mordechai GuriNoam Moscovich19/05/2019 – 06/06/2019 (23:59)Web application security, 
network attacks and BOF
3
Yuval EloviciAviad Elishar09/06/2019 – 21/06/2019 (23:59)Final assignment (all course 
topics)
4
Information Gathering
Information Gathering
Definition:
q“the process of collecting information about something”
More specifically:
qMilitary: the operation of gathering information about an enemy
qInformation Security: collecting as much information as possible about a target
Information Gathering
Information we can collect:
qNetwork Information: Port Scanning, Topology, Firewalls
qDevices information: Hardware, Operating System, Apps
qUsers Activity: Account and browsing Information
qProperty: Ownership of IP & Domains, Docs
And many other interesting things…
Information Gathering
Main Purpose:
qUnderstand How to Attack/Defend
q Understand Where to Attack/Defend
q Understand When to Attack/Defend
q Understand Who to Attack/Defend
q Understand How/Where/When/Who NOT to Attack
This information is highly valuable!
How To Gather Information?
q Network Scans: extract information from network structure and 
components.
q Eavesdropping: listening to the private conversation (or communication 
of others without their consent
q Dumpster Diving: looking for treasure in someone else’s trash.
q Social Engineering: manipulating people to perform actions.
KALI LINUX
q Free of charge customizable open source Debian-based Linux distribution   
aimed at advanced penetration testing (PT) and security auditing.
q Contains over 600 verified tools which are geared towards various information 
security tasks
q Widely used by security researchers for PT, computer forensics and reverse 
engineering.
q Developed, funded and maintained by Offensive Security Ltd
Few of the powerful tools Kali provides
q Wireshark (packet analyzer)
q nmap (port scanner)
q URLCrazy (domain similarity tester)
q Firewalk (L4 determination)
q Parsero (Robot unauthorized scanner)
q Theharvaster (Entities gathering)
Wireshark
q Network sniffing tool
q Live capture and offline analysis
q Deep inspection of hundreds of protocols
q Network professionals, security experts, developers, and educators around 
the world use it regularly
q Freely available as open source
The first assignment is consisted of practical exercises in Wireshark
Nmap (Network mapper)
Features
q Powerful and popular network scanning tool.
q Can scan huge networks with 100,000s of machines.
q Can detect open ports, listening network services and OS version.
Basic scanning
q The simple command nmap <target> scans 1,000 TCP ports on the host (<target>).
§ nmap 192.168.1.1 – scan a single host
§ nmap 192.168.1.1-10 – scan a range of hosts
§ nmap 192.168.1.1/24 – scan a subnet
Nmap (Network mapper)
Host Discovery
qPING Scan (-sP/-sn):
§ One of the very first steps in any network reconnaissance mission is to reduce a (sometimes huge) set of IP 
ranges into a list of active or interesting hosts.
§ Scanning every port of every single IP address is slow (and usually unnecessary). 
§ Ping scan option tells Nmap not to do a port scan after host discovery, and only print out the available 
hosts that responded to the host discovery probes.
§ The default host discovery (a ping scan) for a privilege user consists of actions:
(1) ICMP echo request.
(2) TCP SYN to port 443.
(3) TCP ACK to port 80.
(4) ICMP timestamp request.
(*) For machines on a local ethernet network, ARP scanning will be performed.
§ When executed by an unprivileged user, only SYN packets are sent (i.e., using the connect system call – will 
be further explained later)
Nmap (Network mapper)
Port Scanning Basics
q Nmap is divides ports into six states as follows:
1. open: An application is actively accepting TCP connections or UDP datagrams on this port.
2. closed: A closed port is accessible (it receives and responds to Nmap probe packets), but there is no application 
listening on it.
3. filtered: Nmap cannot determine whether the port is open because packet filtering (e.g., a firewall, router rules 
etc.) prevents its probes from reaching the port.
4. unfiltered: A port is accessible (using ACK), but Nmap is unable to determine whether it is open or closed.
5. open|filtered: Nmap places ports in this state when it is unable to determine whether a port is open or filtered 
(This occurs for scan types in which open ports give no response.). 
6. closed|filtered: This state is used when Nmap is unable to determine whether a port is closed or filtered.
Nmap
Port Scanning technique:
q TCP SYN Scan (-sS): sends TCP packets to 
the targets on specific port.
§ do not creates a full TCP session (instead send 
RST after the SYN/ACK message).
§ requires root privileges.
§ the default port scanning method.
Example (1): TCP SYN scan on OPEN port
Example (2): TCP SYN scan on CLOSED port
Example (3): TCP SYN scan on FILTERED port
Nmap
Port Scanning technique:
q TCP connect scan (-sT): establish a connection with the target server by issuing the “connect” 
system call.
§ targets are more likely to allow the connection because it tries to establish a connection with target 
same as network.
§ scan takes more time to complete and requires to generate more packets.
§ does not requires root privileges. 
Example: TCP connect scan on OPEN port
Nmap
Port Scanning technique:
q UDP Scan (-sU): sends UDP packets in order to scan UDP ports (e.g, DNS, DHCP), can be 
combined with TCP SYN scan.
§ generally slower and more difficult than TCP.
§ sends a UDP packet to every targeted port.
§ for most ports the packet is empty (however, for some common ports such as 53, a protocol-specific 
payload is sent to increase response rate).
Nmap
Port Scanning technique:
qNull, Xmas and FIN Scan (-sN, -sX and -sF):
These three scan types exploit a loophole in 
the TCP RFC to differentiate 
between open and closed ports.
(*) TCP RFC says that any packet not containing 
SYN, RST, or ACK bits will result in a returned RST 
if the port is closed and no response at all if the 
port is open.
(**) These three scan types are exactly the same 
in behavior except for the TCP flags set in probe 
packets (see picture).
(***) If a RST packet is received, the port is 
considered closed, while no response means it 
is open or filtered (The port is marked filtered if 
an ICMP unreachable error is received).
Pros. The key advantage to these scan types is that they 
can sneak through certain non-stateful firewalls and 
packet filtering routers (however, most modern IDS 
products can be configured to detect them).
Cons. The big downside is that not all systems follow 
the TCP RFC.
Nmap
Service, version and OS Detection
q Service and version detection (-sV/-A) :
§ Nmap contains a database of fingerprints for about 
2,200 well-known services.
§ Nmap would report that those ports probably 
correspond to a mail server (SMTP), web server 
(HTTP), and name server (DNS) respectively - this 
lookup is usually accurate.
§ In addition, Nmap can derive the version number of 
service, which helps dramatically in determining 
which exploits a server is vulnerable to.
q OS detection (-O) :
§ One of Nmap's best-known features is remote OS 
detection using TCP/IP stack fingerprinting.
§ Nmap sends a series of TCP and UDP packets to the 
remote host and examines practically every bit in 
the responses.
§ After performing dozens of tests (such as TCP 
options support, the initial window size etc.), Nmap
compares the results to its with a database of more 
than 2,600 known OS fingerprints.
§ Each fingerprint includes a freeform textual 
description of the OS.
Nmap
Additional interesting flags:
-p <port ranges> : specifics which ports you 
want to scan.
--exclude-ports <port ranges> : this option 
specifies which ports you do want Nmap to 
exclude from scanning.
dnsmap
q Meant to be used by pentesters during the information gathering of infrastructure security asses.
q Finds IP addresses and sub-domains of a given domain using  brute-force techniques.
theharvester
q Help penetration testers in the early stages of the penetration test in order to understand the 
customer footprint on the internet
q Gather emails, subdomains, hosts, employee names, open port etc.
q Gather info from various sources : Google, LinkedIn, Twitter etc.
Theharvester Usage Example
Firewalk
q An active reconnaissance network security tool that attempts to determine what layer 4 
protocols a given IP forwarding device will pass (TCP/UDP)
q Firewalk works by sending out TCP or UDP packets with a TTL one greater than the targeted 
gateway
§ If the gateway allows the traffic, it will forward the packets to the next hop where they will expire and 
elicit an ICMP_TIME_EXCEEDED message. Else, it will likely drop the packets.
Firewalk – Usage Example
Parsero
q Free script written in Python
q Parsero reads Robot.txt file of a web server and looks at the Disallow entries
For Example: “Disallow /portal/login_access” 
q Disallow entries means that the content of the entries is not allowed to be indexed by crawlers 
like Google, Bing, Yahoo etc.
Parsero – Usage Example
DMitry
q Linux command line application
q Has the ability to gather as much information as possible about a host
v Sub-domains
v Email addresses
v Uptime Info.
v TCP port scan
v Whois lookups
Dmitry – Usage Example
Other Information gathering Tools
ü Previous tools documentation
ü Other powerful Info. Gathering tools
http://tools.kali.org/category/information-gathering
Open Kali Linux (LAB)
In order to start Kali Linux in the labs follow the next steps:
1. Open ‘VMware Player’ 
2. Choose ‘Player’
3. Choose ‘File’
4. Choose ‘Open a virtual machine’
5. Go to ‘E:/VM-s/Kali/’ and choose the VM file
Kali Linux
§ Username: root
§Password : toor
Lab Exercise – one week to submission 
1. Make list of 5 possible sub-domains for ise.bgu.ac.il and scan the lists to see weather the sub-
domain exists. Please append to the answer file both the list and the scan output.
2. What IP addresses can be pinged in the subnet 132.72.81.1/26 Notice IP address 132.72.81.35
◦ Is the host alive?
◦ Which TCP and UDP ports are opened? 
◦ What is the OS version on that device?
◦ What services are available (use version scan)?
3. Gather 5 emails addresses and 5 sub-domains of bgu.ac.il
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\Practices\Prac2\PS-2.pptx </DOCNO>
<F P=104> Security </F>
<TEXT>
PRACTICAL SESSION NO. 2
CRYPTOGRAPHY – PART A

Computer & Information Security
Cryptography
 Definition :
Latin: kryptós= hidden,  graphein = writing
The practice and study of techniques for secure communication


Julius Caesar
Ancient Greek Scytale
Enigma machine
Goals of Cryptography
 Confidentiality
Make sure that information cannot be accessed by unauthorized individuals, entities or process
Key exchange – Agree on secret key for encryption
Encryption – make the data readable only to trusted entities 
 Integrity 
 Validate that the message was not changed or replaced (Signature, Message Authentication Code)
Authentication
Source Authentication – validate the identity of the other side (signature, certificate)
Something you know: password, PIN code, your elementary school name etc,
Something you have : driver license, token, card etc. 
Something you are : Biometrics, fingerprints, retina (eye) etc.



3
Encryption
Symmetric Encryption
Public Key Encryption



4
Symmetric Encryption – Feistel Network
 Basis for symmetric block encryption algorithms like DES/3 DES  
 have a general iterative block cipher structure
sequence of rounds
substitutions/permutations controlled by key
 Main parameters and design features:
Block size, key size, number of rounds
Sub-key generation algorithm
 Sub-keys are generated using the (master) key and generation algorithm
 Plaintext is divided into two halves: L0 and R0
 F is a function that combines between Ri and Ki
Preforms substitution and permutation (or "confusion and diffusion“)
 N-rounds for encryption/decryption of a block 


Feistel Network – סכמה להצפנה סימטרית של בלוקים (אינה אלגוריתם בפני עצמו). אלגוריתמים כמו DES  ,3DES ומשתמשים בה.
תחילה הטקסט מחולק ל 2
תהליך הצפנה איטרטיבי
מהמפתח המקורי מייצרים תת מפתח שונה לכל שלב בעזרת אלגוריתם יצרת תת מפתחות
בכל שלב החלק הימני מהשלב הקודם הופך לחלק השמאלי
החלק השמאלי מהשלב הקודם עובר פונקציית הצפנה עם תת המפתח ו XOR עם החלק הימני הקודם. התוצאה עוברת לחלק הימני בשלב הבא
פונקציית ההצפנה מבצעת XOR עם תת-המפתח בשלב זה ולאחר מכן מסדרת את המידע מחדש כך שבכל פעם המידע "יזוז" ויתערבב עם חלקים אחרים




5
Cryptography
Data Encryption Standard (DES)
Symmetric Encryption Systems


Data Encryption Standard (DES)
 Based on Feistel Network
 Minor variation of the Feistel network
 Block size = 64 bit
 Master Key size = 64 bit 
Uses only 56 bit
Another 8 bit from the 64bit saved for error detection in key generation 
 16 rounds -> 16 sub-Keys Ki (48 bit each) are generated
 Can be cracked by brute force attack within few days using a PC
 Solution?

Encryption
Decryption

לוקחים מפתח של 64 ביטים, בפועל משתמשים רק ב56 ביטים על מנת לחולל 16 מפתחות בגודל של 48 ביטים כ"א
7
3-DES (ECB Mode)
Enc (DES)
PT
KEY 1
Cipher A
Dec (DES)
KEY 2
Cipher B
Enc (DES)
KEY 3
Cipher
64bit
64bit
Dec (DES)
PT
KEY 3
Cipher B
Enc (DES)
KEY 2
Cipher A
Dec (DES)
KEY 1
64bit
64bit
Cipher


Encryption
Decription

יותר חזק אך משלמים בביצועים
8
What about 2-DES?
 2-DES – good or a bad idea? Think!
 Does brute force attack yields the best result?



 Known Plaintext Attack 
 The attacker knows both the Plaintext and
Cipher. Thus, can reveal the encryption key


2-DES : Meet in the middle attack 
 Solution:
Given a two pairs of Plain-text and Cypher-text <P1,C1>,<P2,C2>
Encrypt P1 with DES using all possible keys
Decrypt C1 with DES using all possible keys
Compare the encryption outputs with the decryption outputs
Every matching  will reveal a possible K1,K2 pair
Test all possible key-pairs on <P2,C2> to reveal the correct key-pair
 Time complexity:
Encrypt with all possible keys (in DES = O()) 
Decrypt with all possible keys (in DES = O())
Compare results – O(1) using look up table
 Memory: look up table requires O() memory


הבהרה: 
גודל הmaster key הוא 64 ביט, אך בפועל במהלך אלגוריתם יצירת המפתחות (לכל האיטרציות) לא משתמשים בביטים שהם כפולות של 8 (הביט ה8,16,24..64(,
ולכן התקפת Brute Force תעבור רק על הביטים הרלוונטיים שהם סה"כ 56 ביטים.
10
DES - Question
Think…
4. 	1. 
5. 	2. 
6. 	3. 
DES - Solution



Equations:	




לסמן נקודות על הלוח שיהיה נוח לסטודנטים להבין
12
4. 	1. 
5. 	2. 
6. 	3. 
DES – Solution (cont.)


  9) 

11)  5 ,1 :  =
12) 








DES- Solution (cont.)
 9) 
12) 


Hence,



We can decrypt any cryptograms in O(1) complexity 





14
Cryptography
Advanced Encryption Standard (AES)
Symmetric Encryption Systems
Advanced Encryption Standard (AES)

 More secure and faster than 3DES
 key length can be 128 /192/ 256 bits
 Not a Feistel network but also an iterative algorithm
 A data block is represented as 4X4 Bytes matrix (128 bit) called State
 Applies 10 rounds:
In each* step preform:
Substitute bytes (SubBytes)
Shift rows
Mix columns
Add round key (the only stage that uses the key)


הרעיון מזכיר רשת פייסטל אבל זה לא מבוסס על הסכמה שלו.
כיום האלגוריתם נפוץ עם מפתחות בגודל של 128 ביטים
האלגוריתם איטרטיבי ומפעיל תת-מפתח בכל שלב.
גם האלגוריתם הזה מסדר את המידע בכל שלב כדי שהרבה ביטים "יגעו" אחד בשני.

האלגוריתם בנוי מארבע תתי שלבים שמופעלים (כמעט) בכל שלב:
בשלב הראשון מבצעים רק את פעולה add round key
בשלב האחרון לא מבצעים את הפעולה mix columns
16
AES – Pseudo Code

האלגוריתם בנוי מארבע תתי שלבים שמופעלים (כמעט) בכל שלב:
בשלב הראשון מבצעים רק את פעולה add round key
בשלב האחרון לא מבצעים את הפעולה mix columns

17
AES – Substitute bytes
 Done with a simple lookup (inversable) table called S-Box
a 1616 matrix of byte values
maps each byte to a new value
e.g. {95} maps to {2A}
Adds non-linearity to the encryption
 Constructed using finite field properties
designed to be resistant to known cryptanalytic attacks
 Decrypt uses inverse of S-Box


18
S-Box 




Shift Rows
 On encryption: shift each row of State by 0,1,2,3 bytes respectively 
    (first row remains original)
 Ensures that each column is now spread over 4 columns
 Decrypt does reverse


שורה ראשונה מבצעת הזזה ציקלית שמאלה של 0 בתים, שורה שניה של 1 בתים, שורה שלישית של 2 בתים ושורה רביעית של 3 בתים. 
להראות הסבר על העובדה שלאחר הSHIFT ROWS כל עמודה "נפרסת" על 4 עמודות – יש חשיבות גבוהה לפיצול ל4 עמודות בשביל חוזק ההצפנה

20
Mix Column
 Operates on each column individually
 Each column C is multiplied by a constant matrix M
Cnew = M * C
Every new value is a function of all four bytes in the column



Note that in a finite field the arithmetic operations (addition and multiplication) are different from non finite fields   


כדאי להזכיר איך עובד כפל מטריצות

כיוון שהמטריצות קבועות ומספר הערכים האפשריים בעמודות קטן אפשר לבנות טבלה של תוצאות כפל במקום לכפול כל פעם

פעולת ה SHIFT-ROWS ו MIX-Columns דואג שלאחר מספר סיבובים הפלט יהיה תלוי בכל הביטים

=> כלומר הודעה עם ביט אחד שונה תשפיע על ההצפנה של כל הביטים – מקשה מאוד על פיצוח הצופן

21
Add Round Key
 XOR State with bits of expanded key





 The round key expansion and other stages of AES make the algorithm secure


בשלב הזה פשוט עושים XOR עם המפתח באותו שלב.

מה שמבטיח שהאלגוריתם יהיה "בטוח" הם השלבים האחרים שמבצעים והדרך בה יוצרים את תתי המפתחות

22
Expanded Key -176 byte Key

Word0
Word1
Word2
Word3

Original Key
16 byte Key (4 Words)
			
			
			
			
			
			
			

Word0
Word1
Word2
Word3

……
….
…..
……

Word4  =  F(word3,word,0)
Word5  =  F(word4,word,1)
Word6  =  F(word5,word,2)
Word7  =  F(word6,word,3)

			
			
			
			


Original
 Key


Sub-k10

Sub-k9
Sub-k2
Sub-k0
…
11 sub – keys (16 bytes)

Word40
Word41
Word42
Word43
AES - Key-Expansion and Creation of Round-Key


23
AES – Animation example

https://www.youtube.com/watch?v=mlzxpkdXP58

Why Shift-Rows & Mix-Columns Are Important?
 The mix column transformation combined with the shift row transformation ensures that after a few rounds, all output bits depend on all input bits
 Do these actions help against brute-force attack?
No!
However, Brute-force on the key is impossible ( possibilities)
 So what are they good for?
Improve encryption (cypher  plain text)
Harder to perform known plain/cypher text attacks
Guessing part of the key will not be helpful

Why Shift-Rows & Mix-Columns Are Important?
Consider K1 and K2:


 Lets encrypt an image using AES with K1 and K2


K1
K2


26
Why Shift-Rows & Mix-Columns Are Important?
What would happened if we decrypted with the opposed key? 













K1
K2


K2
K1

The Keys have just 1 different bit!!
Why Shift-Rows & Mix-Columns Are Important?
What would happened if we didn’t mixed columns?

K2


K2
K1
K1


28
Why Shift-Rows & Mix-Columns Are Important?
What would happened if we didn’t shift rows?

K1
K2


K2
K1


29
Why Shift-Rows & Mix-Columns Are Important?
SUMMARY
 Its quite noticeable that Mix Columns and Shift-Rows are important for the encryption
 Applying this steps will generate totally different results even when the key is almost the same (1 bit is different)

NO SHIFT-ROWS AND NO MIX-COLUMNS
K1
K2


K2
K1
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\Practices\Prac3\PS-3-new.pptx </DOCNO>
<F P=104> Security </F>
<TEXT>
PRACTICAL SESSION NO. 3
CRYPTOGRAPHY – PART B

Computer & Information Security
Encryption
Symmetric Encryption
Public Key Encryption



2
Recall: AES – Pseudo Code

האלגוריתם בנוי מארבע תתי שלבים שמופעלים (כמעט) בכל שלב:
בשלב הראשון מבצעים רק את פעולה add round key
בשלב האחרון לא מבצעים את הפעולה mix columns

3
Question 1
Bob’s and Alice share a secret key K (256 bit). 
Alice sends Bob a message using the following algorithm:
1) String FinalCypher = “”
2) For index = 0 to length(message):
2.1) Char c = Message[i]
2.2) Int tmp = convert c to an integer according to lexicographical order 
2.3) String cyp = AES(tmp,K)
2.4) FinalCypher.append(cyp)
3) Alice sends Bob Final-Cypher



4
Question 1 - cont
Question 1A: Is the suggested protocol is secured against brute force for finding the correct key?
1) String FinalCypher = “”
2) For index = 0 to length(message):
2.1) Char c = Message[i]
2.2) Int tmp = convert c to an integer according to lexicographical order 
2.3) String cyp = AES(tmp,K)
2.4) FinalCypher.append(cyp)
3) Alice sends Bob Final-Cypher



5
Question 1 - cont
Question 1A: Is the suggested protocol is secured against brute force for finding the correct key?

Yes. 
In this question the symmetric key is 256 bit long 
So applying a brute-force attack requires the attacker to decrypt the message with every possible key  possible keys).
 ~ (about 9.63× years for the fastest computer today).


6
Question 1 - cont
Question 1B: Is this protocol is secured?

1) String FinalCypher = “”
2) For index = 0 to length(message):
2.1) Char c = Message[i]
2.2) Int tmp = convert c to an integer according to lexicographical order 
2.3) String cyp = AES(tmp,K)
2.4) FinalCypher.append(cyp)
3) Alice sends Bob Final-Cypher



7
Question 1 - cont
Question 1B: Is this protocol is secured?

What is the size of the domain of all possible cyphers?
Size of English alphabet = |{A,B,C……..,Z}| = 26

How can attackers decrypt each of the 26 characters?
The attacker can create a histogram that counts each of the cyphers that have been seen in several messages. The size of the histogram is 26.
The attacker can infer the character that belongs to each of the cyphers by comparing the distribution of the histogram with the known distribution for English alphabet.


8
Question 1 - cont
Question 1C: How can mitigate such an attack?



9
Question 1 - cont
Question 1C: How can mitigate such an attack?

By encrypting a few characters together (e.g., 256 bit) instead of encrypting each character by its own.



10
Question 2
Prove that Simple AES is vulnerable to a known plaintext attack.

Known Plaintext Attack 
The attacker knows both the Plaintext and
Cipher. 

Question 2 - Solution
C = Simple_AES(M,K1) = 
AddRoundKey(MixColumns(ShiftRows(SubBytes(M))),K1)
Question 2 - Solution
C = Simple_AES(M,K1) = 
AddRoundKey(MixColumns(ShiftRows(SubBytes(M))),K1)

Lets define S as:
S = MixColumns(ShiftRows(SubBytes(M)))
=>
 C  = AddRoundKey(S,K1)
Question 2 - Solution
S = MixColumns(ShiftRows(SubBytes(M)))

The attacker can calculate S because:
The method SubBytes - is known to anyone
The method ShiftRows - is known to anyone
The method MixColumns – is known to anyone
M – is known to the attacker
Question 2 - Solution
The attacker can calculate S because:
 C  = AddRoundKey(S,K1) = SꚚK1
=>
K1 = SꚚC
We calculated S and C is known.
Cryptography 
Message Authentication Codes (MAC)
Integrity
Message Authentication Codes (MAC)
MAC is a short piece of information used to authenticate a message - in other words, to confirm that the message came from the stated sender (its authenticity) and has not been changed.
Message Authentication Codes (MAC)
MAC is a short piece of information used to authenticate a message - in other words, to confirm that the message came from the stated sender (its authenticity) and has not been changed.

Used for:
Integrity – assuring that the message was not changed.
Authentication – authenticating the sender.
Message Authentication Codes (MAC)
There are many implementation of MAC algorithms
The following MAC algorithm is based on a symmetric key K.
Sender
Calculates MAC for a message using a symmetric MAC algorithm.
Sends the MAC and the message together.

Receiver
Calculates MAC for the received message using a symmetric MAC algorithm.
Compares the output to the received output.

MAC is required to be smaller than the original data

CBC-MAC Algorithm Scheme
 Message = m1 m2  …  mx
 Symetric key K and symetric encription algortim E



להראות דוג' על הלוח
20
Attacks on CBC-MAC
 Concatenation attack
Eve choses m1, m2 randomly
Eve asks for m1 encryption - 
Eve calculates and asks encryption of 
,k) = 
Now ) is a valid CBC-MAC of 





Question 3 
A new system was installed on the front gate to a secret organization. When a worker wish to enter the organization and open the front gate he/she uses a dedicated application that runs the following code:





K1 is a symmetric key that is shared by the entire users of the application.
Server on the Internet
Open-Door-1(){
String command = “Open”
String cypher = AES(command,K1)
Send-command-to-server(cypher1)
}
Question 3 
Question 3A: What is the problem with the suggested algorithm?

Question 3 
Question 3A: What is the problem with the suggested algorithm?

The cryptogram that is sent to the server remains the same so attacker can apply a replay attack:
Attacker intercepts a message that is sent to the cloud
Attacker retransmit the message
The gate is opened
Question 3 
Question 3B: In order to mitigate a replay attack, the developers included a message authentication code in the protocol. Is the system secured from replay attacks?

Open-Door-2(){
String command = “Open”
String cypher1 = AES-ENCRYPT(command,K1)
String cypher2 = MAC(command,K2)
Send-to-server(cypher1,cypher2)
}
Question 3 
Question 3B: In order to mitigate a replay attack, the developers included a message authentication code in the protocol. Is the system secured from replay attacks?

No. If the attacker managed to intercept the cypher1 and cypher2 he\she can open the gate and send retransmit them and open the gate.

Open-Door-2(){
String command = “Open”
String cypher1 = AES-ENCRYPT(command,K1)
String cypher2 = MAC(command,K2)
Send-to-server(cypher1,cypher2)
}
Question 3 
Question 3C: How can we secure the system?


Question 3 
Question 3C: How can we secure the system?
By using a ticket: adding the time that the command was sent and limiting validity of the command to a reasonable window of time.

Gate
Decrypt the command and the timestamp using AES.
If more than 1 minute was not passed from the sent timestamp, than open the gate.
Sender
Open-Door-2(){
String timestamp = currentTime ()
String command = “Open” 
String cypher1 = AES(command,K1)
String cypher2 = AES(timestamp,K2)
Send-to-server(cypher1,cypher2)
}

 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\Practices\Prac4\PS-4.pptx </DOCNO>
<F P=104> Security </F>
<TEXT>
PRACTICAL SESSION NO. 4
CRYPTOGRAPHY – PART C

Computer & Information Security
Encryption
Symmetric Encryption
Public Key Encryption



2
Public Key Encryption


Primary Motivation: It is very difficult for two parties to share a symmetric key. 

How can they distribute it to each other?




3
Cryptography
RSA Algorithm (Rivest, Shamir & Adelman)
Public Key Cryptography
RSA Algorithm
 Key Generation
Randomly choose two distinct prime numbers  and  
Compute 
Compute the Euler's function -  
 where 
If  -> example: n=5 {1,2,3,4}-> size=4=5-1
 -> example: p=2 q=3 {1,2,3,4,5} -> size =  2 = (2-1)*(3-1)=1*2 =2
Choose an integer 
Public-Key = 
Determine an integer that 
Private-key = 
 Encryption

 Decryption



פי של אן היא בעצם פונקציה שאומרת כמה מספרים קטנים מאן יש שאין להם מחלק משותף עם אן
D הוא ההופכי של e בשדה סופי

5
RSA- Example
Key Generation


Need to chose  where, 
let 
Public-Key: (7, 55)
Let’s compute  : 
 
Private-Key: (23,55)
Encryption 
Message = 2
Cypher = Messagee mod n

Decryption
Message = Cypherd mod n






6
Possible attacks on RSA
In order to break RSA, we need to calculate , such that:

Note that is public, thus we need to find:

so we need to find  such that 
integer factorization (Prime factorization) is Not an easy task
For year 2009 it takes approximately two years to factorize a 768 bit number

בעיית הפירוק לגורמים היא בעיה קשה
אם נצליח לפרק נמצא את d (המפתח הפרטי ופרצנו את המערכת)
7
Possible attacks on RSA – chosen Cyphertext attack
 Notice the following attributes of RSA (Multiplicative)
  * 
 
 Given a cypher  that we want to decrypt, we lot  and  calculate 
 Than we can ask to decrypt   and and get and 
  is the decryption


Cryptographic hash function are used in order to mitigates this attack!


8
Hybrid Protocol
 RSA is much slower than symmetric algorithms
 The hybrid algorithm take the advantages of symmetric and asymmetric key
Algorithm:
Generate a symmetric key 
The sender encrypt  with the public key  of the receiver
 
The receiver decrypts  using his private key 

Both the receiver and the sender have the same symmetric key 
The communication are encrypted using symmetric algorithm such as AES or DES
Hybrid Protocol
Considering the suggested protocol:
Algorithm:
Generate a symmetric key 
The sender encrypt  with the public key  of the receiver
 
The receiver decrypts  using his private key 

Both the receiver and the sender have the same symmetric key 
The communication are encrypted using symmetric algorithm such as AES or DES

Question: 
Alice wants to send a message to Bob. However, Bob does not own a public key.

What can they do if Alice owns a key?
What can they do if none of them owns a key?
Hybrid Protocol
Question: 
Alice wants to send a message to Bob. However, Bob does not own a public key.

What can they do if Alice owns a key?
What can they do if none of them owns a key?

Conclusion: 
At least one of the parties should maintain a public key.
Cryptography 
Diffie – Hellman Protocol (Key Exchange)
Public Key Cryptography
Diffie-Hellman Protocol

 The first algorithm that was developed in order to enable two parties to agree about a key
 The messages exchanged between two parties sent over public channel that can be eavesdropped by an attacker
 Based on public key cryptography

Primitive root modulo prime
 In modular arithmetic, a number  is a primitive root modulo  if every number  is a power of  modulo n. 
Reminder 
 That is, for every integer  coprime to n, there is an integer  such that .
 Such  is called the discrete logarithm of  to the base  modulo 
 For example, The number 3 is a primitive root modulo 7







Primitive root modulo prime - Algorithm
Algorithm for calculating the prime root of 
Calculate 
Determine all the prime factors  of 
For every   
Count = 0
For every  If () than count = count + 1
If(count == i) return x

Primitive root modulo prime - example
16

 Assume we want to calculate the prime root  of 
 Calculate 
 Determine all the prime factors  of 
 

 






16
Diffie-Hellman Example

Alice choose 
Bob Choose 
Alice sends to Bob 
Bob sends to Alice 

Eve can see 27 and 10 but it hard to calculate 19 from it (e.q to discrete logarithm)


Visible to the attacker
Cryptography 
Man In The Middle (MiM) Attack
Public Key Cryptography
Man In the Middle 
 Two people can decide about public keys (like in Diffie Hellman protocol) 
 However, an attacker can intermediate during the key exchange and cause both sides to believe he is the other side
Man In the Middle


3. 

Man In the Middle


In the end of the attack, the attacker holds two symmetric keys (one with each party) 
Problem: We don’t bind a key to its owner (identity)
Cryptography 
Digital Signatures
Public Key Cryptography
Digital signatures 
Goals:
 Authentication -the source of the message (who is the sender)
 Integrity –Nobody changed the content of the message 
 Non-repudiation of origin– The sender is the only one who can sign the message, the sender cannot deny signing the message
 Asymmetric key cryptography uses:
Private key- the sender signs on the message
Public key- authentication of the signature

Digital signatures 

Digital 
Signature 
Kprivate
Message



Transmit
Calc msg hash





Digital 
Signature 
Kpublic
msg. hash
decrypt signature
Compare


24
Digital signatures - Algorithm
The algorithm consists of two functions:
The signature function
  
The verification function



פונקציה חתימה Sig הצפנה של הודעה M על ידי המפתח הפרטי של המשתמש u.
פונקצית V פענוח ההודעה בעזרת המפתח הפומבי של u.


25
RSA Digital Signature 
 The sender chooses:
Public-key  and Private-key  
everybody can verify the signature
only the sender can sign the message
The sender signs the message M using the private key:
 
 The receiver verifies the signature using the public key
 = 

RSA Digital Signature - Attacks 
Similar to the RSA attack If the attacker saw two signed messages:


He can generate the signature of 
= *  

Digital Signature – More Problems
When we use digital signature we enlarge the amount of data we need to transfer
Computation time of the digital signature is very long and depends on the size of the message
The verification time is long too, and also depends on the size of the message


מגדילה את התעבורה ברשת


28
Public-Key vs Symmetric-Key Cryptography
Public-Key	Symmetric-Key
Each user has a pair of cryptographic keys. A public encryption key, and a private decryption key	The encryption and decryption keys are trivially related
The publicly available encrypting key is widely distributed and the private decrypting key is known only to the recipient (The private key cannot feasibly be derived from the public key)	The key is a secret
Very slow	Very fast
Rely on complexity of mathematic problems (for example, integer factorization, discrete log)	Do not relay on complexity of mathematic problems
Related algorithms: RSA, Elgamal, Diffie-Helman	Related algorithms: AES, DES
Uses for authentication, key agreement and integrity (digital signature)	Uses for confidentiality (encryption) and integrity (MAC)
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\intro\Cryptography-2\CompNetSec3_Cryptographic-Algorithms-Final.pdf </DOCNO>
<F P=104> Security </F>
<TEXT>
Computer & Information Security (372-1-460-1)
Cryptographic Algorithms
Dept. of Software and Information 
Systems Engineering, Ben-Gurion University
Prof. Yuval Elovici, Dr. Asaf Shabtai
{elovici, shabtaia}@bgu.ac.il
Spring, 2018
1
Applications of encryption
2
Applications of encryption
3
Applications of encryption
4
Applications of encryption
5
Applications of encryption
A general UI attack:  picture-in-
picture
Using Digital signatures for code 
signing
8
Cryptography classification
• operations used
– Substitution
– transposition
• keys used
– symmetric
– asymmetric
• how plaintext is processed
– block cipher – processes input one block of elements at 
a time
• Difficult to design: must resist subtle attacks such as 
differential attacks,  linear attacks, brute-force,  …
– stream cipher – processes the input elements 
continuously
9
Cryptanalysis [595]
type of attack known to cryptanalyst
- Least info (very hard) = Brute Force on all possible keys
- Statistical tests + prior knowledge  about  plaintext’s language 
(English, Java), only weak encryption algorithms fails
- More info (still hard) – helps deducing the encryption key
- E.g., Email message has known format
- Certain key words inside specific locations in the file such as: 
“Bank Account”, “Date”
- Probable-Word-attack
- The attacker has an access to the encryption system
- Then can encrypt specific patterns that will help him to reveal 
the structure of the key
- Less common
- The attacker has an access to the encryption system
- Then can decrypt chosen ciphertext patterns that will help him to 
reveal the structure of the key
- Less common
- Combines both Chosen plaintext and Chosen ciphertext
10
Computationally secure 
encryption schemes
• encryption is computationally secure if
– cost of breaking cipher exceeds value of 
information
– time required to break cipher exceeds the 
useful lifetime of the information
• usually very difficult to estimate the 
amount of effort required to break
• can estimate time/cost of a brute-force 
attack
– on average, half of the keys must be tried
11
Advanced Encryption Standard 
(AES)
• AES is more secure and efficient than DES/3DES
• block length of 128 bits 
• key length that can be 128 /192/ 256 bits
• not a Feistel structure
• applies 10 rounds
• four stages
– substitute bytes (SubBytes)
– shift rows
– mix columns
– add round key (the only stage that uses the key)
12
Advanced 
Encryption 
Standard 
(AES)
13
Advanced Encryption Standard 
(AES)
• Plaintext and Keys (128 bit) represented by 4X4 matrix:
– each cell contains 1 byte (8 bits)
– bits are ordered by columns from the leftmost to the rightmost
• 128 bit: 1110101010000011010111001111000000000100……11000101
(E A)      (8 3)       (5 c)     (F 0)         (0 4)            (C 5)  
14
AES Round Structure
15
Substitute Bytes
• a simple table lookup in S-box
– a 1616 matrix of byte values
– a permutation of all possible 256 8-bit values
– maps each byte to a new value
• e.g. {95} maps to {2A}
• constructed using finite field properties
– designed to be resistant to known 
cryptanalytic attacks
• decrypt uses inverse of S-box
16
Substitute Bytes
17
• ab16 = 11101010
(E A)
S-box (Encryption)
18
Inverse S-box (Decryption)
19
Shift Rows
• on encryption: shift each row of State by 
0,1,2,3 bytes respectively
• ensures that each column is now spread over 
four columns
• decrypt does reverse
20
Mix Column
• mix columns
– operates on each column individually
– mapping each byte to a new value that is a 
function of all four bytes in the column
– use of equations over finite fields
– to provide good mixing of bytes in column
21
Add round key
• simply XOR State with bits of expanded 
key
• security from complexity of round key 
expansion and other stages of AES
22
Key-Expansion and creation of 
Round-Key
• Using the symmetric key 128 bit (16 
bytes)
– create expended-Key of 176 bytes
– from which create 11 different round keys 
– each key is 16 bytes = 4 words of 4 bytes
– the first key in is the original key
– using a complex finite field algorithm, each 
added Word in the expanded key depends 
on the two previous words w[i-1] and w[i-4]
23
Key-Expansion and creation of 
Round-Key
24
Expanded Key
176 byte Key (44 Words)
Word0
Word1
Word2
Word3
Original Key
16 byte Key (4 Words)
Word0
Word1
Word2
Word3
Word40
Word41
Word42
Word43
……
….
…..
……
Word4  =  F(word3,word,0)
Word5  = F(word4,word,1)
Word6  = F(word5,word,2)
Word7  =  F(word6,word,3)
Original
Key
Add round key
• simply XOR State with bits of expanded 
key
• security from complexity of round key 
expansion and other stages of AES
25
AES steps
Stage 1: SubBytes
Stage 2: ShiftRows
Stage 3: MixColumns
Stage 4: AddRoundKey
26
RSA Public-Key Encryption
• by Rivest, Shamir & Adleman of MIT in 1977 
• best known and widely used public-key algorithm 
• uses exponentiation of integers modulo a prime
• encrypt: C = Me mod n
• decrypt: M = Cd mod n = (Me)d mod n = M
• both sender and receiver know values of n and e
• only receiver knows value of d
• public-key encryption algorithm with
– public key PU = {e, n} and private key PR = {d, n}
27
RSA Algorithm [637\667]
public key PU = {e, n}
private key PR = {d, n}
Φ(n) – Euler totient function
counts the positive integers 
less than or equal to n that 
are relatively prime to n
Φ(9) = 6
1,2,4,5,7,8 ?
Φ(7) = 6
28
RSA Example – Key Generation
29
RSA Example – Encryption\Decryption
public key PU = {e=7, n=187}                        PR = {d=23, n=187} private key 
For encrypting Message M with plaintext = 88
30
Attacks on RSA
• brute force
– trying all possible private keys
– use larger key, but then the process is slower
• mathematical attacks (factoring n)
– n = pXq  finding p,q enables to find Φ(n) and 
finally d
– currently 1024-2048-bit keys seem secure
– the threat still exists regarding to larger keys:
• increasing computing power
• refinement of factoring algorithms (QS, GNFS, 
SNFS)
31
Attacks on RSA
• timing attacks (on implementation)
– Paul Kocher: possible to determine private 
key according to the time takes to decrypt 
message
– use to prevent: constant time, random 
delays, blinding (multiply by random 
numbers)
• chosen ciphertext attacks (on RSA 
props)
32
Diffie-Hellman Key exchange
• first published public-key algorithm by 
Diffie and Hellman in 1976 
• used in a number of commercial products
• practical method to exchange a secret 
key securely that can then be used for 
subsequent encryption of messages
• security relies on difficulty of computing 
discrete logarithms 
33
34
Primitive root
• Let p be a prime
• Then b is a primitive root of p if the 
powers of b: 1, b, b^2, b^3, ... include all 
of the residue classes mod p (except 0)
• If p=7, then 3 is a primitive root for p 
1, 3, 9, 27, 81, 243 mod 7 = 
1, 3, 2, 6, 4, 5
35
Key Exchange Protocols
36
Diffie-Hellman: key exchange 
algorithm
37
Diffie-Hellman: Proof
38
Diffie-Hellman Example
• have
– prime number q = 353 
– primitive root  = 3
– XA = 97
– XB = 233
• A and B each compute their public keys
– A computes YA = 3
97 mod 353 = 40
– B computes YB = 3
233 mod 353 = 248
• then exchange and compute secret key:
– for A: K = (YB)
XA mod 353 = 24897 mod 353 = 160
– for B: K = (YA)
XB mod 353 = 40233 mod 353 = 160
• attacker must solve:
– 3Xa mod 353 = 40 , with brute force which is feasible (97)
– desired answer is 97, then compute key as B does
– impractical to do it for large prime numbers (, q)
– since it is hard to calculate discrete logarithms
39
Man-in-the-Middle Attack
• attack is:
1. Darth generates private keys XD1 & XD2, and their  
public keys YD1 & YD2
2. Alice transmits YA to Bob
3. Darth intercepts YA and transmits YD1 to Bob. 
Darth also calculates K2
4. Bob receives YD1 and calculates  K1
5. Bob transmits XA to Alice
6. Darth intercepts XA and transmits YD2 to Alice. 
Darth calculates K1
7. Alice receives YD2 and calculates  K2
• all subsequent communications compromised
40
Man-in-the-Middle Attack
• attack is:
1. A  E alpha^x mod p 
2. B  E alpha^y mod p
3. E  B alpha^z mod p
4. E  A alpha^ze mod p
5. Darth generates private keys XD1 & XD2, and their  public 
keys YD1 & YD2
6. Alice transmits YA to Bob
7. Darth intercepts YA and transmits YD1 to Bob. Darth also 
calculates K2
8. Bob receives YD1 and calculates  K1
9. Bob transmits XA to Alice
10. Darth intercepts XA and transmits YD2 to Alice. Darth 
calculates K1
11. Alice receives YD2 and calculates  K2
• all subsequent communications compromised
41
Simple Hash Functions
• a one-way or secure hash function used in:
– message authentication
– source authentication )digital signatures(
• all hash functions process input a block at a time in 
an iterative fashion
• one of simplest hash functions is the bit-by-bit 
exclusive-OR (XOR) of each block
Ci = bi1  bi2  . . . bim
– effective data integrity check on random data
– less effective on more predictable data
– virtually useless for data security
42
Secure Hash Functions [657]
43
Characteristics
• Given M (plaintext), it is easy to 
compute h (hash code)
• Given h, it is hard to compute M such 
that H(M) = h
• Given M, it is hard to find another 
message, M’, such that H(M) = H(M’)
• Collision-resistance: it is hard to find 
two random messages, M and M’, such 
that H(M) = H(M’)
44
Secure Hash Algorithm (SHA)
• SHA was originally developed by NIST
• published as FIPS 180 in 1993 (federal 
information processing standard)
• was revised in 1995 as SHA-1
– produces 160-bit hash values 
• NIST issued revised FIPS 180-2 in 2002
– adds 3 additional versions of SHA: SHA-256, 
SHA-384, SHA-512
– with 256/384/512-bit hash values
– same basic structure as SHA-1 but greater 
security
45
SHA-512 Steps
• Step 1: Append padding bits
– 896 mod 1024
– Padding always added (1-1024 bit)
• Step 2: Append length
– 128 bits that represent the length of the message before 
padding
• Step 3: Initialize hash buffer (IV)
– A 512 bit buffer of 8 X 64 bit registers (a,b,c,d,e,f,g,h)
• Step 4: Process message in 1024-bit (128-word) blocks
– F = The heart module of SHA-512 and is being done 80 rounds
• Step 5: Output
– A 512 bit message digest
46
SHA-512 Structure
47
SHA-512
Initial Values
• initialise 8 (512-bit) buffer (A,B,C,D,E,F,G,H) to 
6a09e667f3bcc908
Bb67ae8584caa73b
3c6ef372fe94f82b
a54ff53a5f1d36f1
510e527fade682d1
9b05688c2b3e6c1f
1f83d9abfb41bd6b
5be0cd19137e2179
48
SHA-512 
Round
49
SHA-512 
Message Scheduling






7916  ,)()(
150  , 
16155726 tWWfWWf
tM
W
t-t-t-t-
t
t
50
SHA-512 Round Function
51
80 Constants (Kt)
428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 
3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118 
d807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2 
72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694 
e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 
2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5
983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4 
c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70 
27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 
650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b 
52
80 Constants (Kt)
a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30
d192e819d6ef5218 d69906245565a910 F40e35855771202a 106aa07032bbd1b8 
19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8
391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3 
748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab7 8cc702081a6439ec 
90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b 
ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e F57d4f7fee6ed178 
06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b 
28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c 
4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817 
53
Combining MAC and Encryption
Option 1:  MAC-then-Encrypt (SSL)
Option 2:  Encrypt-then-MAC (IPsec)
Option 3:   Encrypt-and-MAC (SSH)
Msg  M Msg  M MAC
Enc KEMAC(M,KI)
Msg  M
Enc KE
MAC
MAC(C, KI)
Msg  M
Enc KE
MAC
MAC(M, KI)
Encryption key  KE MAC key = KI
Applications of asymmetric 
cryptography
• Session set up
• Non-interactive applications (e.g.  
sending emails Email)
• Encrypting file systems
• Key escrow: data recovery
55
Location of Encryption
56
Location of Encryption
• Link Encryption
– Every vulnerable link is equipped on both end with 
encryption device
– Requires lots of encryption devices
– The message and its header as well are encrypted thus 
must be decrypted in every switch – so the switch will 
know how to route it next
– The message is vulnerable at every switch
• End-to-End Encryption
– The message is encrypted only at end points
– The header is not encrypted – allows the switch to rout 
it without decrypt
– The header (traffic patterns) is not secured
57
Location of Encryption
• Solution: combine between Link and end-
to-end encryption
– Encrypt the message using end-to-end encryption
– Then encrypt the encrypted messages + the 
header using the link Encryption
– The entire message is secured, except the time 
that the header is decrypted and vulnerable at the 
switch’s memory
58
Key Distribution
59
Limitations of cryptography
• People make other mistakes; crypto doesn’t 
solve them
• Misuse of cryptography is fatal for security 
(e.g., WEP)
Stream Ciphers
• processes input elements continuously
• key input to a pseudorandom bit 
generator
– produces stream of random like numbers 
using the key
– unpredictable without knowing input key
– XOR keystream output with plaintext bytes
• are faster and use far less code than 
Block-Cyphers
61
Stream Ciphers
• design considerations:
– encryption sequence should have a large 
period – since it eventually repeats
– keystream approximates random number 
properties 1s ~= 0s
– uses a sufficiently long key to protect 
against brute force attack
62
Stream Ciphers
63
The RC4 Algorithm
• Designed in 1987 by Ron Rivest for RSA 
Security
• Stream cipher with byte-oriented operations
• Based on the use of a random permutation
• Can be expected to run very quickly in software
• Used in the SSL/TLS standards, WEP (Wired 
Equivalent Privacy) and WPA (WiFi Protected 
Access) protocol 
• In September 1994 was anonymously posted on 
the Internet
64
RC4 Description
• Three main parts:
– initialization of State Vector with the 
Symmetric Key
– initial permutation = KSA (Key Scheduling 
Algorithm)
– stream generation = PRGA (Pseudo Random 
Generation algorithm)
• Notation:
– S = {0, 1, 2, … n-1} is the initial permutation
– l = length of key
65
The RC4 Algorithm
66
RC4: Initialization of State 
Vector
67
  Two vectors of :
     [0],  [1],  [2],  ,  [255]
     [0],  [1],  [2],  ,  [255]
  Key: variable length, from 1 to 256 bytes
  Initialization:
    1.   [ ] ,   for 0 255
    2.   [
bytes
]  [  
S S S S
T T T T
S i i i
T i K i





  
  mod  key-length],  for 0 255
          (i.e., fill up [0..255] with the key  repeatedly.)
i
T K
 
RC4: Initial Permutation (KSA)
68
  Initial Permutation of :
        0
        for   0 to 255 do
                (   [ ]  [ ] )  mod  256
              Swap  [ ],  [ ]
  This part of RC4 is generally known as the 
    Key Sch
S
j
i
j j S i T i
S i S j



  

eduling Algorithm (KSA).
  After KSA, the input key and the temporary
    vector  will no longer be used.T

RC4: Key Stream Generation
69
  Key stream generation:
        ,    0
        while  (true)
                  (   1 )  mod  256
                  (   [ ] )  mod  256
               Swap  [ ],  [ ]
                 ( [ ] 
i j
i i
j j S i
S i S j
t S i


 
 
  [ ] )  mod  256
                 [ ]
               output  
S j
k S t
k


RC4 Example
• Simple 4-byte example
• S = {0, 1, 2, 3}
• K = {1, 7, 1, 7}
• Set i = j = 0
70
KSA
• First Iteration (i = 0, j = 0, S = {0, 1, 2, 3}):
• j = (j + S[ i ] + K[ i ]) = (0 + 0 + 1) = 1 (1mod 4)
• Swap S[ i ] with S[ j ]: Swap S[0] with S[1]: S = {1, 0, 2, 3}
• Second Iteration (i = 1, j = 1, S = {1, 0, 2, 3}):
• j = (j + S[ i ] + K[ i ]) = (1 + 0 + 7) = 0 (8mod 4)
• Swap S[ i ] with S[ j ]: S = {0, 1, 2, 3}
• K = {1, 7, 1, 7}
71
KSA
Third Iteration (i = 2, j = 0, S = {0, 1, 2, 3}):
j = (j + S[ i ] + K[ i ]) = (0 + 2 + 1) = 3 (3mod 4)
Swap S[ i ] with S[ j ]: S = {0, 1, 3, 2}
Fourth Iteration (i = 3, j = 3, S = {0, 1, 3, 2}):
j = (j + S[ i ] + K[ i ]) = (3 + 2 + 7) = 0 (12 mod 4)
Swap S[ i ] with S[ j ]: S = {2, 1, 3, 0}
K = {1, 7, 1, 7}
72
PRGA (Pseudo Random Generation 
algorithm)
• Reset i = j = 0, Recall S = {2, 1, 3, 0}
• i = i + 1 = 1 (1 mod 4)
• j = j + S[ i ] = 0 + 1 = 1 (1 mod 4)
• Swap S[ i ] and S[ j ]: S = {2, 1, 3, 0}
• t= (S[i] + S[j]) mod 4 = 1+1=2 (2 mod 4)
• Output k = S[t] = S[2] = 3
73
The RC4 Algorithm
• Does not use IV (nonce)
• Same key on the same plaintext will 
result in the same cypher
• Weakness in the random number 
generator
• WEP was hacked in 2007
74
Risks in using stream ciphers
“Two time pad” is insecure:
C1  m1  PRG(k)
C2  m2  PRG(k)
Eavesdropper does:
C1  C2        m1  m2 
Enough redundant information in English that:
m1  m2  m1 ,  m2
Risks in using stream ciphers
• Short Cycle Length key-streams 
generated by pseudorandom generators 
are cyclic. True random are 
unbreakable.
• Correlation Attack statistical analyses 
where parts of the contents of the two 
messages could be identified as equal 
leads to the key, or parts of the key.
76
Risks in using stream ciphers
• Substitution Attack type of man-in-the-
middle attack: In structure messages 
specific part my be substituted  cause 
confusion or misbehavior of the system 
even if the information is protected by a 
strong stream cipher.
• Reused-Key Attack Attack known from 
Wired Equivalent Privacy (WEP) : Example: 
long term key plus 24 bits changing as IV: 
Chance of finding reused key is high: 
Breaking the system in short time is likely.
77
78
79
80
81
82
83
84
85
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\intro\Cryptography\CompNetSec2.Cryptographic-Tools-Final.pptx </DOCNO>
<F P=104> Security </F>
<TEXT>
Computer & Information Security (372-1-460-1)


Cryptographic Tools
Dept. of Software and Information Systems Engineering, Ben-Gurion University

Prof. Yuval Elovici, Dr. Asaf Shabtai, Dr. Mordechai Guri
{elovici, shabtaia}@bgu.ac.il, gurim@post.bgu.ac.il
 
Spring, 2019

2
Cryptography
Is
A powerful tool for protecting information
The basis for many security mechanisms
Mostly based on Math, logics and Statistics

Is not
The solution to all security problems
Reliable unless implemented properly
Reliable unless used properly
2

3


קריפטוגרפיה עוזרת לנו להשיג לא מעט מהכלים שעליהם דיברנו במצגת הקודמת. זה
אחד מהכלים של אבטחת מידע. זה לא פתרון להכל 
וצריך לדעת איך ליישם את זה ולהשתמש בזה כדי להשיג שירות בצורה הטובה ביותר

2
Use cases
UC1: Secure communication

UC2: Protect files via encryption

UC3: Secure cloud computing

UC4: Blockchain (bitcoin) 

3

4
Cryptography techniques - history
Manual
Mechanical
Electro-mechanical
Electronic
Quantum cryptography 
(base on physical rules, uncertainty 
theorem etc.)
4

5
4


Cryptography - goals
Confidentiality
Integrity
Authenticity
Non-repudiation
Access control
Make attacks more difficult
5

6
5


Definitions
Cryptology
Cryptography (Kryptos = hidden, Graphia = writing)
Cryptanalysis
Input: Plaintext
Cryptosystem
Algorithm
Key/Key space
Output: Ciphertext

6

7
6


Auguste Kerckhoffs (1835)
"The system should be, if not theoretically unbreakable, unbreakable in practice"

Kerckhoffs principle: a cryptosystem should be secure even if everything about the system, except the secret key, is public knowledge.
7

8

חוקר בתחום הקריפטוגרפיה , הולנדי , קירחוף . 

הוא קבע חוקים , עיקרונות מנחים בקריפטוגרפיה. הוא קבע 6 עקרונות ואנו נציג שניים מהם:
-   אחד הדברים שנדרוש ממערכת ההצפנה , גם אם לא הצלחנו להוכיח שהיא בלתי פריצה נוכל להראות מעשית שהיא לא פריצה , מעשית הכוונה שיקח לתוקף זמן לא סביר לפרוץ אותה.
-המערכת צריכה להיות בנויה בצורה כזאת שהדבר היחיד שהוא לא גלוי זה המפתח , צריך להניח שכל אחד יודע איך המערכת עובדת , הדבר היחיד ששמור כסוד זה המפתח

7
Cryptosystems’ Main Categories
8
Substitution	Transposition	One time pad	Symmetric
(Single Key)	Asymmetric
(Two Keys)
(PKE)
Mono alphabetic
(Ceaser Cipher)	Scytale Rod	Vernum Cipher	Block Cipher
(DES, Triple DES, AES, RC5, RC6)	RSA, 
Diffie – Helman
DSS
ECC
Poly alphabetic
(Vigenere cipher)

 	Basic Transposition
		Stream Cipher
(RC4)	


9

סיכום של מנגנוני הצפנה לפי קטגוריות
8
Basic cryptosystems - Substitution
Caesar cipher
Mono-alphabetic cipher
key = the offset
Simple to break
9

10
9

יש מספר צורות בהם נוכל להשיג הצפנה, הטכניקה הראשונה היא החלפה. הדוגמא הראשונה היא ידנית. 

מה שרואים כאן , המעגל החיצוני הוא סט האותיות והמעגל הפנימי הוא מפתח , 
נסובב את המעגל הפנימי ומציבים אות מסוימת מול אות מסוימת באלף-בית ולמעשה זו תהיה האות המוחלפת. 
המפתח כאן הוא התאמה בין אות אחת לשנייה.


Basic cryptosystems - Substitution
Vigenere cipher (1586) – polyalphabetic cipher

Key = boy (X axis)
Plaintext = hello (Y axis)
Cipher = isjmc

More complicated to 
break
The frequency of the 
letters appears in the 
cipher is different
10

11
10

In order to encrypt the word “Hello” with the Key “Boy”
Go to column “B” – and find the row in which we find “H” on the axis – the mutual letter is “i” therefore we take it as the first one =  “i”
Go to column “O” – and find the row in which we find “E” on the axis– the mutual letter is “S” therefore we take it as the second one = “s”
We keep on it till we finish – in case that they key is shorter than the plaintext we duplicate the key’s letters on the same appearance order.

In Oder to Decrypt the Cipher “isjmc” with the Key “Boy”
Go to column “B” – and find the row in which we find “i” inside the table – the letter on the axis is “H” therefore we take it as the first one =  “H”
Go to column “O” – and find the row in which we find “s” inside the table – the mutual letter is “S” therefore we take it as the second one = “E”
And so on.


Monoalphabetic Substitution
So 26! ~= 4 x 1026 possible mappings

Testing 106/sec would take 1013 years

Is it secure?

All natural languages have statistical properties (most common letters, digrams, trigrams, word endings, doubled letters, words)


11

12

אם נבדוק את כל המפתחות האפשריים ( brut force ) זה יצריך זמן רב. אולם זה לא אופטימלי , 
יש סטטיסטיקות שמייחדות את השפה , 
אם למשל נצפין בשפה האנגלית נדע אילו אותיות ייותר שכיחות , סיומות וכו'. חוקי שפה.

Letter Frequency
Letter	%	Letter	%
E	13.0	A	7.3
T	9.3	S	6.3
N	7.8	D	4.4
R	7.7	H	3.5
I	7.4	L	3.5
O	7.4	C	3.0
12

13


Frequency of Usage
th 
he 
at 
st 
an 
in 
ea 
nd 
er 
en 
re 
nt 
to 
es 
on 
ed 
ti

the 
and 
tha 
hat 
ent 
ion 
for 
tio 
has 
edt 
tis 
ers 
res 
ter 
con 
ing 
men 

ll 
tt 
ss 
ee 
pp 
oo 
rr 
ff 
cc 
dd 
nn

Digrams
Trigrams
Doubles
e 
t 
s 
d 
n 
r 
y

Endings
Words
the 
of 
are 
I 
and 
you 
a 
can 
to 
he 
her 
that 
in 
was 
is 
has 
it 
him 
his
13

14


Decrypting a Substitution Cipher
Count relative frequency of letters, digrams, trigrams, endings, doubles, and words in the ciphertext

If you have enough encrypted text, it can be analyzed and broken by high-speed computers

But must have a body of encrypted text of sufficient size to permit analysis
14

15

המידע הסטטיסטי מאפשר לנו לקצר את פרק הזמן שבו לוקח לפענח את ההצפנה , הצפנות מהסוג הזה ניתן לפרוץ מאוד מהר. 
זה דורש ידע מקדים על מה אנחנו מצפינים , אם יודעים שמצפינים טקסט באנגלית אז נדע להוציא את השכיחויות משם וכל הסטטיסטיקות. 
מצד שני אם לא יודעים באיזה שפה זה הוצפן, זה יהיה יותר קשה. 

Transposition Ciphers
Repeated letters in the plaintext results in repeated letters in the ciphertext

Need to break the repetition relationship between letters in the plaintext and the cipher

 transposition cipher
15

16

החלפת מקום של אותיות.
Basic cryptosystems - Transposition
Scytale Rod (Sparta 400BC)

The ancient Greeks, and the Spartans used this cipher during wars.

Key = Both sender and receiver use rod with the same diameter.

The plaintext and the cypher were written on the same leather.



16

17
16


Basic cryptosystems - Transposition
17

18
17

בוחרים מפתח שהוא רצף תווים , לדוגמא MEGABUCK

כותבים את הטקסט לפי האורך של המפתח. 
בשורות לאורכו של המפתח.

איך מתבצעת ההצפנה? קובעים את סדר העמודות לפי סדר האלף-בית . 
לוקחים את העמודה של  a ורושמים את כל האותיות שמרכיבות את העמודה(לפי סדרך הa b c )

איך מתבצע הפיענוח?
למקבל יש גם את המפתח – והוא שופך את ה CHIPHER לפי סדר ה א' ב' ואז בסוך קוראים שורות שורות את הצופן המפוענח.

One-Time Pad
Vernam cipher (Gilbert Vernam), 1917
Mathematically unbreakable – 
has a property termed perfect secrecy;
ciphertext gives absolutely no additional information about the plaintext
Generated randomly
Same length as the plaintext
Never reused
18

19
18

הצפנה שהוכחה בצורה מתמטית שלא ניתן לפרוץ אותה , 
מתייחסים אליה כאל perfect cypher , המשמעות היא שאם יש cypher text מסוים הוא לא יתן לי שום מידע על הplain text .

המשמעות של ה plain text היא , שהמפתח מיוצר בצורה רנדומאלית , שני האלמנטים שנותנים לו את היכולת להוכיח שהוא בלתי פריץ :
- אורך המפתח הוא באורך הטקסט
-לא משתמשים באותו מפתח פעמיים

One-Time Pad
key=‘cat’= 01100011 01100001 01110100
P=‘dog’=
‘d’=10010=011001002
‘o’=11110=011011112
‘g’=10310=011001112
Cipher=
01100100 01100100 01100111 

00000111 00000101 00010011
19


20


One-Time Pad
Choose a random bit string as a key
Convert plaintext into bitstring
Compute exclusive-or of the two strings
Ciphertext contains no redundancy information because every combination is equally likely
Key must be at least as long as message- overhead
20

21


One-Time Pad
Challenges:
Key can not be memorized (too long)
Difficulties to create natural Random
Large over head
Why it works?


21


22


Secure cryptosystem
Problems
Statistical patterns
Redundancies
Key smaller than plaintext
Key reused
Solutions
substitutions
Transposition
Compression
Expansion
Padding
Key mixing
Initialization vector (IV)
22

23
22


Symmetric Encryption
The universal technique for providing confidentiality for data at rest/motion

Also referred to as conventional encryption or single-key encryption

Two security requirements:
Need a strong encryption algorithm
Sender and receiver must agree on the secret key in a secure fashion (handshake) and must keep the key secured.
23

24
23

The universal technique for providing confidentiality for transmitted or stored data is symmetric encryption.

Symmetric encryption, also referred to as conventional encryption or single-key encryption, was the only type of encryption in use prior to the introduction of public-key encryption in the late 1970s. 
Countless individuals and groups, from Julius Caesar to the German U-boat force to present-day diplomatic, military, and commercial users, have used symmetric encryption for secret communication.
It remains the more widely used of the two types of encryption.

There are two requirements for secure use of symmetric encryption:

1. We need a strong encryption algorithm. At a minimum, we would like the
algorithm to be such that an opponent who knows the algorithm and has access to one or more ciphertexts would be unable to decipher the ciphertext
or figure out the key. This requirement is usually stated in a stronger form:
The opponent should be unable to decrypt ciphertext or discover the key even if he or she is in possession of a number of ciphertexts together with the plaintext that produced each ciphertext.

2. Sender and receiver must have obtained copies of the secret key in a secure
fashion and must keep the key secure. If someone can discover the key and knows the algorithm, all communication using this key is readable.
Symmetric Encryption [43]
24

25
24

A symmetric encryption scheme has five ingredients:

• Plaintext: This is the original message or data that is fed into the algorithm as input.

• Encryption algorithm: The encryption algorithm performs various substitutions and transformations on the plaintext.

• Secret key: The secret key is also input to the encryption algorithm. The exact substitutions and transformations performed by the algorithm depend on the key.

• Ciphertext: This is the scrambled message produced as output. It depends on the plaintext and the secret key. For a given message, two different keys will produce two different ciphertexts.

• Decryption algorithm: This is essentially the encryption algorithm run in reverse. It takes the ciphertext and the secret key and produces the original plaintext.
Symmetric Encryption
Two classes

Block (RC5, RC6, Blowfish…)

Stream (RC4)
25

26
25


Cryptanalytic Attacks
Rely on:
nature of the algorithm
some knowledge of the general characteristics of the plaintext
some sample plaintext-ciphertext pairs
Exploits the 
characteristics of the algorithm to attempt to deduce a specific plaintext or the key being used
If successful 
all future and past messages encrypted with that key are compromised
26

27
26


Brute-Force Attack
Try all possible keys on some ciphertext

Try until an intelligible translation into plaintext is obtained

On average half of all possible keys must be tried to achieve success
27

28
27


Average Time Required for Exhaustive Key Search

28
Assuming the decryption takes 
1 key in 1 micro-second
1M key in 1 micro second


29
28

The table shows how much time is involved for various key sizes. 
With microprocessors, it may be possible to achieve processing rates many orders of magnitude greater.
The final column considers the results for a system that can process 1 million keys per microsecond.
At this performance level, a 56-bit key is no longer computationally secure.

Comparison of three Popular Symmetric Encryption Algorithms
29
Block cipher - most commonly used in symmetric encryption
Input = Fixed-size blocks
Output = Fixed-size equals to the input

30
29

The most commonly used symmetric encryption algorithms are block ciphers.
A block cipher processes the plaintext input in fixed-size blocks and produces a block of ciphertext of equal size for each plaintext block.
The algorithm processes longer plaintext amounts as a series of fixed-size blocks.
The most important symmetric algorithms, all of which are block ciphers, are the Data Encryption Standard (DES), triple DES, and the Advanced Encryption Standard (AES).
Data Encryption Standard (DES)
Adopted by NIST in 1977
Uses 
64 bit plaintext block 
56 bit key to 
produce a 64 bit ciphertext block
DES is the most studied encryption algorithm in existence
Electronic Frontier Foundation (EFF) announced in July 1998 that it had broken a DES encryption using the “DES cracker” (250K$ hardware)
30

31
30

The most widely used encryption scheme is based on the Data Encryption Standard (DES) adopted in 1977 by the National Bureau of Standards, now the National Institute of Standards and Technology (NIST), as Federal Information Processing Standard 46 (FIPS PUB 46).
The algorithm itself is referred to as the Data Encryption Algorithm (DEA).
DES takes a plaintext block of 64 bits and a key of 56 bits, to produce a ciphertext block of 64 bits.

Concerns about the strength of DES fall into two categories: concerns about the algorithm itself and concerns about the use of a 56-bit key.
The first concern refers to the possibility that cryptanalysis is possible by exploiting the characteristics of the DES algorithm.
Over the years, there have been numerous attempts to find and exploit weaknesses in the algorithm, making DES the most-studied encryption
algorithm in existence. Despite numerous approaches, no one has so far reported a fatal weakness in DES.

A more serious concern is key length. With a key length of 56 bits, there are 256 possible keys, which is approximately 7.2 x 1016 keys. 
Thus, on the face of it, a brute-force attack appears impractical.
Assuming that, on average, half the key space has to be searched, a single machine performing one DES encryption per micro second would take more than a thousand years to break the cipher.

However, the assumption of one encryption per microsecond is overly conservative.
DES finally and definitively proved insecure in July 1998, when the Electronic Frontier Foundation (EFF) announced that it had broken a DES encryption
using a special-purpose “DES cracker” machine that was built for less than $250,000. 
The attack took less than three days. The EFF has published a detailed description of the machine, enabling others to build their own cracker [EFF98].
And, of course, hardware prices will continue to drop as speeds increase, making DES virtually worthless.

It is important to note that there is more to a key-search attack than simply running through all possible keys.
Unless known plaintext is provided, the analyst must be able to recognize plaintext as plaintext.
If the message is just plain text in English, then the result pops out easily, although the task of recognizing English would have to be automated. 
If the text message has been compressed before encryption, then recognition is more difficult. 
And if the message is some more general type of data, such as a numerical file, and this has been compressed, the problem becomes even more difficult to automate. 
Thus, to supplement the brute-force approach, some degree of knowledge about the expected plaintext is needed, and some means of automatically distinguishing plaintext from garble is also needed. The EFF approach addresses this issue as well and introduces some automated techniques that would be effective in many contexts.

A final point: If the only form of attack that could be made on an encryption algorithm is brute force, then the way to counter such attacks is obvious: Use longer
keys. 
To get some idea of the size of key required, let us use the EFF cracker as a basis for our estimates. The EFF cracker was a prototype and we can assume that
with today’s technology, a faster machine is cost effective. If we assume that a cracker can perform 1 million decryptions per μs, which is the rate used in Table 2.1, then a DES code would take about 10 hours to crack. This is a speed-up of approximately a factor of 7 compared to the EFF result
How does DES work? (Feistel Network) [597]
Plaintext is a block of length 2w bits

K is the Key (seed) from which the subkeys ki are being generated using a generation algorithm.

Plaintext is divided into two halves of length w: L0 and R0.

F is a function that combines between Ri and Ki 

N –rounds, and the steps are:


31

32
31


Triple DES (3DES)
Repeats basic DES algorithm three times using either two or three unique keys
First standardized for use in financial applications in ANSI standard X9.17
Attractions:
168-bit key length overcomes the vulnerability to brute-force attack of DES
underlying encryption algorithm is the same as in DES
Drawbacks:
algorithm is slow in software
uses a 64-bit block size
32

33
32

The life of DES was extended by the use of triple DES (3DES), which involves repeating the basic DES algorithm three times, using either two
or three unique keys, for a key size of 112 or 168 bits. Triple DES (3DES) was first standardized for use in financial applications in ANSI standard X9.17 in 1985.
3DES was incorporated as part of the Data Encryption Standard in 1999, with the publication of FIPS PUB 46-3.

3DES has two attractions that assure its widespread use over the next few years.
First, with its 168-bit key length, it overcomes the vulnerability to brute-force attack of DES.
Second, the underlying encryption algorithm in 3DES is the same as in DES. 
This algorithm has been subjected to more scrutiny than any other encryption algorithm over a longer period of time, and no effective cryptanalytic attack
based on the algorithm rather than brute force has been found.
Accordingly, there is a high level of confidence that 3DES is very resistant to cryptanalysis.
If security were the only consideration, then 3DES would be an appropriate choice for a standardized encryption algorithm for decades to come.

The principal drawback of 3DES is that the algorithm is relatively sluggish in software.
The original DES was designed for mid-1970s hardware implementation and does not produce efficient software code. 3DES, which requires three times as
many calculations as DES, is correspondingly slower. A secondary drawback is that both DES and 3DES use a 64-bit block size. For reasons of both efficiency and security, a larger block size is desirable.
3DES – Scheme [630]
33

34
33

The life of DES was extended by the use of triple DES (3DES), which involves repeating the basic DES algorithm three times, using either two
or three unique keys, for a key size of 112 or 168 bits. Triple DES (3DES) was first standardized for use in financial applications in ANSI standard X9.17 in 1985.
3DES was incorporated as part of the Data Encryption Standard in 1999, with the publication of FIPS PUB 46-3.

3DES has two attractions that assure its widespread use over the next few years.
First, with its 168-bit key length, it overcomes the vulnerability to brute-force attack of DES.
Second, the underlying encryption algorithm in 3DES is the same as in DES. 
This algorithm has been subjected to more scrutiny than any other encryption algorithm over a longer period of time, and no effective cryptanalytic attack
based on the algorithm rather than brute force has been found.
Accordingly, there is a high level of confidence that 3DES is very resistant to cryptanalysis.
If security were the only consideration, then 3DES would be an appropriate choice for a standardized encryption algorithm for decades to come.

The principal drawback of 3DES is that the algorithm is relatively sluggish in software.
The original DES was designed for mid-1970s hardware implementation and does not produce efficient software code. 3DES, which requires three times as
many calculations as DES, is correspondingly slower. A secondary drawback is that both DES and 3DES use a 64-bit block size. For reasons of both efficiency and security, a larger block size is desirable.
Advanced Encryption Standard(AES)
NIST call for proposal for a new Advanced Encryption Standard (AES) in 1997
Selected Rijndeal in Nov. 2001 (also known as AES)
Advantages:
Faster than 3DES
security strength equal or better than 3DES
symmetric block cypher
Larger Blocks: 128bit blocks 
Longer keys: 128/192/256 bit key
34

35
34

Because of its drawbacks, 3DES is not a reasonable candidate for long-term use.
As a replacement, NIST in 1997 issued a call for proposals for a new Advanced Encryption Standard (AES), which should have a security strength equal to or better than 3DES and significantly improved efficiency. 
In addition to these general requirements, NIST specified that AES must be a symmetric block cipher with a block length of 128 bits and support for key
lengths of 128, 192, and 256 bits. 
Evaluation criteria included security, computational efficiency, memory requirements, hardware and software suitability, and flexibility.

In a first round of evaluation, 15 proposed algorithms were accepted. A second round narrowed the field to 5 algorithms. 
NIST completed its evaluation process and published a final standard (FIPS PUB 197) in November of 2001. 
NIST selected Rijndael as the proposed AES algorithm. 
AES is now widely available in commercial products. 
Symmetric Encryption Types
Block Cipher
Processes the input one block of elements at a time and produces an output block for each input block.
Implemented via different modes.
Stream cipher
Encrypts plaintext one byte at a time (also other units) 
Processes the input elements continuously

35

36
Modes of Operation [612]
36

37
36

A symmetric block cipher processes one block of data at a time. In the case of DES
and 3DES, the block length is 64 bits. For longer amounts of plaintext, it is necessary
to break the plaintext into 64-bit blocks (padding the last block if necessary).
To apply a block cipher in a variety of applications, five modes of operation have been defined by NIST (Special Publication 800-38A). The five modes are intended
to cover virtually all the possible applications of encryption for which a block cipher
could be used. These modes are intended for use with any symmetric block cipher,
including triple DES and AES. The modes are summarized in Table 20.4 , and the
most important are described briefly in the remainder of this section.

Block Cipher Encryption
Processes the input one block of elements at a time and produces an output block for each input block
Plaintext is handled using Electronic Code Book (ECB)  
For lengthy messages ECB mode is not secure especially if:
it is known that messages starts with certain predefined fields
keys are being reused
37

38
37

The ECB mode. A plaintext of length nb is divided into n b-bit blocks (P1, P2,c,Pn).
Each block is encrypted using the same algorithm and the same encryption key, to
produce a sequence of n b-bit blocks of ciphertext (C1, C2,c,Cn).
Practical Security Issues
Typically symmetric encryption is applied to a unit of data larger than a single 64-bit or 128-bit block

Electronic codebook (ECB) mode is the simplest approach to multiple-block encryption
each block of plaintext is encrypted using the same key
cryptanalysts may be able to exploit regularities in the plaintext

Modes of operation
Alternative techniques developed to increase the security of symmetric block encryption for large sequences
Overcomes the weaknesses of ECB
To increase security for lengthy messages we use Stream Cipher
38

39

Typically, symmetric encryption is applied to a unit of data larger than a single 64-bit or 128-bit block. E-mail messages, network
packets, database records, and other plaintext sources must be broken up into a series of fixed-length block for encryption by a symmetric block cipher. The simplest approach to multiple-block encryption is known as electronic codebook (ECB)
mode, in which plaintext is handled b bits at a time and each block of plaintext is encrypted using the same key. Typically b  64 or b  128

For lengthy messages, the ECB mode may not be secure. A cryptanalyst may be able to exploit regularities in the plaintext to ease the task of decryption. For
example, if it is known that the message always starts out with certain predefined fields, then the cryptanalyst may have a number of known plaintext-ciphertext pairs to work with.

To increase the security of symmetric block encryption for large sequences of data, a number of alternative techniques have been developed, called modes of
operation. These modes overcome the weaknesses of ECB; each mode has its own particular advantages.
38
Electronic Codebook (ECB)
Simplest mode

Plaintext is handled b bits at a time and each block is encrypted using the same key

“codebook” because have unique ciphertext value for each plaintext block


39

40
39

The simplest way to proceed is what is known as electronic codebook (ECB) mode,
in which plaintext is handled b bits at a time and each block of plaintext is encrypted
using the same key ( Figure 2.3a ). The term codebook is used because, for a given
key, there is a unique ciphertext for every b -bit block of plaintext. Therefore, one
can imagine a gigantic codebook in which there is an entry for every possible b -bit
plaintext pattern showing its corresponding ciphertext.

With ECB, if the same b -bit block of plaintext appears more than once in
the message, it always produces the same ciphertext. Because of this, for lengthy
messages, the ECB mode may not be secure. If the message is highly structured,
it may be possible for a cryptanalyst to exploit these regularities. For example, if
it is known that the message always starts out with certain predefined fields, then
the cryptanalyst may have a number of known plaintext-ciphertext pairs to work
with. If the message has repetitive elements, with a period of repetition a multiple
of b bits, then these elements can be identified by the analyst. This may help in the
analysis or may provide an opportunity for substituting or rearranging blocks.

To overcome the security deficiencies of ECB, we would like a technique in
which the same plaintext block, if repeated, produces different ciphertext blocks.

Electronic Codebook (ECB)
40

41
ECB Analysis
Security:
EFB is not secure, since repeated plaintext is seen in repeated ciphertext
A typical example of this weakness is by encoding a bitmap image – as can be noticed, ECB mode cannot blur the plaintext.


41

42
ECB Analysis
Speed: Each plaintext/ciphertext block is encrypted/decrypted separately. Thus, it is possible to encrypt and decrypt by using many threads simultaneously.
Effect of an error: Each plaintext/ ciphertext block is encrypted/decrypted separately. Thus, an error in one block does not affect other blocks.
Reoccurrences of key:  the same key are used for all encryption and decryption blocks. 

42

43
Cipher Block Chaining (CBC)
43

44
43

In the cipher block chaining (CBC) mode (Figure 20.6), the input to the encryption algorithm is the XOR of the current plaintext block and the preceding ciphertext block; the same key is used for each block. In effect, we have chained together the processing of the sequence of plaintext blocks. The input to the encryption function for each plaintext block bears no fixed relationship to the plaintext block. Therefore, repeating patterns of b bits are not exposed. CBC is widely used in security applications.

For decryption, each cipher block is passed through the decryption algorithm. The result is XORed with the preceding ciphertext block to produce the plaintext block. To see that this works, we can write:
Cj = E(K, [Cj–1  Pj])
where E[K, X] is the encryption of plaintext X using key K, and  is the exclusive-OR operation.
To produce the first block of ciphertext, an initialization vector (IV) is XORed with the first block of plaintext. On decryption, the IV is XORed with the output of the decryption algorithm to recover the first block of plaintext.

The IV must be known to both the sender and receiver. For maximum security, the IV should be protected as well as the key. This could be done by sending the IV using ECB encryption. One reason for protecting the IV is as follows: If an opponent is able to fool the receiver into using a different value for IV, then the opponent is able to invert selected bits in the first block of plaintext.
CBC Analysis
Security: the CBC mode is secure, repeated plaintext will not be seen in repeated ciphertext.
Reoccurrences of key:  the same key are used for all encryption and decryption blocks.
Speed: 
Encryption: Each ciphertext block depends on the previous one. Thus, encryption in CBC mode can only be performed by using one thread. 
Decryption: Because the receiver knows all the ciphertext blocks just after obtaining the encrypted message, he can decrypt the message using many threads simultaneously.
44

45
CBC Analysis
Effect of an error: 
Encryption: If one bit of a plaintext message is damaged (for example because of some earlier transmission error), all subsequent ciphertext blocks will be damaged and it will be never possible to decrypt the ciphertext received from this plaintext. 
Decryption: If one ciphertext bit is damaged, only two received plaintext blocks will be damaged. It might be possible to recover the data.

45

46
Cipher Feedback (CFB)
46

47
46

It is possible to convert any block cipher into a stream cipher by using the cipher feedback (CFB) mode. A stream cipher eliminates the need to pad a message to be an integral number of blocks. It also can operate in real time. Thus, if a character stream is being transmitted, each character can be encrypted and transmitted immediately using a character-oriented stream cipher. One desirable property of a stream cipher is that the ciphertext be of the same length as the plaintext. 

Figure 20.7 depicts the CFB scheme. In the figure, it is assumed that the unit of transmission is s bits; a common value is s = 8. As with CBC, the units of plaintext are chained together.
For encryption, the input to the encryption function is a b-bit shift register that is initially set to some initialization vector (IV). The leftmost (most significant) s bits of the output of the encryption function are XORed with the first unit of plaintext P1 to produce the first unit of ciphertext C1, which is then transmitted. In addition, the contents of the shift register are shifted left by s bits and C1 is placed in the rightmost (least significant) s bits of the shift register. This process continues until all plaintext units have been encrypted. Will have:
C1 = P1  Ss[E(K, IV)]
For decryption, the same scheme is used, except that the received ciphertext unit is XORed with the output of the encryption function to produce the plaintext unit. Note that it is the encryption function that is used, not the decryption function. This is easily explained. Let Ss(X) be defined as the most significant s bits of X. Then have
P1 = C1  Ss[E(K, IV)]
CFB Analysis
Security: The CFB mode is similar to CBC. The main difference is that one should encrypt ciphertext data from the previous round and then add the output to the plaintext bits. It does not affect the cipher security but it results in the fact that the same encryption algorithm should be used during the decryption process.
47

48
CFB Analysis
Reoccurrences of key:  the same key are used for all encryption and decryption blocks.
Speed: 
Encryption: Encryption in CFB mode can be performed only by using one thread.
Decryption: As in CBC mode, one can decrypt ciphertext blocks using many threads simultaneously. 
48

49
CFB Analysis
Effect of an error: 
Encryption: If one bit of a plaintext message is damaged, the corresponding ciphertext block and all subsequent ciphertext blocks will be damaged.
Decryption: If one ciphertext bit is damaged, only two received plaintext blocks will be damaged.
49

50
Output Feedback (OFB)
50


51
OFB Analysis
Security: The biggest drawback of OFB is that the repetition of encrypting the initialization vector may produce the same state that has occurred before. It is an unlikely situation but in such a case the plaintext will start to be encrypted by the same data as previously.
Reoccurrences of key:  Algorithms that work in the OFB mode create keystream bits that are used for encryption subsequent data blocks. In this regard, the way of working of the block cipher becomes similar to the way of working of a typical stream cipher.
51

52
OFB Analysis
Speed: Because of the continuous creation of keystream bits, both encryption and decryption can be performed using only one thread at a time. Similarly, as in the CFB mode, both data encryption and decryption uses the same cipher encryption algorithm.
Effect of an error: If one bit of a plaintext or ciphertext message is damaged (for example because of a transmission error), only one corresponding ciphertext or respectively plaintext bit is damaged as well. It is possible to use various correction algorithms to restore the previous value of damaged parts of the received message.
52

53
Counter (CTR)
53

54
53

Although interest in the counter mode (CTR) has increased recently, with applications to ATM network security and IPSec), this mode was proposed early

Figure 20.8 depicts the CTR mode. A counter, equal to the plaintext block size is used. The only requirement stated in SP 800-38A is that the counter value must be different for each plaintext  block that is encrypted. Typically, the counter is initialized to some value and then incremented by 1 for each subsequent block (modulo 2b, where b is the block size). For encryption, the counter is encrypted and then XORed with the plaintext block to produce the ciphertext block; there is no chaining. For decryption, the same sequence of counter values is used, with each encrypted counter XORed with a ciphertext block to recover the corresponding plaintext block.

Some advantages of CTR mode are :

• Hardware efficiency: CTR mode can be done in parallel on multiple blocks of plaintext or ciphertext. 

• Software efficiency: have opportunities for parallel execution in CTR mode.

• Preprocessing: can be used to prepare the output of the encryption boxes that feed into the XOR functions in Figure 20.8. 

• Random access: The ith block of plaintext or ciphertext can be processed in random-access fashion. 

• Provable security: CTR is at least as secure as the other mode.

• Simplicity: CTR mode oly needs the implementation of the encryption algorithm.
CTR Analysis
Security: In this mode, subsequent values of an increasing counter are added to a nonce value (the nonce means a number that is unique: number used once) and the results are encrypted as usual. The nonce plays the same role as initialization vectors.
Reoccurrences of key: Using the CTR mode makes block cipher way of working similar to a stream cipher. As in the OFB mode, keystream bits are created regardless of content of encrypting data blocks. 

54

55
CTR Analysis
Speed: It is one of the most popular block ciphers modes of operation. Both encryption and decryption can be performed using many threads at the same time.
Effect of an error: If one bit of a plaintext or ciphertext message is damaged, only one corresponding output bit is damaged as well. Thus, it is possible to use various correction algorithms to restore the previous value of damaged parts of received messages.

55

56
Stream Cipher Encryption – RC4
Encrypts plaintext one byte at a time (also other units) 
Produces output one element at a time
Processes the input elements continuously
56

57
56

Diagram of stream cipher structure. In this structure a key is input to a pseudorandom bit generator that produces a stream of 8-bit numbers that are apparently random. A pseudorandom stream is one that is unpredictable without knowledge of the input key and which has an apparently random character.
The output of the generator, called a keystream, is combined one byte at a time with the plaintext stream using the bitwise exclusive-OR (XOR) operation.



Stream Cipher Encryption – RC4
Almost always faster 
Pseudorandom stream is one that is unpredictable without knowledge of the input key
Keys cannot be reused
Generate pseudo random keys 
(key Stream)
57

58
57

Diagram of stream cipher structure. In this structure a key is input to a pseudorandom bit generator that produces a stream of 8-bit numbers that are apparently random. A pseudorandom stream is one that is unpredictable without knowledge of the input key and which has an apparently random character.
The output of the generator, called a keystream, is combined one byte at a time with the plaintext stream using the bitwise exclusive-OR (XOR) operation.



Message Confidentiality
 
VS 

Message Authentication
58

59
58


Message Authentication
Protects against active attacks
Verifies that the received message is authentic
content have not been altered
from authentic source
timely and in correct sequence
can use conventional (Symmetric) encryption
Only sender and receiver share a key
59

60
59


התקפה פאסיבית היא כזו של האזנה וציתות למסרים ומידע שמועבר.

כאן נרצה גם להגן מפני התקפות אקטיביות,

הרעיון הוא אימות הודעות ותכנים, המטרות לאמת ש:

המידע לא שונה בדרך
המידע הוא אכן מהמקור שאנחנו מצפים לקבל ממנו
המידע הגיע בזמן (ולא אחרי שנה) ובסדר הנכון

Encryption protects against passive attack (eavesdropping).
A different requirement is to protect against active attack (falsification of data and transactions). 
Protection against such attacks is known as message or data authentication.

A message, file, document, or other collection of data is said to be authentic when it is genuine and came from its alleged source. 
Message or data authentication is a procedure that allows communicating parties to verify that received or stored messages are authentic. 
The two important aspects are to verify that the contents of the message have not been altered and that the source is authentic. 
We may also wish to verify a message’s timeliness (it has not been artificially delayed and replayed) and sequence relative to other messages flowing between two parties. All of these concerns come under the category of data integrity.

It would seem possible to perform authentication simply by the use of symmetric encryption. 
If we assume that only the sender and receiver share a key (which is as it should be), then only the genuine sender would be able to encrypt a message
successfully for the other participant, provided the receiver can recognize a valid message.
Furthermore, if the message includes an error-detection code and a sequence number, the receiver is assured that no alterations have been made and that sequencing is proper. 
If the message also includes a timestamp, the receiver is assured that the message has not been delayed beyond that normally expected for network transit.

In fact, symmetric encryption alone is not a suitable tool for data authentication.
To give one simple example, in the ECB mode of encryption, if an attacker reorders the blocks of ciphertext, then each block will still decrypt successfully.
However, the reordering may alter the meaning of the overall data sequence.
Although sequence numbers may be used at some level (e.g., each IP packet), it is typically not the case that a separate sequence number will be associated with each b-bit block of plaintext. Thus, block reordering is a threat.
Message Authentication without Encryption
Symmetric Encryption only for message authentication is exposed to Block reorder attack (e.g in ECB)
Thus using a generated tag and appending it to each message protect from this attack as well:
Message Authentication Code
One Way Hash Function
60

61
60


התקפה פאסיבית היא כזו של האזנה וציתות למסרים ומידע שמועבר.

כאן נרצה גם להגן מפני התקפות אקטיביות,

הרעיון הוא אימות הודעות ותכנים, המטרות לאמת ש:

המידע לא שונה בדרך
המידע הוא אכן מהמקור שאנחנו מצפים לקבל ממנו
המידע הגיע בזמן (ולא אחרי שנה) ובסדר הנכון

Encryption protects against passive attack (eavesdropping).
A different requirement is to protect against active attack (falsification of data and transactions). 
Protection against such attacks is known as message or data authentication.

A message, file, document, or other collection of data is said to be authentic when it is genuine and came from its alleged source. 
Message or data authentication is a procedure that allows communicating parties to verify that received or stored messages are authentic. 
The two important aspects are to verify that the contents of the message have not been altered and that the source is authentic. 
We may also wish to verify a message’s timeliness (it has not been artificially delayed and replayed) and sequence relative to other messages flowing between two parties. All of these concerns come under the category of data integrity.

It would seem possible to perform authentication simply by the use of symmetric encryption. 
If we assume that only the sender and receiver share a key (which is as it should be), then only the genuine sender would be able to encrypt a message
successfully for the other participant, provided the receiver can recognize a valid message.
Furthermore, if the message includes an error-detection code and a sequence number, the receiver is assured that no alterations have been made and that sequencing is proper. 
If the message also includes a timestamp, the receiver is assured that the message has not been delayed beyond that normally expected for network transit.

In fact, symmetric encryption alone is not a suitable tool for data authentication.
To give one simple example, in the ECB mode of encryption, if an attacker reorders the blocks of ciphertext, then each block will still decrypt successfully.
However, the reordering may alter the meaning of the overall data sequence.
Although sequence numbers may be used at some level (e.g., each IP packet), it is typically not the case that a separate sequence number will be associated with each b-bit block of plaintext. Thus, block reordering is a threat.
Message Authentication Codes (MAC)
61
MACM = F(KAB,M)

62
61


למעשה היות והשולח והמקבל של המסרים המוצפנים חולקים את אותו מפתח סימטרי אזי ניתן להשתמש בסוד המשותף הזה גם כדי לאכוף אימות מסרים.

איך נעבוד כאן עם MAC?, 
נקח את ההודעה ונפעיל עליה algorithm MAC עם המפתח , 
מצרפים להודעה את הMAC ומעבירים לצד השני , 
הצד השני צריך להשוות את הMAC שהוא יוצר לMAC שהגיע עם ההודעה ואם לא זהים אז יש בעיה בהודעה. 



One authentication technique involves the use of a secret key to generate a small block of data, known as a message authentication code, that is appended to the message. 
This technique assumes that two communicating parties, say A and B, share a common secret key KAB. 
When A has a message to send to B, it calculates the message authentication code as a complex function of the message and the key: MACM  F(KAB, M). 
The message plus code are transmitted to the intended recipient. 
The recipient performs the same calculation on the received message, using the same secret key, to generate a new message authentication code. 
The received code is compared to the calculated code). 
If we assume that only the receiver and the sender know the identity of the secret key, and if the received code matches the calculated code, then

1. The receiver is assured that the message has not been altered. If an attacker alters the message but does not alter the code, then the receiver’s calculation of the code will differ from the received code. Because the attacker is assumed not to know the secret key, the attacker cannot alter the code to correspond to the alterations in the message.

2. The receiver is assured that the message is from the alleged sender. Because no one else knows the secret key, no one else could prepare a message with a proper code.

3. If the message includes a sequence number (such as is used with X.25, HDLC, and TCP), then the receiver can be assured of the proper sequence, because an attacker cannot successfully alter the sequence number.

A number of algorithms could be used to generate the code. The NIST specification, FIPS PUB 113, recommends the use of DES. DES is used to generate an
encrypted version of the message, and the last number of bits of ciphertext are used as the code. A 16- or 32-bit code is typical.

The process just described is similar to encryption. One difference is that the authentication algorithm need not be reversible, as it must for decryption. It turns
out that because of the mathematical properties of the authentication function, it is less vulnerable to being broken than encryption.
Message Authentication Codes (MAC)
Only the sender and receiver share the secret key KAB

If the sender find a match between the received MAC and his calculated code then:
Message wasn’t altered: attacker can alter the message but not the code since doesn’t have the secret key
Sender authenticity –no one else is able to produce the same MAC due to the secret key
Message on correct order  - attacker cannot alter the sequence number (X.25,HDLC, TCP) within a message
Note that MAC algorithms are not required to be reversible
62

63
62


התקפה פאסיבית היא כזו של האזנה וציתות למסרים ומידע שמועבר.

כאן נרצה גם להגן מפני התקפות אקטיביות,

הרעיון הוא אימות הודעות ותכנים, המטרות לאמת ש:

המידע לא שונה בדרך
המידע הוא אכן מהמקור שאנחנו מצפים לקבל ממנו
המידע הגיע בזמן (ולא אחרי שנה) ובסדר הנכון

Encryption protects against passive attack (eavesdropping).
A different requirement is to protect against active attack (falsification of data and transactions). 
Protection against such attacks is known as message or data authentication.

A message, file, document, or other collection of data is said to be authentic when it is genuine and came from its alleged source. 
Message or data authentication is a procedure that allows communicating parties to verify that received or stored messages are authentic. 
The two important aspects are to verify that the contents of the message have not been altered and that the source is authentic. 
We may also wish to verify a message’s timeliness (it has not been artificially delayed and replayed) and sequence relative to other messages flowing between two parties. All of these concerns come under the category of data integrity.

It would seem possible to perform authentication simply by the use of symmetric encryption. 
If we assume that only the sender and receiver share a key (which is as it should be), then only the genuine sender would be able to encrypt a message
successfully for the other participant, provided the receiver can recognize a valid message.
Furthermore, if the message includes an error-detection code and a sequence number, the receiver is assured that no alterations have been made and that sequencing is proper. 
If the message also includes a timestamp, the receiver is assured that the message has not been delayed beyond that normally expected for network transit.

In fact, symmetric encryption alone is not a suitable tool for data authentication.
To give one simple example, in the ECB mode of encryption, if an attacker reorders the blocks of ciphertext, then each block will still decrypt successfully.
However, the reordering may alter the meaning of the overall data sequence.
Although sequence numbers may be used at some level (e.g., each IP packet), it is typically not the case that a separate sequence number will be associated with each b-bit block of plaintext. Thus, block reordering is a threat.
One-Way Hash Function
63
One way since it is not reversible

M message with variable length

H – one way hash function

H does not use a secret key

H(M) – fixed message digest that is added to the original message

We add to H(M) the length of the original message in bits

Hash is more lightweight than MAC
Sender authenticity is not guaranteed



64
63


שיטה נוספת לאימות מסרים היא להשתמש בhash:
ניקח את ההודעה
נדרוש מhash שיעבוד על הודעה בכל אורך , 
מוסיפים תוספת שהיא אורך ההודעה , 
נפעיל פונקציית hash על ההודעה , 
מקבלים תוצאה שאותה מצרפים להודעה עצמה. 
מה משיגים עם פונקצייה כזו? היא לא הפיתרון הכי טוב , התוקף יוכל לשנות את כל ההודעה כולל פונקציית הhash.

ב  hashאין סוד שעובר, מניחים שכולם יודעים את פונקציית ההאש, ניתן להשתמש בו כדי לבדוק האם היו בעיות במהלך מעבר ההודעה.

An alternative to the message authentication code is the one-way hash function.
As with the message authentication code, a hash function accepts a variable-size message M as input and produces a fixed-size message digest
H(M) as output. 
Typically, the message is padded out to an integer multiple of some fixed length (e.g., 1024 bits) and the padding includes the value of the length
of the original message in bits. 
The length field is a security measure to increase the difficulty for an attacker to produce an alternative message with the same hash value.
We encrypt the digest only using the symmetric key
64
Message Authentication Using a One-Way Hash Function – HMAC
(MD2, MD4, MD5, SHA-1(160)/256/512)  [53]


65
64

Unlike the MAC, a hash function does not also take a secret key as input.
To authenticate a message, the message digest is sent with the message in such a way that the message digest is authentic.
The Figure illustrates three ways in which the message can be authenticated using a hash code. 
The message digest can be encrypted using symmetric encryption (part a); if it is assumed that only the sender and receiver share the encryption key, then authenticity is assured. 
The message digest can also be encrypted using public-key encryption (part b).
The public-key approach has two advantages: It provides a digital signature as well as message authentication; and it does not require the
distribution of keys to communicating parties.

These two approaches have an advantage over approaches that encrypt the entire message in that less computation is required. But an even more common approach is  the use of a technique that avoids encryption altogether. Several reasons
for this interest are pointed out in [TSUD92]:

• Encryption software is quite slow. Even though the amount of data to be
encrypted per message is small, there may be a steady stream of messages into
and out of a system.

• Encryption hardware costs are non-negligible. Low-cost chip implementations
of DES are available, but the cost adds up if all nodes in a network must have
this capability.

• Encryption hardware is optimized toward large data sizes. For small blocks of
data, a high proportion of the time is spent in initialization/invocation overhead.

• An encryption algorithm may be protected by a patent.

Figure 2.6c shows a technique that uses a hash function but no encryption for message authentication. 
This technique, known as a keyed hash MAC, assumes that two communicating parties, say A and B, share a common secret key K.
This secret key is incorporated into the process of generating a hash code. In the
approach illustrated in Figure 2.6c, when A has a message to send to B, it calculates
the hash function over the concatenation of the secret key and the message:
MDM = H(KMK).6 It then sends [ MMDM] to B. Because B possesses K, it can
recompute H(K7M7K) and verify MDM. Because the secret key itself is not sent, it
should not be possible for an attacker to modify an intercepted message. As long as
the secret key remains secret, it should not be possible for an attacker to generate a
false message.

Note that the secret key is used as both a prefix and a suffix to the message. If
the secret key is used as either only a prefix or only a suffix, the scheme is less secure.
This topic is discussed in Chapter 21. Chapter 21 also describes a scheme known
as HMAC, which is somewhat more complex than the approach of Figure 2.6c and
which has become the standard approach for a keyed hash MAC.
We encrypt the digest only using our private key
  - used as digital signature
  - no need for key distribution
65
Message Authentication Using a One-Way Hash Function – HMAC
(MD2, MD4, MD5, SHA-1(160)/256/512)  [53]


66
65

Unlike the MAC, a hash function does not also take a secret key as input.
To authenticate a message, the message digest is sent with the message in such a way that the message digest is authentic.
The Figure illustrates three ways in which the message can be authenticated using a hash code. 
The message digest can be encrypted using symmetric encryption (part a); if it is assumed that only the sender and receiver share the encryption key, then authenticity is assured. 
The message digest can also be encrypted using public-key encryption (part b).
The public-key approach has two advantages: It provides a digital signature as well as message authentication; and it does not require the
distribution of keys to communicating parties.

These two approaches have an advantage over approaches that encrypt the entire message in that less computation is required. But an even more common approach is  the use of a technique that avoids encryption altogether. Several reasons
for this interest are pointed out in [TSUD92]:

• Encryption software is quite slow. Even though the amount of data to be
encrypted per message is small, there may be a steady stream of messages into
and out of a system.

• Encryption hardware costs are non-negligible. Low-cost chip implementations
of DES are available, but the cost adds up if all nodes in a network must have
this capability.

• Encryption hardware is optimized toward large data sizes. For small blocks of
data, a high proportion of the time is spent in initialization/invocation overhead.

• An encryption algorithm may be protected by a patent.

Figure 2.6c shows a technique that uses a hash function but no encryption for message authentication. 
This technique, known as a keyed hash MAC, assumes that two communicating parties, say A and B, share a common secret key K.
This secret key is incorporated into the process of generating a hash code. In the
approach illustrated in Figure 2.6c, when A has a message to send to B, it calculates
the hash function over the concatenation of the secret key and the message:
MDM = H(KMK).6 It then sends [ MMDM] to B. Because B possesses K, it can
recompute H(K7M7K) and verify MDM. Because the secret key itself is not sent, it
should not be possible for an attacker to modify an intercepted message. As long as
the secret key remains secret, it should not be possible for an attacker to generate a
false message.

Note that the secret key is used as both a prefix and a suffix to the message. If
the secret key is used as either only a prefix or only a suffix, the scheme is less secure.
This topic is discussed in Chapter 21. Chapter 21 also describes a scheme known
as HMAC, which is somewhat more complex than the approach of Figure 2.6c and
which has become the standard approach for a keyed hash MAC.
We use secret value K that is agreed on the sender and receiver, the secret is not sent therefore it is difficult for an attacker to create H(m)

66
Message Authentication Using a One-Way Hash Function – HMAC
(MD2, MD4, MD5, SHA-1(160)/256/512)  [53]


67
66

Unlike the MAC, a hash function does not also take a secret key as input.
To authenticate a message, the message digest is sent with the message in such a way that the message digest is authentic.
The Figure illustrates three ways in which the message can be authenticated using a hash code. 
The message digest can be encrypted using symmetric encryption (part a); if it is assumed that only the sender and receiver share the encryption key, then authenticity is assured. 
The message digest can also be encrypted using public-key encryption (part b).
The public-key approach has two advantages: It provides a digital signature as well as message authentication; and it does not require the
distribution of keys to communicating parties.

These two approaches have an advantage over approaches that encrypt the entire message in that less computation is required. But an even more common approach is  the use of a technique that avoids encryption altogether. Several reasons
for this interest are pointed out in [TSUD92]:

• Encryption software is quite slow. Even though the amount of data to be
encrypted per message is small, there may be a steady stream of messages into
and out of a system.

• Encryption hardware costs are non-negligible. Low-cost chip implementations
of DES are available, but the cost adds up if all nodes in a network must have
this capability.

• Encryption hardware is optimized toward large data sizes. For small blocks of
data, a high proportion of the time is spent in initialization/invocation overhead.

• An encryption algorithm may be protected by a patent.

Figure 2.6c shows a technique that uses a hash function but no encryption for message authentication. 
This technique, known as a keyed hash MAC, assumes that two communicating parties, say A and B, share a common secret key K.
This secret key is incorporated into the process of generating a hash code. In the
approach illustrated in Figure 2.6c, when A has a message to send to B, it calculates
the hash function over the concatenation of the secret key and the message:
MDM = H(KMK).6 It then sends [ MMDM] to B. Because B possesses K, it can
recompute H(K7M7K) and verify MDM. Because the secret key itself is not sent, it
should not be possible for an attacker to modify an intercepted message. As long as
the secret key remains secret, it should not be possible for an attacker to generate a
false message.

Note that the secret key is used as both a prefix and a suffix to the message. If
the secret key is used as either only a prefix or only a suffix, the scheme is less secure.
This topic is discussed in Chapter 21. Chapter 21 also describes a scheme known
as HMAC, which is somewhat more complex than the approach of Figure 2.6c and
which has become the standard approach for a keyed hash MAC.
Hash Function Requirements
Can be applied to a block of data of any size
Produces a fixed-length output
H(x) is relatively easy to compute for any given x
One-way or pre-image resistant
computationally infeasible to find x such that H(x) = h
67

68
67

The purpose of a hash function is to produce a
“fingerprint” of a file, message, or other block of data. To be useful for message
authentication, a hash function H must have the following properties:
1. H can be applied to a block of data of any size.
2. H produces a fixed-length output.
3. H(x) is relatively easy to compute for any given x, making both hardware and
software implementations practical.
4. For any given code h, it is computationally infeasible to find x such that
H(x)  h. A hash function with this property is referred to as one-way or preimage
resistant.
5. For any given block x, it is computationally infeasible to find y  x with
H(y)  H(x). A hash function with this property is referred to as second preimage
resistant. This is sometimes referred to as weak collision resistant.
6. It is computationally infeasible to find any pair (x, y) such that H(x)  H(y).
A hash function with this property is referred to as collision resistant. This is
sometimes referred to as strong collision resistant.
The first three properties are requirements for the practical application of a hash
function to message authentication.
The fourth property is the one-way property: It is easy to generate a code given a
message, but virtually impossible to generate a message given a code. This property is
important if the authentication technique involves the use of a secret value (Figure 2.6c).
The secret value itself is not sent; however, if the hash function is not one way, an attacker
can easily discover the secret value: If the attacker can observe or intercept a transmission,
the attacker obtains the message M and the hash code MDM  H(SAB || M). The attacker
then inverts the hash function to obtain SAB || M  H-1(MDM). Because the attacker now
has both M and SAB || M, it is a trivial matter to recover SAB.
The fifth property guarantees that it is impossible to find an alternative
message with the same hash value as a given message. This prevents forgery when
an encrypted hash code is used (Figures 2.6a and b). If this property were not true,
an attacker would be capable of the following sequence: First, observe or intercept
a message plus its encrypted hash code; second, generate an unencrypted hash code
from the message; third, generate an alternate message with the same hash code.
A hash function that satisfies the first five properties in the preceding list is
referred to as a weak hash function. If the sixth property is also satisfied, then it
is referred to as a strong hash function. A strong hash function protects against an
attack in which one party generates a message for another party to sign. For example,
suppose Bob gets to write an IOU message, send it to Alice, and she signs it.
Bob finds two messages with the same hash, one of which requires Alice to pay a
small amount and one that requires a large payment. Alice signs the first message
and Bob is then able to claim that the second message is authentic.
Hash Function Requirements
Second pre-image resistant or weak collision resistant
Given x, it computationally infeasible to find y ≠ x such that	H(y) = H(x)
Not alternative message can be found
Collision resistant or strong collision resistance (Strong Hash)
computationally infeasible to find any pair (x, y) such that H(x) = H(y)
68

69
68

The purpose of a hash function is to produce a
“fingerprint” of a file, message, or other block of data. To be useful for message
authentication, a hash function H must have the following properties:
1. H can be applied to a block of data of any size.
2. H produces a fixed-length output.
3. H(x) is relatively easy to compute for any given x, making both hardware and
software implementations practical.
4. For any given code h, it is computationally infeasible to find x such that
H(x)  h. A hash function with this property is referred to as one-way or preimage
resistant.
5. For any given block x, it is computationally infeasible to find y  x with
H(y)  H(x). A hash function with this property is referred to as second preimage
resistant. This is sometimes referred to as weak collision resistant.
6. It is computationally infeasible to find any pair (x, y) such that H(x)  H(y).
A hash function with this property is referred to as collision resistant. This is
sometimes referred to as strong collision resistant.
The first three properties are requirements for the practical application of a hash
function to message authentication.
The fourth property is the one-way property: It is easy to generate a code given a
message, but virtually impossible to generate a message given a code. This property is
important if the authentication technique involves the use of a secret value (Figure 2.6c).
The secret value itself is not sent; however, if the hash function is not one way, an attacker
can easily discover the secret value: If the attacker can observe or intercept a transmission,
the attacker obtains the message M and the hash code MDM  H(SAB || M). The attacker
then inverts the hash function to obtain SAB || M  H-1(MDM). Because the attacker now
has both M and SAB || M, it is a trivial matter to recover SAB.
The fifth property guarantees that it is impossible to find an alternative
message with the same hash value as a given message. This prevents forgery when
an encrypted hash code is used (Figures 2.6a and b). If this property were not true,
an attacker would be capable of the following sequence: First, observe or intercept
a message plus its encrypted hash code; second, generate an unencrypted hash code
from the message; third, generate an alternate message with the same hash code.
A hash function that satisfies the first five properties in the preceding list is
referred to as a weak hash function. If the sixth property is also satisfied, then it
is referred to as a strong hash function. A strong hash function protects against an
attack in which one party generates a message for another party to sign. For example,
suppose Bob gets to write an IOU message, send it to Alice, and she signs it.
Bob finds two messages with the same hash, one of which requires Alice to pay a
small amount and one that requires a large payment. Alice signs the first message
and Bob is then able to claim that the second message is authentic.
Security of Hash Functions
Two approaches to attacking a secure hash function:
Cryptanalysis
exploit logical weaknesses in the algorithm
Brute-force attack
strength of hash function depends solely on the length of the hash code produced by the algorithm

SHA (Secure hash function) most widely used hash algorithm – 160 bits
69

70
69

As with symmetric encryption, there are two
approaches to attacking a secure hash function: cryptanalysis and brute-force attack.
As with symmetric encryption algorithms, cryptanalysis of a hash function involves
exploiting logical weaknesses in the algorithm.
The strength of a hash function against brute-force attacks depends solely on
the length of the hash code produced by the algorithm.
For a hash code of length n,
the level of effort required is proportional to the following:
Preimage resistant 2n
Second preimage resistant 2n
Collision resistant 2n/2

If collision resistance is required (and this is desirable for a general-purpose
secure hash code), then the value 2n/2 determines the strength of the hash code against
brute-force attacks. Van Oorschot and Wiener [VANO94] pre sented a design for a
$10 million collision search machine for MD5, which has a 128-bit hash length, that
could find a collision in 24 days. Thus a 128-bit code may be viewed as inadequate.
The next step up, if a hash code is treated as a sequence of 32 bits, is a 160-bit hash
length. With a hash length of 160 bits, the same search machine would require over
four thousand years to find a collision. With today’s technology, the time would be
much shorter, so that 160 bits now appears suspect.

In recent years, the most widely used
hash function has been the Secure Hash Algorithm (SHA). SHA was developed
by the National Institute of Standards and Technology (NIST) and published as
a federal information processing standard (FIPS 180) in 1993. When weaknesses
were discovered in SHA, a revised version was issued as FIPS 180-1 in 1995 and is
generally referred to as SHA-1. SHA-1 produces a hash value of 160 bits. In 2002,
NIST produced a revised version of the standard, FIPS 180–2, that defined three
new versions of SHA, with hash value lengths of 256, 384, and 512 bits, known as
SHA-256, SHA-384, and SHA-512. These new versions have the same underlying
structure and use the same types of modular arithmetic and logical binary operations
as SHA-1. In 2005, NIST announced the intention to phase out approval of SHA-1
and move to a reliance on the other SHA versions by 2010. As discussed in Chapter
21, researchers have demonstrated that SHA-1 is far weaker than its 160-bit hash
length suggests, necessitating the move to the newer versions of SHA.

We have discussed the use of hash functions for message authentication and for the
creation of digital signatures (the latter is discussed in more detail later in this chapter).
Here are two other examples of secure hash function applications:

• Passwords: Chapter 3 explains a scheme in which a hash of a password is
stored by an operating system rather than the password itself. Thus, the actual
password is not retrievable by a hacker who gains access to the password file.
In simple terms, when a user enters a password, the hash of that password is
compared to the stored hash value for verification. This application requires
preimage resistance and perhaps second preimage resistance.

• Intrusion detection: Store H(F) for each file on a system and secure the hash
values (e.g., on a CD-R that is kept secure). One can later determine if a file has
been modified by recomputing H(F). An intruder would need to change F without
changing H(F). This application requires weak second preimage resistance
Security of Hash Functions
Additional secure hash function applications:
Passwords - hash of a password is stored by an operating system
intrusion detection - store H(F) for each file on a system and secure the hash values
70

71
70

As with symmetric encryption, there are two
approaches to attacking a secure hash function: cryptanalysis and brute-force attack.
As with symmetric encryption algorithms, cryptanalysis of a hash function involves
exploiting logical weaknesses in the algorithm.
The strength of a hash function against brute-force attacks depends solely on
the length of the hash code produced by the algorithm.
For a hash code of length n,
the level of effort required is proportional to the following:
Preimage resistant 2n
Second preimage resistant 2n
Collision resistant 2n/2

If collision resistance is required (and this is desirable for a general-purpose
secure hash code), then the value 2n/2 determines the strength of the hash code against
brute-force attacks. Van Oorschot and Wiener [VANO94] pre sented a design for a
$10 million collision search machine for MD5, which has a 128-bit hash length, that
could find a collision in 24 days. Thus a 128-bit code may be viewed as inadequate.
The next step up, if a hash code is treated as a sequence of 32 bits, is a 160-bit hash
length. With a hash length of 160 bits, the same search machine would require over
four thousand years to find a collision. With today’s technology, the time would be
much shorter, so that 160 bits now appears suspect.

In recent years, the most widely used
hash function has been the Secure Hash Algorithm (SHA). SHA was developed
by the National Institute of Standards and Technology (NIST) and published as
a federal information processing standard (FIPS 180) in 1993. When weaknesses
were discovered in SHA, a revised version was issued as FIPS 180-1 in 1995 and is
generally referred to as SHA-1. SHA-1 produces a hash value of 160 bits. In 2002,
NIST produced a revised version of the standard, FIPS 180–2, that defined three
new versions of SHA, with hash value lengths of 256, 384, and 512 bits, known as
SHA-256, SHA-384, and SHA-512. These new versions have the same underlying
structure and use the same types of modular arithmetic and logical binary operations
as SHA-1. In 2005, NIST announced the intention to phase out approval of SHA-1
and move to a reliance on the other SHA versions by 2010. As discussed in Chapter
21, researchers have demonstrated that SHA-1 is far weaker than its 160-bit hash
length suggests, necessitating the move to the newer versions of SHA.

We have discussed the use of hash functions for message authentication and for the
creation of digital signatures (the latter is discussed in more detail later in this chapter).
Here are two other examples of secure hash function applications:

• Passwords: Chapter 3 explains a scheme in which a hash of a password is
stored by an operating system rather than the password itself. Thus, the actual
password is not retrievable by a hacker who gains access to the password file.
In simple terms, when a user enters a password, the hash of that password is
compared to the stored hash value for verification. This application requires
preimage resistance and perhaps second preimage resistance.

• Intrusion detection: Store H(F) for each file on a system and secure the hash
values (e.g., on a CD-R that is kept secure). One can later determine if a file has
been modified by recomputing H(F). An intruder would need to change F without
changing H(F). This application requires weak second preimage resistance
Public-Key Encryption
Publicly proposed by Diffie and Hellman in 1976

Asymmetric
Uses two separate keys
Public key (PUK) and private key (PRK)
Public key is made public for others to use
There is a relation between the private and public key.

Some form of protocol is needed for distribution
71

72

Public-key encryption, first publicly proposed by Diffie and Hellman in 1976
[DIFF76], is the first truly revolutionary advance in encryption in literally thousands
of years. Public-key algorithms are based on mathematical functions rather than on
simple operations on bit patterns, such as are used in symmetric encryption algorithms.
More important, public-key cryptography is asymmetric, involving the use
of two separate keys, in contrast to symmetric encryption, which uses only one key.
The use of two keys has profound consequences in the areas of confidentiality, key
distribution, and authentication.

Before proceeding, we should first mention several common misconceptions
concerning public-key encryption. One is that public-key encryption is more secure
from cryptanalysis than symmetric encryption. In fact, the security of any encryption
scheme depends on (1) the length of the key and (2) the computational work involved
in breaking a cipher. There is nothing in principle about either symmetric or public-key
encryption that makes one superior to another from the point of view of resisting cryptanalysis.
A second misconception is that public-key encryption is a general- purpose
technique that has made symmetric encryption obsolete. On the contrary, because of
the computational overhead of current public-key encryption schemes, there seems no
foreseeable likelihood that symmetric encryption will be abandoned. Finally, there is
a feeling that key distribution is trivial when using public-key encryption, compared to
the rather cumbersome handshaking involved with key distribution centers for symmetric
encryption. For public-key key distribution, some form of protocol is needed,
often involving a central agent, and the procedures involved are no simpler or any
more efficient than those required for symmetric encryption.

As the names suggest, the public key of the pair is made public for others to
use, while the private key is known only to its owner. A general-purpose public-key
cryptographic algorithm relies on one key for encryption and a different but related
key for decryption.

The essential steps are the following:

1. Each user generates a pair of keys to be used for the encryption and decryption
of messages.

2. Each user places one of the two keys in a public register or other accessible
file. This is the public key. The companion key is kept private. As Figure 2.7a
suggests, each user maintains a collection of public keys obtained from others.

3. If Bob wishes to send a private message to Alice, Bob encrypts the message
using Alice’s public key.

4. When Alice receives the message, she decrypts it using her private key. No
other recipient can decrypt the message because only Alice knows Alice’s private
key.

With this approach, all participants have access to public keys, and private keys
are generated locally by each participant and therefore need never be distributed.
As long as a user protects his or her private key, incoming communication is secure.
At any time, a user can change the private key and publish the companion public
key to replace the old public key.
71
Public-Key Encryption [58] 
(Confidentiality) 
72

73
72

A public-key encryption scheme has six ingredients (Figure 2.7a):

• Plaintext: This is the readable message or data that is fed into the algorithm as
input.

• Encryption algorithm: The encryption algorithm performs various transformations
on the plaintext.

• Public and private key: This is a pair of keys that have been selected so that
if one is used for encryption, the other is used for decryption. The exact
transformations performed by the encryption algorithm depend on the public
or private key that is provided as input.

Ciphertext: This is the scrambled message produced as output. It depends on
the plaintext and the key. For a given message, two different keys will produce
two different ciphertexts.

• Decryption algorithm: This algorithm accepts the ciphertext and the matching
key and produces the original plaintext.

As the names suggest, the public key of the pair is made public for others to
use, while the private key is known only to its owner. A general-purpose public-key
cryptographic algorithm relies on one key for encryption and a different but related
key for decryption.

The essential steps are the following:

1. Each user generates a pair of keys to be used for the encryption and decryption
of messages.

2. Each user places one of the two keys in a public register or other accessible
file. This is the public key. The companion key is kept private. As Figure 2.7a
suggests, each user maintains a collection of public keys obtained from others.

3. If Bob wishes to send a private message to Alice, Bob encrypts the message
using Alice’s public key.
4. When Alice receives the message, she decrypts it using her private key. No
other recipient can decrypt the message because only Alice knows Alice’s private
key.

With this approach, all participants have access to public keys, and private keys
are generated locally by each participant and therefore need never be distributed.
As long as a user protects his or her private key, incoming communication is secure.
At any time, a user can change the private key and publish the companion public
key to replace the old public key.

Note that the scheme of Figure 2.7a is directed toward providing confidentiality:
Only the intended recipient should be able to decrypt the ciphertext because only
the intended recipient is in possession of the required private key. Whether in fact
confidentiality is provided depends on a number of factors, including the security of
the algorithm, whether the private key is kept secure, and the security of any protocol
of which the encryption function is a part.
Private-Key Encryption
(Authentication \ data integrity)
73

74
73

Figure 2.7b illustrates another mode of operation of public-key cryptography.
In this scheme, a user encrypts data using his or her own private key.
Anyone who knows the corresponding public key will then be able to decrypt the
message.

The scheme of Figure 2.7b is directed toward providing authentication
and/or data integrity. If a user is able to successfully recover the plaintext from
Bob’s ciphertext using Bob’s public key, this indicates that only Bob could have
encrypted the plaintext, thus providing authentication. Further, no one but
Bob would be able to modify the plaintext because only Bob could encrypt the
plaintext with Bob’s private key. Once again, the actual provision of authentication
or data integrity depends on a variety of factors. This issue is addressed
primarily in Chapter 21, but other references are made to it where appropriate in
this text.
Requirements for Public-Key Cryptosystems
Computationally easy to create key pairs

Computationally easy for sender knowing public key to encrypt messages

Computationally easy for receiver knowing private key to decrypt ciphertext
74

75
74

1. It is computationally easy for a party B to generate a pair (public key PUb, private key PRb).

2. It is computationally easy for a sender A, knowing the public key and the message to be encrypted, M, to generate the corresponding ciphertext: C = E(PUb, M)

3. It is computationally easy for the receiver B to decrypt the resulting ciphertext using the private key to recover the original message:
M = D(PRb,C) = D[PRb, E(PUb, M)]

4. It is computationally infeasible for an opponent, knowing the public key, PUb, to determine the private key, PRb.

5. It is computationally infeasible for an opponent, knowing the public key, PUb, and a ciphertext, C, to recover the original message, M.

We can add a sixth requirement that, although useful, is not necessary for all public-key applications:

6. Either of the two related keys can be used for encryption, with the other used for decryption.
M = D[PUb, E(PRb, M)] = D[PRb, E(PUb, M)]
Requirements for Public-Key Cryptosystems
Computationally infeasible for opponent to determine private key from public key

Computationally infeasible for opponent to otherwise recover original message

Useful if either key can be used for each role (encryption/Decryption)
75

76
75

1. It is computationally easy for a party B to generate a pair (public key PUb, private key PRb).

2. It is computationally easy for a sender A, knowing the public key and the message to be encrypted, M, to generate the corresponding ciphertext: C = E(PUb, M)

3. It is computationally easy for the receiver B to decrypt the resulting ciphertext using the private key to recover the original message:
M = D(PRb,C) = D[PRb, E(PUb, M)]

4. It is computationally infeasible for an opponent, knowing the public key, PUb, to determine the private key, PRb.

5. It is computationally infeasible for an opponent, knowing the public key, PUb, and a ciphertext, C, to recover the original message, M.

We can add a sixth requirement that, although useful, is not necessary for all public-key applications:

6. Either of the two related keys can be used for encryption, with the other used for decryption.
M = D[PUb, E(PRb, M)] = D[PRb, E(PUb, M)]
Asymmetric Encryption Algorithms
76


77
76

RSA One of the first public-key schemes was developed in 1977 by Ron Rivest, Adi
Shamir, and Len Adleman at MIT and first published in 1978 [RIVE78]. The RSA
scheme has since reigned supreme as the most widely accepted and implemented
approach to public-key encryption. RSA is a block cipher in which the plaintext and
ciphertext are integers between 0 and n – 1 for some n.

In 1977, the three inventors of RSA dared Scientific American readers to decode
a cipher they printed in Martin Gardner’s “Mathematical Games” column. They
offered a $100 reward for the return of a plaintext sentence, an event they predicted
might not occur for some 40 quadrillion years. In April of 1994, a group working over
the Internet and using over 1600 computers claimed the prize after only eight months
of work [LEUT94]. This challenge used a public-key size (length of n) of 129 decimal
digits, or around 428 bits. This result does not invalidate the use of RSA; it simply
means that larger key sizes must be used. Cur rently, a 1024-bit key size (about 300
decimal digits) is considered strong enough for virtually all applications.

DIFFIE-HELLMAN KEY AGREEMENT The first published public-key algo rithm
appeared in the seminal paper by Diffie and Hellman that defined public-key
cryptography [DIFF76] and is generally referred to as Diffie-Hellman key exchange,
or key agreement. A number of commercial products employ this key exchange
technique.

The purpose of the algorithm is to enable two users to securely reach agreement
about a shared secret that can be used as a secret key for subsequent symmetric
encryption of messages. The algorithm itself is limited to the exchange of the keys.

DIGITAL SIGNATURE STANDARD The National Institute of Standards and Technology
(NIST) has published Federal Information Processing Standard FIPS PUB 186,
known as the Digital Signature Standard (DSS). The DSS makes use of SHA-1
and presents a new digital signature technique, the Digital Signature Algorithm
(DSA). The DSS was originally proposed in 1991 and revised in 1993 in response to
public feedback concerning the security of the scheme. There was a further minor
revision in 1996. The DSS uses an algorithm that is designed to provide only the digital
signature function. Unlike RSA, it cannot be used for encryption or key exchange.

ELLIPTIC CURVE CRYPTOGRAPHY The vast majority of the products and standards
that use public-key cryptography for encryption and digital signatures use RSA.
The bit length for secure RSA use has increased over recent years, and this has put
a heavier processing load on applications using RSA. This burden has ramifications,
especially for electronic commerce sites that conduct large numbers of secure
transactions. Recently, a competing system has begun to challenge RSA: elliptic
curve cryptography (ECC). Already, ECC is showing up in standardization efforts,
including the IEEE (Institute of Electrical and Electronics Engineers) P1363
Standard for Public-Key Cryptography.

The principal attraction of ECC compared to RSA is that it appears to offer
equal security for a far smaller bit size, thereby reducing processing overhead. On
the other hand, although the theory of ECC has been around for some time, it is
only recently that products have begun to appear and that there has been sustained
cryptanalytic interest in probing for weaknesses. Thus, the confidence level in ECC
is not yet as high as that in RSA.
Applications for Public-Key Cryptosystems [59]
77

78

Table 2.3 indicates the applications supported by the algorithms
discussed in this section.
77
Digital Signatures
Used for authenticating of:
Source 
Data integrity

Created by encrypting hash code with private key

Does not provide confidentiality
Even in the case of complete encryption
Message is safe from alteration but not eavesdropping
78

79

Public-key encryption can be used for authentication, as suggested by Figure 2.6b.
Suppose that Bob wants to send a message to Alice. Although it is not important that
the message be kept secret, he wants Alice to be certain that the message is indeed
from him. For this purpose, Bob uses a secure hash function, such as SHA-512, to
generate a hash value for the message and then encrypts the hash code with his private
key, creating a digital signature. Bob sends the message with the signature attached.
When Alice receives the message plus signature, she (1) calculates a hash value for
the message; (2) decrypts the signature using Bob’s public key; and (3) compares the
calculated hash value to the decrypted hash value. If the two hash values match, Alice
is assured that the message must have been signed by Bob. No one else has Bob’s
private key and therefore no one else could have created a ciphertext that could be
decrypted with Bob’s public key. In addition, it is impossible to alter the message
without access to Bob’s private key, so the message is authenticated both in terms of
source and in terms of data integrity.

It is important to emphasize that the digital signature does not provide confidentiality.
That is, the message being sent is safe from alteration but not safe from
eavesdropping. This is obvious in the case of a signature based on a portion of the
message, because the rest of the message is transmitted in the clear. Even in the
case of complete encryption, there is no protection of confidentiality because any
observer can decrypt the message by using the sender’s public key.
78
Digital Signatures
encrypt the digest only using private key
      - used as digital signature
       - no need for key distribution
79

80
79

Unlike the MAC, a hash function does not also take a secret key as input.
To authenticate a message, the message digest is sent with the message in such a way that the message digest is authentic.
The Figure illustrates three ways in which the message can be authenticated using a hash code. 
The message digest can be encrypted using symmetric encryption (part a); if it is assumed that only the sender and receiver share the encryption key, then authenticity is assured. 
The message digest can also be encrypted using public-key encryption (part b).
The public-key approach has two advantages: It provides a digital signature as well as message authentication; and it does not require the
distribution of keys to communicating parties.

These two approaches have an advantage over approaches that encrypt the entire message in that less computation is required. But an even more common approach is  the use of a technique that avoids encryption altogether. Several reasons
for this interest are pointed out in [TSUD92]:

• Encryption software is quite slow. Even though the amount of data to be
encrypted per message is small, there may be a steady stream of messages into
and out of a system.

• Encryption hardware costs are non-negligible. Low-cost chip implementations
of DES are available, but the cost adds up if all nodes in a network must have
this capability.

• Encryption hardware is optimized toward large data sizes. For small blocks of
data, a high proportion of the time is spent in initialization/invocation overhead.

• An encryption algorithm may be protected by a patent.

Figure 2.6c shows a technique that uses a hash function but no encryption for message authentication. 
This technique, known as a keyed hash MAC, assumes that two communicating parties, say A and B, share a common secret key K.
This secret key is incorporated into the process of generating a hash code. In the
approach illustrated in Figure 2.6c, when A has a message to send to B, it calculates
the hash function over the concatenation of the secret key and the message:
MDM = H(KMK).6 It then sends [ MMDM] to B. Because B possesses K, it can
recompute H(K7M7K) and verify MDM. Because the secret key itself is not sent, it
should not be possible for an attacker to modify an intercepted message. As long as
the secret key remains secret, it should not be possible for an attacker to generate a
false message.

Note that the secret key is used as both a prefix and a suffix to the message. If
the secret key is used as either only a prefix or only a suffix, the scheme is less secure.
This topic is discussed in Chapter 21. Chapter 21 also describes a scheme known
as HMAC, which is somewhat more complex than the approach of Figure 2.6c and
which has become the standard approach for a keyed hash MAC.
Public Key Certificates
The weakness of PKE: 
anyone can forge a publication of the Bob’s public key and 
by the time it is discovered he can read messages aimed at Bob and pretend to be Bob as well
We need a trusted third party – certificate authority CA
80

81
80

בוב הולך קודם לCA ומבקש שיספק לוcertificate , התקשורת היא קודם בין בוב לCA. 

 קיים צד שלשי , certificate authority, לכל אחד שמשתתף בתקשורת , המשתתף הולך לנציג הזה מזדהה בפניו , ומבקש ממנו certificate , שכל מי שרוצה לדבר איתי שכולם יוודאו שהוא בוב. 
מה כולל הcertificate? 
את הפרטים של בוב, 
את המפתח שלו ואת הפרטים של ה certificate , אותו נציג ונצרף את הMAC , ומצמיד אותו להודעה( הריבוע השחור נקרא digital signature) . כדי לעשות ווידוא למפתח הפומבי של בוב , נעשה האש למפתח של בוב ושאר השדות שמעליו ומתחתיו , ונעשה פיענוח של החתימה ואם נקבל פרטים שונים כנראה שמי שמדבר איתנו הוא לא בוב. 



On the face of it, the point of public-key encryption is that the public key is public.
Thus, if there is some broadly accepted public-key algorithm, such as RSA, any
participant can send his or her public key to any other participant or broadcast the
key to the community at large. Although this approach is convenient, it has a major
weakness. Anyone can forge such a public announcement. That is, some user could
pretend to be Bob and send a public key to another participant or broadcast such a
public key. Until such time as Bob discovers the forgery and alerts other participants,
the forger is able to read all encrypted messages intended for A and can use the
forged keys for authentication.

The solution to this problem is the public-key certificate. In essence, a certificate
consists of a public key plus a user ID of the key owner, with the whole block
signed by a trusted third party. The certificate also includes some information about
the third party plus an indication of the period of validity of the certificate. Typically,
the third party is a certificate authority (CA) that is trusted by the user community,
such as a government agency or a financial institution. A user can present his
or her public key to the authority in a secure manner and obtain a signed certificate.
The user can then publish the certificate. Anyone needing this user’s public key
can obtain the certificate and verify that it is valid by means of the attached trusted
signature. Figure 2.8 illustrates the process.

One scheme has become universally accepted for formatting public-key
certificates: the X.509 standard. X.509 certificates are used in most network security
applications, including IP Security (IPsec), Transport Layer Security (TLS), Secure
Shell (SSH), and Secure/Multipurpose Internet Mail Extension (S/MIME). We
examine most of these applications in Part Five.
Public Key Certificates
81

82
81

בוב הולך קודם לCA ומבקש שיספק לוcertificate , התקשורת היא קודם בין בוב לCA. 

 קיים צד שלשי , certificate authority, לכל אחד שמשתתף בתקשורת , המשתתף הולך לנציג הזה מזדהה בפניו , ומבקש ממנו certificate , שכל מי שרוצה לדבר איתי שכולם יוודאו שהוא בוב. 
מה כולל הcertificate? 
את הפרטים של בוב, 
את המפתח שלו ואת הפרטים של ה certificate , אותו נציג ונצרף את הMAC , ומצמיד אותו להודעה( הריבוע השחור נקרא digital signature) . כדי לעשות ווידוא למפתח הפומבי של בוב , נעשה האש למפתח של בוב ושאר השדות שמעליו ומתחתיו , ונעשה פיענוח של החתימה ואם נקבל פרטים שונים כנראה שמי שמדבר איתנו הוא לא בוב. 



On the face of it, the point of public-key encryption is that the public key is public.
Thus, if there is some broadly accepted public-key algorithm, such as RSA, any
participant can send his or her public key to any other participant or broadcast the
key to the community at large. Although this approach is convenient, it has a major
weakness. Anyone can forge such a public announcement. That is, some user could
pretend to be Bob and send a public key to another participant or broadcast such a
public key. Until such time as Bob discovers the forgery and alerts other participants,
the forger is able to read all encrypted messages intended for A and can use the
forged keys for authentication.

The solution to this problem is the public-key certificate. In essence, a certificate
consists of a public key plus a user ID of the key owner, with the whole block
signed by a trusted third party. The certificate also includes some information about
the third party plus an indication of the period of validity of the certificate. Typically,
the third party is a certificate authority (CA) that is trusted by the user community,
such as a government agency or a financial institution. A user can present his
or her public key to the authority in a secure manner and obtain a signed certificate.
The user can then publish the certificate. Anyone needing this user’s public key
can obtain the certificate and verify that it is valid by means of the attached trusted
signature. Figure 2.8 illustrates the process.

One scheme has become universally accepted for formatting public-key
certificates: the X.509 standard. X.509 certificates are used in most network security
applications, including IP Security (IPsec), Transport Layer Security (TLS), Secure
Shell (SSH), and Secure/Multipurpose Internet Mail Extension (S/MIME). We
examine most of these applications in Part Five.
Public Key Certificates – hierarchy of trust
82

83
82

בוב הולך קודם לCA ומבקש שיספק לוcertificate , התקשורת היא קודם בין בוב לCA. 

 קיים צד שלשי , certificate authority, לכל אחד שמשתתף בתקשורת , המשתתף הולך לנציג הזה מזדהה בפניו , ומבקש ממנו certificate , שכל מי שרוצה לדבר איתי שכולם יוודאו שהוא בוב. 
מה כולל הcertificate? 
את הפרטים של בוב, 
את המפתח שלו ואת הפרטים של ה certificate , אותו נציג ונצרף את הMAC , ומצמיד אותו להודעה( הריבוע השחור נקרא digital signature) . כדי לעשות ווידוא למפתח הפומבי של בוב , נעשה האש למפתח של בוב ושאר השדות שמעליו ומתחתיו , ונעשה פיענוח של החתימה ואם נקבל פרטים שונים כנראה שמי שמדבר איתנו הוא לא בוב. 



On the face of it, the point of public-key encryption is that the public key is public.
Thus, if there is some broadly accepted public-key algorithm, such as RSA, any
participant can send his or her public key to any other participant or broadcast the
key to the community at large. Although this approach is convenient, it has a major
weakness. Anyone can forge such a public announcement. That is, some user could
pretend to be Bob and send a public key to another participant or broadcast such a
public key. Until such time as Bob discovers the forgery and alerts other participants,
the forger is able to read all encrypted messages intended for A and can use the
forged keys for authentication.

The solution to this problem is the public-key certificate. In essence, a certificate
consists of a public key plus a user ID of the key owner, with the whole block
signed by a trusted third party. The certificate also includes some information about
the third party plus an indication of the period of validity of the certificate. Typically,
the third party is a certificate authority (CA) that is trusted by the user community,
such as a government agency or a financial institution. A user can present his
or her public key to the authority in a secure manner and obtain a signed certificate.
The user can then publish the certificate. Anyone needing this user’s public key
can obtain the certificate and verify that it is valid by means of the attached trusted
signature. Figure 2.8 illustrates the process.

One scheme has become universally accepted for formatting public-key
certificates: the X.509 standard. X.509 certificates are used in most network security
applications, including IP Security (IPsec), Transport Layer Security (TLS), Secure
Shell (SSH), and Secure/Multipurpose Internet Mail Extension (S/MIME). We
examine most of these applications in Part Five.
Digital Envelopes
Protects a message without needing to first arrange for sender and receiver to have the same secret key 
Equates to the same thing as a sealed envelope containing an unsigned letter
The symmetric key is exchanges through Asymmetric PKE
The messages encrypted using the encrypted symmetric key
Advantages:
Short keys
Symmetric - Fast encryption and decryption of messages
New symmetric keys in every session – enhances confidentiality
83


84
83




Another application in which public-key encryption is used to protect a symmetric
key is the digital envelope, which can be used to protect a message without needing
to first arrange for sender and receiver to have the same secret key. The technique
is referred to as a digital envelope, which is the equivalent of a sealed envelope
containing an unsigned letter. The general approach is shown in Figure 2.9. Suppose
Bob wishes to send a confidential message to Alice, but they do not share a symmetric
secret key. Bob does the following:

1. Prepare a message.

2. Generate a random symmetric key that will be used this one time only.

3. Encrypt that message using symmetric encryption the one-time key.

4. Encrypt the one-time key using public-key encryption with Alice’s public key.

5. Attach the encrypted one-time key to the encrypted message and send it to
Alice.

Only Alice is capable of decrypting the one-time key and therefore of recovering
the original message. If Bob obtained Alice’s public key by means of Alice’s
public-key certificate, then Bob is assured that it is a valid key.
Digital Envelopes - Encryption
84


85
84




Another application in which public-key encryption is used to protect a symmetric
key is the digital envelope, which can be used to protect a message without needing
to first arrange for sender and receiver to have the same secret key. The technique
is referred to as a digital envelope, which is the equivalent of a sealed envelope
containing an unsigned letter. The general approach is shown in Figure 2.9. Suppose
Bob wishes to send a confidential message to Alice, but they do not share a symmetric
secret key. Bob does the following:

1. Prepare a message.

2. Generate a random symmetric key that will be used this one time only.

3. Encrypt that message using symmetric encryption the one-time key.

4. Encrypt the one-time key using public-key encryption with Alice’s public key.

5. Attach the encrypted one-time key to the encrypted message and send it to
Alice.

Only Alice is capable of decrypting the one-time key and therefore of recovering
the original message. If Bob obtained Alice’s public key by means of Alice’s
public-key certificate, then Bob is assured that it is a valid key.
Digital Envelopes
85


86
85




Another application in which public-key encryption is used to protect a symmetric
key is the digital envelope, which can be used to protect a message without needing
to first arrange for sender and receiver to have the same secret key. The technique
is referred to as a digital envelope, which is the equivalent of a sealed envelope
containing an unsigned letter. The general approach is shown in Figure 2.9. Suppose
Bob wishes to send a confidential message to Alice, but they do not share a symmetric
secret key. Bob does the following:

1. Prepare a message.

2. Generate a random symmetric key that will be used this one time only.

3. Encrypt that message using symmetric encryption the one-time key.

4. Encrypt the one-time key using public-key encryption with Alice’s public key.

5. Attach the encrypted one-time key to the encrypted message and send it to
Alice.

Only Alice is capable of decrypting the one-time key and therefore of recovering
the original message. If Bob obtained Alice’s public key by means of Alice’s
public-key certificate, then Bob is assured that it is a valid key.
Q&A
Bob encrypt a message with symmetric key, and sends it to Alice who owns this key as well, what did he achieve?

Bob encrypts a message with his private key, and sends it to Alice, what did he achieve?

Bob encrypts a message with his public key, and sends it to Alice, what did he achieve?

Bob encrypts message with Alice’s public key, and sends it to Alice, what did he achieve?

Bob encrypts message’s hash code with his private key, and sends it to Alice with the message itself encrypted with Alice’s public key, what did he achieve?

Bob encrypts message’s hash code with Alice’s public key, and sends it to Alice, what did he achieve?

Confidentiality?
Message authentication (integrity of content and time)?
Source authentication?
Nothing
86


87
86

תשובות לשאלות:

a+c המידע מגיע מוגן, רק למי שאני חולק איתו את המפתח ולכן אני אליס יודעת שזה אני.
c - בלבד כי כולם יודעים את הציבורי שלי, ולכן אין כאן confidentiality.
d – כלום כי רק לי יש את הפרטי, אין לאף אחד מה לעשות עם זה..... ובטח שגם לא לי.
a - בלבד כי המידע אומנם מגיע מוגן, אבל כולם יכולים להצפין עם הציבורי של אליס ולכן לא ידוע מי שלח בתצורה הזו.
A + C + B
D – כלום כי רק אליס יכולה לפתוח את ה HASH ומה היא תעשה איתה בדיוק?




Another application in which public-key encryption is used to protect a symmetric
key is the digital envelope, which can be used to protect a message without needing
to first arrange for sender and receiver to have the same secret key. The technique
is referred to as a digital envelope, which is the equivalent of a sealed envelope
containing an unsigned letter. The general approach is shown in Figure 2.9. Suppose
Bob wishes to send a confidential message to Alice, but they do not share a symmetric
secret key. Bob does the following:

1. Prepare a message.

2. Generate a random symmetric key that will be used this one time only.

3. Encrypt that message using symmetric encryption the one-time key.

4. Encrypt the one-time key using public-key encryption with Alice’s public key.

5. Attach the encrypted one-time key to the encrypted message and send it to
Alice.

Only Alice is capable of decrypting the one-time key and therefore of recovering
the original message. If Bob obtained Alice’s public key by means of Alice’s
public-key certificate, then Bob is assured that it is a valid key.
Strength of algorithms
Key space
Strength of the algorithm
Correctness of implementation
Key management
Random number generator
87

88
87


Cryptanalysis
Breaking codes
Attack vectors
Key
Algorithm
Implementation
Data
Social engineering
88

89
88


Random Numbers
Keys for public-key algorithms
Stream key for symmetric stream cipher
Symmetric key to be used as a temporary session key or in creating a digital envelope
Handshaking to prevent replay attacks
Session key
89

90
89

A number of network security algorithms based on cryptography make use of random numbers.
For example,
• Generation of keys for the RSA public-key encryption algorithm and other public-key algorithms.
• Generation of a stream key for symmetric stream cipher.
• Generation of a symmetric key for use as a temporary session key or in creating a digital envelope.

• In a number of key distribution scenarios, such as Kerberos, random numbers are used for handshaking to prevent replay attacks.

• Session key generation, whether done by a key distribution center or by one of the principals.

These applications give rise to two distinct and not necessarily compatible
requirements for a sequence of random numbers: randomness and unpredictability.
Random Number Requirements
Randomness
Uniform distribution
frequency of occurrence of each of the numbers should be approximately the same
Independence
no one value in the sequence can be inferred from the others
Unpredictability
Each number is statistically independent of other numbers in the sequence
Opponent should not be able to predict future elements of the sequence on the basis of earlier elements
90

91

Traditionally, the concern in the generation of a sequence of
allegedly random numbers has been that the sequence of numbers be random in
some well-defined statistical sense. The following two criteria are used to validate
that a sequence of numbers is random:

• Uniform distribution: The distribution of numbers in the sequence should be
uniform; that is, the frequency of occurrence of each of the numbers should be
approximately the same.

• Independence: No one value in the sequence can be inferred from the others.

Although there are well-defined tests for determining that a sequence of numbers
matches a particular distribution, such as the uniform distribution, there is no such
test to “prove” independence. Rather, a number of tests can be applied to demonstrate
if a sequence does not exhibit independence. The general strategy is to apply a number
of such tests until the confidence that independence exists is sufficiently strong.

In the context of our discussion, the use of a sequence of numbers that appear
statistically random often occurs in the design of algorithms related to cryptography.
For example, a fundamental requirement of the RSA public-key encryption scheme 
is the ability to generate prime numbers. In general, it is
difficult to determine if a given large number N is prime. A brute-force approach
would be to divide N by every odd integer less than 1N. If N is on the order, say,
of 10150, a not uncommon occurrence in public-key cryptography, such a brute-force
approach is beyond the reach of human analysts and their computers. However, a
number of effective algorithms exist that test the primality of a number by using a
sequence of randomly chosen integers as input to relatively simple computations.
If the sequence is sufficiently long (but far, far less than 110150), the primality of
a number can be determined with near certainty. This type of approach, known
as randomization, crops up frequently in the design of algorithms. In essence, if a
problem is too hard or time-consuming to solve exactly, a simpler, shorter approach
based on randomization is used to provide an answer with any desired level of
confidence.

UNPREDICTABILITY 
In applications such as reciprocal authentication and session key
generation, the requirement is not so much that the sequence of numbers be statistically
random but that the successive members of the sequence are unpredictable. With
“true” random sequences, each number is statistically independent of other numbers
in the sequence and therefore unpredictable. However, as is discussed shortly, true
random numbers are not always used; rather, sequences of numbers that appear to
be random are generated by some algorithm. In this latter case, care must be takent
of earlier elements.
90
Random versus Pseudorandom
Cryptographic applications typically make use of algorithmic techniques for random number generation
algorithms are deterministic and therefore produce sequences of numbers that are not statistically random
Pseudorandom numbers are:
sequences produced that satisfy statistical randomness tests
likely to be predictable
True random number generator (TRNG):
uses a nondeterministic source to produce randomness
most operate by measuring unpredictable natural processes
e.g. radiation, gas discharge, leaky capacitors
increasingly provided on modern processors 
91

92
91

Cryptographic applications typically make use of algorithmic techniques for random
number generation. These algorithms are deterministic and therefore produce
sequences of numbers that are not statistically random. However, if the algorithm is
good, the resulting sequences will pass many reasonable tests of randomness. Such
numbers are referred to as pseudorandom numbers.

You may be somewhat uneasy about the concept of using numbers generated
by a deterministic algorithm as if they were random numbers. Despite what might
be called philosophical objections to such a practice, it generally works. As one
expert on probability theory puts it [HAMM91],

For practical purposes we are forced to accept the awkward concept
of “relatively random” meaning that with regard to the proposed
use we can see no reason why they will not perform as if they were
random (as the theory usually requires). This is highly subjective
and is not very palatable to purists, but it is what statisticians regularly
appeal to when they take “a random sample”—they hope that
any results they use will have approximately the same properties as
a complete counting of the whole sample space that occurs in their
theory.

A true random number generator (TRNG) uses a nondeterministic source to
produce randomness. Most operate by measuring unpredictable natural processes,
such as pulse detectors of ionizing radiation events, gas discharge tubes, and leaky
capac itors. Intel has developed a commercially available chip that samples thermal
noise by amplifying the voltage measured across undriven resistors [JUN99].
A group at Bell Labs has developed a technique that uses the variations in the
response time of raw read requests for one disk sector of a hard disk [JAKO98].
LavaRnd is an open source project for creating truly random numbers using inexpensive
cameras, open source code, and inexpensive hardware. The system uses a
saturated charge- coupled device (CCD) in a light-tight can as a chaotic source to
produce the seed. Software processes the result into truly random numbers in a
variety of formats.
Practical Application
Common to encrypt data-in-motion
Much less common to encrypt data-at-rest
usually apply authentication and operating system access controls
archive
deleted data is sometime recoverable
encryption is achieved by using software, DLP mechanisms, hardware 

92

93
92

One of the principal security requirements of a computer system is the protection
of stored data. Security mechanisms to provide such protection include access control,
intrusion detection, and intrusion prevention schemes, all of which are discussed
in this book. The book also describes a number of technical means by which
these various security mechanisms can be made vulnerable. But beyond technical
approaches, these approaches can become vulnerable because of human factors.
We list a few examples here, based on [ROTH05].

• In December of 2004, Bank of America employees backed up and sent to its
backup data center tapes containing the names, addresses, bank account numbers,
and Social Security numbers of 1.2 million government workers enrolled
in a charge-card account. None of the data were encrypted. The tapes never
arrived and indeed have never been found. Sadly, this method of backing up
and shipping data is all too common. As an another example, in April of 2005,
Ameritrade blamed its shipping vendor for losing a backup tape containing
unencrypted information on 200,000 clients.

• In April of 2005, San Jose Medical group announced that someone had physically
stolen one of its computers and potentially gained access to 185,000
unencrypted patient records.

• There have been countless examples of laptops lost at airports, stolen from a
parked car, or taken while the user is away from his or her desk. If the data on the
laptop’s hard drive are unencrypted, all of the data are available to the thief.

Although it is now routine for businesses to provide a variety of protections,
including encryption, for information that is transmitted across networks, via the
Internet, or via wireless devices, once data are stored locally (referred to as data at
rest), there is often little protection beyond domain authentication and operating
system access controls. Data at rest are often routinely backed up to secondary storage
such as CDROM or tape, archived for indefinite periods. Further, even when
data are erased from a hard disk, until the relevant disk sectors are reused, the data
are recoverable. Thus it becomes attractive, and indeed should be mandatory, to
encrypt data at rest and combine this with an effective encryption key management
scheme.

There are a variety of ways to provide encryption services. A simple approach
available for use on a laptop is to use a commercially available encryption package
such as Pretty Good Privacy (PGP). PGP enables a user to generate a key from a
password and then use that key to encrypt selected files on the hard disk. The PGP
package does not store the password. To recover a file, the user enters the password,
PGP generates the password, and PGP decrypts the file. So long as the user protects
his or her password and does not use an easily guessable password, the files are fully
protected while at rest. Some more recent approaches are listed in [COLL06]:

• Back-end appliance: This is a hardware device that sits between servers and
storage systems and encrypts all data going from the server to the storage system
and decrypts data going in the opposite direction. These devices encrypt
data at close to wire speed, with very little latency. In contrast, encryption
software on servers and storage systems slows backups. A system man ager
configures the appliance to accept requests from specified clients, for which
unencrypted data are supplied.

• Library-based tape encryption: This is provided by means of a co-processor board
embedded in the tape drive and tape library hardware. The co-processor encrypts
data using a nonreadable key configured into the board. The tapes can then be sent
off-site to a facility that has the same tape drive hardware. The key can be exported
via secure e-mail or a small flash drive that is transported securely. If the matching
tape drive hardware co-processor is not available at the other site, the target facility
can use the key in a software decryption package to recover the data.

• Background laptop and PC data encryption: A number of vendors offer software
products that provide encryption that is transparent to the application and
the user. Some products encrypt all or designated files and folders. Other products
create a virtual disk, which can be maintained locally on the user’s hard
drive or maintained on a network storage device, with all data on the virtual
disk encrypted. Various key management solutions are offered to restrict access
to the owner of the data.
Important Emerging tools
Homomorphic encryption: 
is a form of encryption that allows computation on ciphertexts, generating an encrypted result which, when decrypted, matches the result of the operations as if they had been performed on the plaintext.
Quantum computing
Multiparty computation

93

94
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\intro\Introduction\CompNetSec1.Introduction.pdf </DOCNO>
<F P=104> Security </F>
<TEXT>
Computer & Information Security (372-1-460-1)
Introduction
Dept. of Software and Information Systems 
Engineering, Ben-Gurion University
Prof. Yuval Elovici, Dr. Asaf Shabtai, Dr. Mordechai Guri
Spring, 2019
1
Syllabus
• When:
– Monday 09:00 – 12:00
– Monday 13:00 – 16:00
– Tuesday 09:00 – 12:00
• TA’s:
– Ron Biton, Ben Nassi, Noam Moskovitch, Avihad Eliyashar, Vitaly Dyadyuk
• Exam (70%) + 4 Exercises (30%) + Labs
• Should submit 80% of the lab tasks
• Reading materials: 
– Network security: Kaufman/Perlman or Stallings
– Web
Syllabus
• Introduction to cyber security
• Encryption
• Access control
• Intrusion detection/data leakage/ firewall
• Malicious software
• Internet security protocols
• Attacks: buffer overflow, SQL injection, DoS
• Network security
3
Syllabus
4
Course goals
• Understanding threats to today’s 
computerized world
• Introduction to standard and emerging 
security mechanisms
• Setting a security state of mind
• Hands on experience
5
Course positioning
6
Introduction to computer and network 
security
Cryptography
Information 
Security 
Management
Malware Internals
סוגיות מתקדמות 
בקוד עוין
Cyber Security 
Using Machine 
Learning
הנדסת אבטחת 
מערכות
Operating Systems 
Security
Network Security
Implementation 
Attacks
Advanced topics 
in security
Ethics
• You will learn and practice attack 
techniques and approaches that can 
cause real damage
• Do not ‘experiment’ without guidance
7
Computer & information security
What is computer/network/ 
information security?
8
Cyber security
• Cyber security is defined as the 
intersection of
– computer security
– network security
– information security
– and…
physical space
9
Everything is connected…
10
Everything is connected…
11
Everything is connected…
• Internet is global, open, everybody online…
– Including the attackers!
• Computers are unprotected, unmanaged
– Insecure platforms (Windows, IE, pdf readers)
• Naïve users
• Many, untrusted clients and peers
• Protocols designed for friendly/secure 
environment
• Many threats / attacks…
12
13
What are the threats…
2007 ESTONIA
2008 
GHOSTNET
2009  
OPERATION 
AURORA
2010 
STUXNET
2010  
NASDAQ
2011 SONY
2011 
LOCKHEED 
MARTIN
2012
US BANKS
2012 FLAME
14
Some more examples…
15
Cyber attacks and critical 
infrastructure
Government Operations Emergency Systems Gas & Oil Water Supply Systems
Telecommunications Electrical Energy Transportation Banking & Finance
Critical 
Infrastructures
Project ‘Aurora’ (2007)
17
SCADA Networks
18
9-1-1 system DDoS blackout
19
Find the difference…
20
USAF RQ-170 
Find the difference…
21
United States F-22 vs. China J-20
Today’s battlefield
22
Advanced persistence threat 
(APT)
• A cyber attack mounted by organizational teams (e.g., foreign 
government) that have deep resources, advanced penetration 
skills, specific target profiles (political or commercial) and are 
remarkably
persistent in their efforts
23
Reconnaissance
1
2
4
5
Initial 
Exploitation
Internal Recon
Command 
& Control
Privilege
Escalation
Exfiltration &
Subversion
Maintain 
Persistence
6
3
An Observation from the Bible
“if as one people speaking the same language
they have begun to do this, then nothing they
plan to do will be impossible for them"
The fact that many computers are based
on the same operating system allows the
attackers to design successful attacks that
can also propagate from one computer to
another.
What’s wrong with that picture?
25
Evaluation Testbed (PoC)
BGU Cyber Security Research Center 16
Attacks on avionic systems –
becoming a real threat…
Attacks on cars
28
Automobile Example
• The Tesla Hack @ Black Hat 2016 & 2017
– Keen Security Lab: turn on the brakes remotely and 
getting the doors and trunk to open and close while 
blinking the lights in time to music streamed from the 
car's radio on Tesla Model X. 
– “the work was complex and not easily replicated” 
• The Jeep Hack @ Black Hat 2015 & 2016
– Remotely stop a car and disable its brake.
– Plug into the car's electronic system to hijack its 
steering and brake systems
• The TPMS “Hack”
– Tire Pressure Monitoring System (TPMS) signal sent 
wirelessly
– Easily eavesdropped, with unique identifier
29
Autonomous cars
30
Autonomous cars
31
32
33
Ransomware
34
Everything is smart
3/1/2019 35
http://files.meetup.com/20182446/IS_Overview.pdf
Internet of Things
36
Internet of Things
37
Our future bathroom?
3/1/2019 IoT Security Analytics; Yair Meidan 38
http://www.mako.co.il/nexter-news/Article-
ed331e883b02651006.htm?sCh=3d385dd2dd5d4110&pId=
1758979194_8168
• Rug
• Electrical measurements through feet
• Toilet seat
• Measurements of blood pressure and 
pulse
• Mirror
• Camera to scan for complexion 
changes, indicating of blood problems
• Speakers in bathtub
• Ultrasonic sound waves, for heart-
echo and internal organs
Smart things?
39
Illustration - iRobot
40
Medical domain…
41
Smartphones
42
Some more examples…Data 
leakage
43
Sony attack, 2014
• Obtained data included personal information about 
Sony employees, e-mails communication, salaries, 
copies of (previously) unreleased Sony films, and more
44
Ashley Madison, 2015
45
Hacking Team, 2015
46
T-Mobile US, 2015
47
48
Supply-chain attack
49
Supply-chain attack
• "The National Institute of Standards and Technology ("NIST") 
has recently released a draft update to the Framework for 
Improving Critical Infrastructure Cybersecurity (also known as 
the Cybersecurity Framework). 
• The updated framework provides new details on managing cyber 
supply chain risks, clarifies key terms, and introduces 
measurement methods for cybersecurity. In this regard, it aims 
to further develop NIST’s voluntary guidance to organizations 
on reducing cybersecurity risks. Several key changes to the 
Cybersecurity Framework are as follows:
• Supply Chain Risk Management: the draft adds cyber supply 
chain risk management considerations throughout the 
Cybersecurity Framework, including a new section on “Buying 
Decisions” and a new category under the Cybersecurity 
Framework Core’s Identify function with five subcategories;”
50
After-market devices (WOOT 
2018)
51
After-market devices
52
IoT Botnets
53
54
Bridging the air-gap
55
56
Adversarial learning
• Due to the large increase in the use of AI 
methods, hackers concluded that 
they too should embrace AI
• Today, hackers are using machine learning to 
find loopholes in other machine learning based 
systems
• Fooling AI systems is not very hard as machine 
learning relies on past cases and assumes that 
future data shares its characteristics
• Hackers abuse this assumption for example, by 
manipulating the input data
57
Academic research on AL
58
Spam detection system
Trained to look for incriminating
content by analyzing the text of 
spam emails
To avoid detection, a spammer can 
obfuscate the content of an email 
by deliberately misspelling 
suspicious words
Adversarial traffic signs
Robust Physical-World Attacks on Deep Learning Visual Classification
Use Deep Learning (CNN) for 
image recognition (traffic signs 
identification) by autonomous 
vehicles 
Adversarial AI can be also applied 
on machine vision systems
“Confused the computer vision 
system into thinking that a stop 
sign was a 45 mph sign, with just a 
few pieces of tape.”
Handwrite recognition system
If the presented check is examined 
by a handwriting recognition 
system, the amount is extracted 
correctly
However, by adding certain 
adversarial noise to the digit nine 
we can fool the system and make it 
think that it is the digit eight.
62
Generic Black-Box Attack Against API-
Calls Based Malware Classifiers
Ishai Rosenberg, Yuval 
Elovici, 
Lior Rokach, Asaf Shabtai
63
Detecting malware by analyzing 
system calls
64
Many of the AI-based anti-viruses examine 
the sequence of system calls (extracted at 
runtime) to characterize an application’s 
behavior
The sequence consists of requests issued by 
an application towards the operating system
Sequences used as features
•Classification based on extracted syscall n-
grams
•Markov model
•ANN – RNNs [Pascanu et al., 2015]; RNN, LSTM, 
GRU and CNN [Athiwaratkun et al., 2017]; RNN, 
combining file access and API calls [Wang et al., 
2016]; feed-forward DNN, combining static 
features and API calls [Huang et al., 2016]
•…
Classifiers performance
65
Attack effectiveness
66
GADGET: Generative Api aDversarial
Generic Example by Transferability framework
• A framework demonstrating an attacker’s ability to create and end-to-end attack using the 
proposed method
• no-op attack – adding API’s which have no effect on the code’s functionality; with valid 
parameters
• Add the adversarial modifications as an input
• The injected code would trace the APIs called so far and each injected API would also call the 
adversarial added API, if needed
67
Malware Binary, 
without GADGET Malware Binary, with GADGET
Advantages:
Requires no access to the 
malware source code
Generic – fit every code
Disadvantages:
API call type-specific
Cyber crime
• Any illegal act involving a computer its system 
or its applications
– Computer used as a tool
– Computerized device is used as a target
– Computer that contain evidences of the crime
• New type of crimes
– Speed, anonymity, geographical, evidence can be 
hidden…
68
Computer & information security
What is computer/information security?
Computer/information security deals with the 
prevention and detection of unauthorised 
actions by users of a computer system
69
False assumptions
• the code is too complex
• why would anyone want to hack me?
70
Computer & information security
• Intrusion detection
• Malware detection
• Authentication/ 
verification
• Database security
• Data leakage 
detection
• Fraud detection
• SPAM/Phishing 
detection
• Privacy
• Social networks 
security
• Web content filtering
• Forensics
• Security analytics
• Malicious insider 
detection
• Awareness
• …
71
Why is it so difficult ?
72
Why is it so difficult ?
Challenges
• Deals with abstract threats which cannot be solved only by 
using mathematical models (encryption/access control)
• Protect against whom? employees, business partners, 
hacker/attacker, customers…
• Intentional vs. accidental
• Complex systems
• Emerging technologies (smart mobile devices, social 
networks, cloud)
• Increasing amounts of data to process
• Protecting data while at-rest, in-motion and in-use
• Regulations
• Competition
• Management
73
Call center 
agent
Marketing
Technical 
support
Finance Operation …
Application Layer
Customer 
data
Bills … …
Data Source
Customer 
support 
application
Accounting 
application
Inventory 
application
Decision 
support 
application
…
Why is it so difficult ?
Challenges
• Electronic traces everywhere  big data
• Identity theft: rather easy (pressure, physical theft, 
man‐in‐the‐middle)
• Eavesdropping
• Social engineering
• Manipulation (integrity attack)
• Internet goes SCADA
• Side channel attacks on credit cards, teller machines, printers, 
smart phones: 
• Protecting Systems:
– Business process risks (e.g. DDoS)
– Business intelligence risks (competitor intrudes)
– Privacy risks
– Externality risks (outside of cyber, e.g. critical infrastructure)
74
Why is it so difficult ?
Challenges
• Many types of threats
• Wide selection of security 
tools and vendors (e.g., 
deployment)
• Hard to prove the benefit
• Must consider potential
attacks
• Super users / admin
• Requires regular monitoring
• Too often an after-thought
75
Security trends
76
And more…
• Potential attacks on the security features 
must be considered (e.g., OpenSSL 
Heartbleed)
• Physical and logical placement needs to be 
determined
• Complex algorithms or protocols may be 
involved
• Attackers only need to find a single 
weakness, the developer needs to find all 
weaknesses
77
Security trends
78
Darknet services or, Malware as a 
Service
79
80
Computer & information security
What is computer/information security?
“Protection afforded to an automated 
information system in order to attain the 
applicable objectives of preserving the 
integrity, availability and confidentiality of 
information system resources (includes 
hardware, software, firmware, 
information/data, and telecommunications).”
[NIST95] The NIST Computer Security Handbook
81
The AIC triad
• Each system\environment\organization can be 
characterized based on these three factors
– Stocks Exchanges systems – will focus more 
on the availability of the systems
– Systems holding medical or customer-related 
data – will focus more on confidentiality
• But is it enough ?
fraud, accountability, authenticity, system does what it was 
planed\designed to do, privacy, non-repudiation
82
Availability Confidentiality
Integrity
Concepts and relationships
83
Terminology
84
Security taxonomy
85
Vulnerabilities, threats and 
attacks
• categories of vulnerabilities
– corrupted (loss of integrity)
– leaky (loss of confidentiality)
– unavailable or very slow (loss of availability)
• threats
– capable of exploiting vulnerabilities
– represent potential security harm to an asset
• attacks (threats carried out)
– passive – does not affect system resources
– active – attempt to alter system resources or affect their 
operation
– insider – initiated by an entity inside the security parameter
– outsider – initiated from outside the perimeter
86
Threats and consequences
• Eavesdropping
• Traffic analysis
• Masquerading / Spoofing / Identity theft - dark side economy
• Man-in-the-Middle (e.g., SSL)
• Manipulation of data
• Intrusion
• Hijacking of hardware (supply chain attack, stealing computer resources)
• Botnets (spam, DDoS, spyware, phishing)
• Social engineering (phishing, Trojan horse…)
• Denial-of-Service
• Redirecting traffic destined for one website to another bogus website (browser of 
victim or DNS server manipulation)
• Passive (hard to detect) vs. active attacks
• Unauthorized disclosure
• Telephony attacks “blue boxing” (or phreaking)
• Near‐field, Zigbee etc.
• Scada attacks
• etc … (will not end and always will come up something new …)
87
Threats and consequences
88
Scope of Computer Security
89
Countermeasures
• Means used to deals with security 
attacks
– prevent
– detect
– recover
• Goal: minimize risk to an asset
• May introduce new vulnerabilities
• Residual vulnerability
90
Examples of threats
Table 1.3    Computer and Network Assets, with Examples of Threats. 91
Passive and Active Attacks
• Passive attacks attempt to learn or make use of information 
from the system but does not affect system resources
– eavesdropping/monitoring transmissions
– difficult to detect
– emphasis is on prevention rather than detection
– two types:
• release of message contents
• traffic analysis
• Active attacks involve modification of the data stream
– goal is to detect them and then recover
– four categories:
• masquerade
• replay
• modification of messages
• denial of service
92
Who are the bad guys?
• Elite hackers
• Virus writers and releasers
• Script kiddies: limited but numerous
• Criminals - growing rapidly
• Employees, Consultants, and Contractors
– White hats: use their hacking ability for defensive purpose
– Ethical hacker: former black hat, white hat, consulting 
company; using his skills for defensive purposes
• Cyberterrorism and Cyberwar
• Hacktivism: hacking for a cause (e.g., social or political 
agenda)
• Virtual gangs: a group of hackers that each one of them 
specializes in different platform
93
Goals of information security
• Identification of the organization’s assets
• Making sure that important assets 
(data\information, hardware, software, 
network) of the organization are protected
• Allowing the organization to run its business 
with as less disruptions as possible
• Continuous and iterative activity of integrating, 
implementing, improving and validating security 
mechanisms to allow running business process
• Complying with information security policies, 
rules, regulations
94
Computer security strategy – how 
do we get it done?
• Specification/policy
– what is the security scheme supposed to do?
– consider the value of the assets; vulnerabilities; 
potential threats and the likelihood of attacks
– “Ease of use versus security”
– “Cost of security versus cost of failure and recovery”
• Risk management
• Implementation/mechanisms
– how does it do it?
– prevention, detection, response, recovery
• Correctness/assurance
– does it really work?
– assurance, evaluation
95
Security plan elements
• Governance
• Policy
• Asset identification & 
classification
• Risk management 
program
• Intelligence program
• Audit & compliance 
program
• Incident management
• Education & awareness 
program
• Technical security 
(systems, 
communication)
• Access control
• Identification and 
Authentication
• Configuration 
management
• Contingency planning
• Monitoring
• Physical security
• Employees/personnel
• Forensics
96
ניהול אבטחת מידע–7799י "ת
קביעת מדיניות אבטחת מידע. 1•
ארגון אבטחת מידע. 2•
סיווג ובקרה של נכסי הארגון. 3•
אבטחת עובדים. 4•
אבטחה פיזית וסביבתית. 5•
ותפעולתקשורת ניהול . 6•
בקרת גישה. 7•
ותחזוקה של מערכותפיתוח . 8•
המשכיות עסקיתניהול . 9•
תאימות.10•
97
Security technologies used
• Implementing 
mature, low cost
solutions
98
Key drivers
• Client requirement
• Legal, regulations
• Potential exposure
• Common practice
• Security vs. privacy
• Budget
• Transparency
99
Who is responsible for security
• Executive management\CEO ?
• IT department\CTO ?
• IT security stuff ?
Everyone! – all employees and stakeholders of 
the organization
100
Who is responsible for security
101
IT department 
and CTO
Security 
function in the 
IT department
Independent 
unit reporting 
to the 
management 
managed by the 
CISO
Role of security in today’s world
• Top management
– Endorse and lead information security
• Chief Information Security Officer (CISO)
– Responsible for the design and implementation of a 
comprehensive security plan
• Information security implementer
– Implement, install, support , maintain security tools
– The “hands-on” function
– Sometime the network administrator is also the IS 
implementer
– Deep understanding in Windows, Linux, databases, network 
security and also in specific products (Symantec, Cisco …)
102
Role of security in today’s world
• Information security architect\engineer
– Design the security solution that should protect the 
organization against its risks
– Instruct the IS implementers
• Information security auditor
– Auditing of security products, processes, policies etc.
• Penetration tester\Ethical Hacker
– Hacking to systems and assets
– Detecting vulnerabilities
• Forensics investigator
103
Designing a security system
• What goals do we want to achieve?
• Does the system focus on the data, operations 
or the users of the system?
• What level should the security system operate 
from? Should it be at the level of hardware, 
operating system or applications package?
• Should it be simple or sophisticated?
• In a distributed system, should the security be 
centralized or spread?
• How do you secure the levels below the level of 
the security system?
104
• Physical measures: CCTV, guard, fences, locks, CD-ROM\USB 
removal, fire alarms, controlling individual access to the 
facility…
• Administrative measures: developing and
publishing policies, standards, procedures
and guidelines, screening and background
checks, awareness, risk assessment, 
audit, training…
• Technical (logical) measures: access
control mechanisms to systems, passwords,
firewalls, anti-virus, IDS, VPNs, configuration 
managements, backup…
Types of security controls and 
solutions
Assets
Technical measures
Administrative
measures
Physical 
measures
105
Categories
Administrative Technical Physical
Directive Policy Warning/ 
instructive banner
Security guard
Deterrent Demotion Audit logs Security guard
Preventive Information 
classification
Encryption / 
access control
Fences
Detective Investigation IDS Motion detectors
Corrective Termination Anti-virus Fire extinguisher
Recovery DRP Backups Rebuild
Compensating Supervision Keystroke dynamic Layered fences
106
Security services
• Authentication
– assuring that a communication is from the source 
that it claims to be from
– must assure that the connection is not interfered 
with by a third party masquerading as one of the 
two legitimate parties
– Data origin authentication
• Access control
– the ability to limit and control the access to host 
systems and applications via communications links
107
Security services
• Nonrepudiation
– prevents either sender or receiver from 
denying a transmitted message
– receiver can prove that the alleged sender 
in fact sent the message
– the sender can prove that the alleged 
receiver in fact received the message
108
Security services
• Data confidentiality
– the protection of transmitted data from 
passive attacks
– protects the traffic flow from analysis
– this requires that an attacker not be able 
to observe the source and destination, 
frequency, length, or other characteristics 
of the traffic on a communications facility
109
Security services
• Data Integrity
– can apply to a stream of messages, a single 
message, or selected fields within a message
– protection against message modification only
– assures that messages are received as sent, 
with no duplication, insertion modification, 
reordering, or replays
– destruction of data is also covered under this 
service
• Availability
– a service that protects a system to ensure its 
availability
110
Assurance and Evaluation
• assurance
– the degree of confidence one has that the 
security measures work as intended to protect 
the system and the information it processes
– encompasses both system design and system 
implementation
• evaluation
– process of examining a computer product or 
system with respect to certain criteria
– involves testing and formal analytic or 
mathematical techniques
111
Social engineering
• Human are usually the weakest link in the 
security chain
• Social engineering is the human side of 
breaking into a corporate network
• Acquisition of sensitive information or 
inappropriate access privileges by an outsider 
based upon inappropriate trust relationships 
with insiders
• The goal is to cone the victim into providing 
valuable information
112
80%-95% of the attacks exploits 
human vulnerabilities
113BGU Cyber Security Research Center
Social engineering
• Human are usually the weakest link in the security chain
• Social engineering is the human side of breaking into a 
corporate network
• Acquisition of sensitive information or inappropriate 
access privileges by an outsider based upon inappropriate 
trust relationships with insiders
• The goal is to cone the victim
into providing valuable information
• Steps
– Information gathering
– Development of relationship
– Exploiting of relationship
– Execution to achieve objective
114
Social engineering - types
• Human-based - person-to-person interaction in order to 
retrieve the desired information
– Impersonation
– Posing as important user
– Third party authorization
– Masquerading
– Dumpster Diving (= Trashing) and shoulder surfing
• Computer-based
– Having computer software that attempts to retrieve desired 
information
– Mail or Instant Messaging (IM) attachments
– Pop up windows
– Websites
– Spam mail
– CD / DVD/ USB …
115
Checkpoint analysis of Gooligan: 1m Google accounts compromised 
(30/11/16)
• The malware code been found in
dozens of legitimate-looking apps
on third-party app stores which 
offer free versions of paid 
application
• Gooligan-infected apps are also 
installed using phishing scams
• After Gooligan is installed  he collect 
data about the device and downloads 
a rootkit that takes advantage of
well-known Android 4 and 5 (old 
versions) exploits
• These exploits still plague many 
devices today because the patches 
were never installed by the user
BGU Cyber Security Research Center 116
Information security
An on going process
• Prevention
• Monitoring and detection
• Response
• Emergency – carry out BCP
• Recovery
• Forensics \ investigation
• Updating
117
Auditing,
Periodic testing
 
</TEXT>
</DOC>
<DOC>
<DOCNO> C:\Dan\UNI\Jarta.Projects\Hackathon\searchEngine\corpus\MoodleFiles\Security\intro\authentication\CompNetSec4_User-Authentication.pdf </DOCNO>
<F P=104> Security </F>
<TEXT>
Computer & Information Security (372-1-460-1)
User authentication
Dept. of Software and Information 
Systems Engineering, Ben-Gurion University
Prof. Yuval Elovici, Dr. Asaf Shabtai
{elovici, shabtaia}@bgu.ac.il
Spring, 2018
Authentication and access control 
requirements
– Same username/password? 
– iPhone’s fingerprint verification?
• Privacy
• Confidentiality
• Reliability
2
Authentication, Authorization, 
Accountability (AAA)
• Authentication
– Identification – who are you? ; specify identifier (username, account number, fb) 
– Verification – can you prove it? (password, PIN code, smartcard, token) 
• Face verification? Fingerprint verification?
• Authorization – ok, this is what you are allowed to do and access! (permissions)
• Auditing and accountability
– tracking and recording the activity of a user so that users can be held accountable for their 
actions
• Different from message authentication in
• message authentication might not happen in real time; 
• User\entity authentication does
• message authentication needs to be repeated for each new message; 
• User\entity authentication authenticates for the whole duration of the session 
(today, even more, for mobile apps, or in the browser)
3
RFC 2828 (Internet Security Glossary)
• RFC 2828 defines user authentication as: 
“The process of verifying an identity claimed by or for 
a system entity.”
– “Entity authentication is a technique designed to let one 
party prove the identity of another party. 
– An entity can be a person, a process, a client, or a server. 
– The entity whose identity needs to be proved is called the 
claimant; 
– The party that tries to prove the identity of the claimant is 
called the verifier.”
4
User Authentication Process
• fundamental building block and primary line of defense
• basis for access control and user accountability
• identification step
– presenting an identifier to the security system
• (username, smartcard, token)
• verification step
– presenting or generating authentication information to the 
system that corroborates the binding between the entity 
and the identifier
5
Authentication Process
• Authentication mechanism
– visible to the user
– e.g., password, fingerprint, smartcard
• Authentication protocol
– Transparent, e.g.:
– Kerberos – Strong authentication for Client server based on 
symmetric encryption
– Extensible Authentication Protocol (EAP) -
authentication framework frequently used in wireless 
networks and point-to-point connections
6
User Authentication
• One way authentication
– One time continues authentication (fb, 
browser, smartphone)
• Mutual authentication
7
?
?
User Authentication
• Something you know
– password, PIN, answers to prearranged questions
• Something you have
– smartcard, electronic keycard, physical key
• Something you are (static)
– Fingerprint, retina, face
• Something you do (dynamic)
– voice pattern, handwriting, typing rhythm (ABV-Moskovitch)
8
Password Authentication
• Widely used line of defense against intruders
– user provides name/login and password
– the system compares the password with the one stored for that 
specified login
– Usually only the Hash Code (SHA) of the passwords are stored
• the user ID:
– determines that the user is authorized to access the system 
(such username exists)
– determines the user’s permissions
– is used in discretionary access control (for instance editing 
permission in dropbox folder through email address)
9
Password Authentication
• How is the password communicated?
– eavesdropping risk
• How is the password stored?
– in the clear? encrypted? hashed?
• How does the system check the password?
• How easy is it to guess the password?
– easy-to-remember passwords tend to be easy to 
guess
– password file is difficult to keep secret
slide 10
Password-based protocols
• Simple username/password (e.g., telnet)
• S/Key
• Challenge-Response
• Kerberos
• …
slide 11
Password Vulnerabilities
• Install sniffer or keylogger
• Run cracking tools on password files
• Specific account attack (guessing against single user)
• Popular password attack (against wide range of IDs)
• Workstation hijacking (unattended logged-in station)
• Session hijacking (using stolen cookie)
• Exploiting user mistakes (multiple password use, writing, share, 
admin)
• Electronic monitoring (eavesdropping to passwords transmitted across 
net)
• Replay attack (replay-repeat passwords transmission)
• Man-in-the-middle attack (double agent with new PSW)
• 8 out of 9 exploits involve password stealing and/or cracking 
(Mitnick’s “Art of Deception”)
– usernames and passwords stored in the clear
– use default password12
Countermeasures
• Controls to prevent unauthorized access to password file
• Intrusion detection measures
• Rapid reissuance of compromised passwords
• Account lockout mechanisms
• Policies to inhibit users from selecting common passwords
• Training in and enforcement of password policies
• Automatic workstation logout
• Policies against similar passwords on network devices13
Dictionary and Brute Force 
Attacks and need in Salt
Use of Hashed Passwords
• Add Salt (random num) :
– duplicate passwords 
cannot be identified
(Different salts)
– increases cracking
effort (factor of 2b)
* With salt hashing all 
the passwords against
all the salts
– nearly impossible to 
identify the same 
passwords of the 
same user across
multiple systems
(Different salts)
15
Use of Hashed Passwords
UNIX Implementation
• original scheme
– password up to 8 printable characters in length 
(converted into 56-bit value using 7bit ASCII code),  
– This 56 bit of the password serves as the key encryption
– 12-bit salt used
– Using crypt(3) that is one way hash function based on DES algorithm
– 64 bit block of zero value +  12 bit salt are first encrypted
– Then the encryption is repeatedly done 25 times
– output translated to 11 character sequence
• now regarded as inadequate
– Strong CPU was able to process over 50M password guesses in 80 min
17
Improved Implementations
much stronger hash/salt 
schemes available for 
Unix
recommended hash 
function is based on 
MD5
• salt of up to 48-bits
•password length is 
unlimited
•produces 128-bit hash
•uses an inner loop with 
1000 iterations to 
achieve slowdown
OpenBSD uses 
Blowfish block cipher 
based hash algorithm 
called Bcrypt
•most secure version of Unix 
hash/salt scheme PSW up 
to 55 characters
•uses 128-bit salt to create     
192-bit hash value
18
Password Cracking
• Dictionary attacks
– use a large dictionary of possible passwords 
and try each against the password file
– each password must be hashed using each salt 
value and then compared to stored hash values
• rainbow table attacks
– pre-compute tables of hash values for all salts
– can be countered by using a sufficiently large 
salt value and a sufficiently large hash length
19
Observed Password Lengths
*Source: study at Purdue university
20
Passwords 
Cracked from 
a Sample Set 
of 13,797 
Accounts
*Computed as the number of matches 
divided by the search size.  The more 
words that need to be tested for a 
match, the lower the cost/benefit ratio.
21
Password File Access Control
• Make available only to privileged users can block 
offline guessing attacks by denying access to 
encrypted passwords
• Shadow password file - a separate file from the 
user IDs where the hashed passwords are kept
• Vulnerabilities
– weakness in the OS that allows access to the file
– accident with permissions making it readable
– users with same password on other systems
– access from backup media
– sniff passwords in network traffic
22
Password Selection Techniques
• User education
• Computer generated - users have trouble 
remembering them
• Reactive password checking - system 
periodically runs its own password cracker 
to find guessable passwords
• Proactive password checking - the system 
checks to see if the password is allowable, 
and if  not, rejects it
23
Proactive Password Checking
• rule enforcement
– specific rules that passwords must adhere to
• password cracker
– compile a large dictionary of passwords not to 
use
• Bloom filter
– used to build a table based on dictionary using 
hashes
– check desired password against this table
24
Bloom Filter
25
Phishing…
slide 26
Images from Anti-Phishing Working Group’s Phishing Archive
slide 27
Images from Anti-Phishing Working Group’s Phishing Archive
The next page requests:
• Name
• Address
• Telephone
• Credit Card Number, Expiration Date, 
Security Code
• PIN
• Account Number
• Personal ID
• Password
slide 28
slide 29
Images from Anti-Phishing Working Group’s Phishing Archive
slide 30
WHOIS 210.104.211.21: 
Location: Korea, Republic Of
Images from Anti-Phishing Working Group’s Phishing Archive
Advanced Phishing Attacks
• Spear-phishing: Improved target selection
• Socially aware attacks
– Mine social relationships from public data
– Phishing email appears to arrive from someone 
known to the victim 
• Context-aware attacks
slide 31
Memory Cards
• can store but do not process data
• the most common is the magnetic stripe card
• can include an internal electronic memory
• can be used alone for physical access (hotel room, ATM)
• provides significantly greater security when combined with a 
password or PIN (credit/debit)
• drawbacks of memory cards include:
– requires a special reader (paypal)
– loss of token prevents access and requires replacement
– user dissatisfaction for using these cards for computer access
32
Smartcards
• Has an embedded micro-processor and I\O port
• Card readers provide the power supply
• Provides authentication services
• Two types: contact and contact-less (using Radio Frequency 
Identification (RFID))
• Can look like calculators, keys, small portable objects
• interface:
– manual interfaces include a keypad and display for interaction
– electronic interfaces communicate with a compatible 
reader/writer
• Attacks on smart cards
– Fault generation - changing input voltage, clock rate, 
temperature fluctuations
– Microprobing - directly tapping into the card’s ROM chips
– Side channel attacks - nonintrusive attacks, measure power or 
frequency emissions33
The smart card chip is embedded into the
plastic card and is not visible. The dimensions 
conform to ISO standard 7816-2.
Smartcard Dimensions
• Read Only Memory (ROM) – card number, holder name…
• Electronically erasable programmable ROM (EEPROM) –
protocols, application data, talk time… 
• Random Access Memory (RAM)
- execution data
34
Smartcards Regulations
• Homeland Security Presidential Directive 12 (HSPD-12): 
Policy for a Common Identification Standard for Federal 
Employees and Contractors
“U.S. policy is to enhance security, increase Government 
efficiency, reduce identity fraud, and protect personal 
privacy by establishing a mandatory, Government-wide 
standard for secure and reliable forms of identification 
issued by the Federal Government to its employees and 
contractors (including contractor employees).”
• Federal Information Processing Standard Publication 
(FIPS PUB) 201-1: Personal Identity Verification (PIV) 
of Federal Employees and Contractors
National Institute of Standards and Technology (NIST)
35
Smartcards
• authentication protocol - categories:
– static 
• user is authenticated to the token
• Then the token authenticates the user with the system.
– dynamic password generator – periodically 
generates a unique password (RSA tokens)
– challenge-response
• The computer generates a challenge (random string of 
numbers)
• The token responses with encryption of the random 
numbers with his private key
36
Tokens - asynchronous 
authentication
• Uses the challenge-response method
• Masquerading attack is possible if the token is shared or 
stolen
• Not vulnerable to eavesdropping, sniffing, replay, or 
password guessing
37
1. request 
access (Bob)
2. Challenge
value (nonce)
4. Enters 
Challenge and PIN
5. Encrypts the 
Challenge and 
presents the one-
time password
3. Present 
Challenge value
6. Enters the one-
time password 7. one-time 
password 8. verify the 
one-time 
password 
Bob
Tokens - synchronous 
authentication
• The token device and the authentication 
servers are synchronized using time or counter
• Time-based
– the token device and authentication server should 
have the same time
– current time,  token ID and a secret (e.g., PIN) are 
used to generate the one-time password
– RSA SecureID time-based tokens
–
• Event-based
– usually, a counter is advanced to the next 
authentication value by pushing a button of the 
token device
38
S/Key Protocol
• Lamport's scheme
• One-time password scheme
• The two sides agree on password (pwd), and choose initial counter 
ctr
• System stores in the passwords file h(h(…(h(pwd)…)=hctr(pwd), ctr
• During the authentication process the system send the ctr and 
requests for hctr-1(pwd)
• If authenticates, the system updates the password file with hctr-
1(pwd), ctr-1
• When the counter is set to zero the user selects a new password
Biometric Authentication
• attempts to authenticate an individual 
based on unique physical characteristics
• based on pattern recognition
• Is technically complex and expensive
when compared to passwords and tokens
• - iPhone finger? security/usability?
41
Biometric Authentication
• Face recognition
– Measures various features in the face such as 
distances between eyes, nose etc.
– Accurate but no well accepted due to privacy issues
• Fingerprint
– Patterns on the tip of a finger
– Sensitive to minor changes (temperature, pressure, 
surface damage)
– Accurate, acceptable by the user
– Some people have no fingerprint,.. Live detection
• Hand geometry and hand topography 
– Shape, size peaks and valleys
– Accurate, acceptable by the user42
Biometric Authentication
• Retina (רשתית)
– Blood vessel patterns
– Very accurate however, sensitive to physical 
condition (diabetes, pregnancy, heart attack); 
perceived as intrusive
• Iris scan (קשתית)
– Patterns in the iris
– Very accurate however, sensitive to physical 
condition (diabetes, pregnancy, heart attack); 
perceived as intrusive
43
Biometric Authentication
• Voice patterns (behavioral)
– Not so accurate
– The person can be recorded; solution – use a 
challenge
• Keystroke dynamics (behavioral)
– Dwell time; flight time
– 2-factor authentication
– Can provide continuous verification
– Cons: Different keyboards, injuries,..
• Signature dynamics
44
Biometrics - parameters to 
consider
• Accuracy
• Intrusiveness
• Cost
• Time to process
45
Operation of a Biometric System
46
Biometric Accuracy
47
Biometrics
• Convert physical attributes to digital data
• Types of biometric authentication methods
– Physiological
– Behavioral
• False Acceptance Rate (FAR)
• False Rejection Rate (FRR)
• Crossover Error Rate (CER)
– Used for comparing products and
setting standards
48
Biometric Measurement Operating 
Characteristic Curves
49
Actual Biometric Measurement 
Operating Characteristic Curves
50
BioMetrics Vulnerabilities
• In WOOT Workshop of Usenix conference 2014 held in San-
Diego it was shown that using Smartphones:
• Fingerprints are not secured at all….
52
Authentication protocol
• Sequence of communications by two or 
more parties to achieve security 
objective(s)
53
A  B: A “Hi, I’m Alice”
B  A: Enter password: “Prove It!”
A  B: $R%&^8! “Here’s the proof”
Authentication protocol
• Sequence of communications by two or 
more parties to achieve security 
objective(s)
• Not like this… (password can be intercepted)
54
A  B: A “Hi, I’m Alice”
B  A: Enter password: “Prove It!”
A  B: $R%&^8! “Here’s the proof”
Attacker model
• Eve can:
– Sees all messages
– Delete, alter, inject and redirect messages
– Initiate new communications
– Reuse messages from past sessions
• Eve cannot:
– Solve “hard” problems
– Guess pseudo-random values (e.g., nonces)
– Get another identity (identity theft)
55
Authentication protocol (1)
• What’s the problem with this?
– The nonce Nb leaks, so it cannot be used to 
secure the session
56
A  B: A “Hi, I’m Alice”
B  A: Enc(Nb,PKa) “Prove It!”
A  B: Nb “Here’s the proof”
Authentication protocol (2)
A  B: A “Hi, I’m Alice”
B  A: Enc(Nb,PKa) “Prove It!”
A  B: Enc(Nb,PKb) “Here’s the proof”
57
Authentication protocol (2)
A  B: A “Hi, I’m Alice”
B  A: Enc(Nb,PKa) “Prove It!”
A  B: Enc(Nb,PKb) “Here’s the proof”
58
• Man-in-the-middle attack:
A  E  B : A B receives “A” 
from E
B  E  A : Enc(Nb,PKa) E uses A to 
decrypt Nb
A  E : Enc(Nb,PKe) Now E has Nb
E  B : Enc(Nb,PKb) E fools B
Authentication protocol (3)
A  B: A “Hi, I’m Alice”
B  A: Enc({B,Nb},PKa) “Prove It!”
A  B: Enc(Nb,PKb) “Here’s the proof”
59
• Does it work now?
A  E B : A “Hi, I’m Alice”
B  E  A : Enc({B,Nb},PKa) A can see that the 
message is not 
from E
Mutual Authentication
38
Attack on Mutual Authentication
Session Hijacking
• Man-in-the-middle attack
• Attacker waits for the authentication 
process to end successfully
• Disconnects the user by sending a 
disconnecting message and continues the 
session
• Solution: use session (symmetric) key
Remote User Authentication
• Authentication over a network, the 
Internet, or a communications link is 
more complex
– additional security threats such as: 
eavesdropping, capturing a password, 
replaying an authentication sequence that 
has been observed
• Generally rely on some form of a 
challenge-response protocol to counter 
threats
63
Password Protocol
• user transmits identity to 
remote host
• host generates a random 
number r (nonce)
• nonce is returned to the user
• host stores a hash code of the 
password
• function in which the password 
hash is one of the arguments
• use of a random number helps 
defend against replay attack in 
which an adversary capturing 
the user’s transmission and 
retransmit it again.64
Token Protocol
• user transmits identity to 
the remote host
• host returns a random 
number and identifiers
• token either stores a static 
passcode or generates a 
one-time random passcode
• user activates passcode by 
entering a password
• password is shared between 
the user and token and does 
not involve the remote host
65
Static Biometric Protocol
• user transmits an ID to the 
host
• host responds with a random 
number and the identifier for 
an encryption
• client system controls 
biometric device on user side
• host decrypts incoming 
message and compares these to 
locally stored values
• host provides authentication by 
comparing the incoming device 
ID to a list of registered 
devices at the host database
66
Dynamic Biometric Protocol
• host provides a random 
sequence and a random 
number as a challenge
• sequence challenge is a 
sequence of numbers, 
characters, or words
• user at client end must then 
vocalize, type, or write the 
sequence to generate a 
biometric signal
• the client side encrypts the 
biometric signal and the 
random number
• host decrypts message and 
generates a comparison67
Authentication Security Issues
• Adversary attempts to achieve user authentication without access to 
the remote host or the intervening communications path (e.g., 
eavesdropping)
• Host attack: Directed at the user file at the host where passwords, 
token passcodes, or biometric templates are stored
• Replay - adversary repeats a previously captured user response
• Client attacks – masquerade a legitimate user and guess passwords.
• Denial-of-service - attempts to disable a user authentication service 
by flooding the service with numerous authentication attempts
• Trojan horse - an application or physical device masquerades as an 
authentic application or device for the purpose of capturing a user 
password, passcode, or biometric
68
Potential 
Attacks, 
Susceptible 
Authenticators
, and Typical 
Defenses
69
Identity Management (IDM)
• Identity management products are used to id, authenticate 
and authorize users in an automated means
• Enforce organization policies
• Authorization creep prevention - the accumulation of access 
rights over time, particularly those that the user does not 
have a need to know
• These products may include
– User account management
– Access controls
– Password management
– Single-Sign-On (SSO)
– Permissions
GSM Authentication
• Subscriber Identity Module (SIM)
• Tamper-resistant
– protected by a PIN code (checked locally by the SIM)
– removable from the terminal
– contains all data specific to the end user which have to 
reside in the Mobile Station (MS):
• IMSI: International Mobile Subscriber Identity (permanent user’s 
identity)
• PIN
• TMSI (Temporary Mobile Subscriber Identity)
• Ki : User’s secret key
• CK : Ciphering key
• List of the last call attempts
• List of preferred operators
• Supplementary service data (abbreviated dialing, last short 
messages received,...)
71
GSM Authentication
• Protected by a Personal Identification 
Number (PIN)
– Can be changed by the Subscriber
– Four digit code
– Usually 3 attempts before phone is blocked
• Bypassing the PIN requires the Pin 
Unblocking Key (PUK)
– 8 digit code
– Set by manufacturer
– Maximum 10 attempts before phone is 
permanently blocked
72
GSM Authentication
• Processor is used for providing access 
to the data and security
• Standard smart card reader and SIM 
access
• Software is required
73
GSM Authentication
• Mobile Station (cell-phone) authenticates to 
mobile operator - public land mobile network 
(PLMN)
• Mobile Station (MS) stores a symmetric 
authentication key ki in the SIM. Same key is 
stored by Home PLMN
• Problem: authentication to Visited PLMN that 
doesn’t have key, without exposing key over air
• Solution:
– first - billing agreement between HPLMN and 
visited PLMN
– second – challenge response protocol
GSM Authentication Components
77
Base Station Controller (BSC) - The network element 
which provides all the control functions and physical links 
between the MSC and BTS. Provides functions such as 
handover, cell configuration data, and control of radio 
frequency (RF) power levels in Base Transceiver Stations.
Base Transceiver Station (BTS) - The network 
element which handles the radio interface to the 
mobile station radio equipment (transceivers and 
antennas) needed to service each cell in the network.
Home Location Register (HLR) - stores data 
about GSM subscribers, including the 
Individual Subscriber Authentication Key 
(Ki) for each SIM
Mobile Services Switching 
Center (MSC) - The network 
element which performs the 
telephony switching 
functions of the GSM 
network
Equipment Identity Register (EIR) - A 
database which contains information about 
the identity of mobile equipment in order 
to prevent calls from stolen, unauthorized, 
or defective mobile stations
Visitor Location Register (VLR) - A database 
which stores temporary information about 
roaming GSM subscribers.
Authentication Center (AUC) - contains 
the IMSI the Subscriber Authentication 
key (Ki), and the defined algorithms for 
encryption
GSM Authentication Components
MS BS
VLR
HLR
AUC
VPLMN HPLMN
GSM Authentication Components
80
GSM Security
• Focused on the protection of the air 
interface
• No protection on the wired part of the 
network (neither for privacy nor for 
confidentiality)
• The visited network has access to all data 
(except the secret key of the end user)
• Few successful attacks have been 
reported:
– faked base stations
– cloning of the SIM card
Kerberos - Overview
• A secured, centralized network authentication 
protocol (N users and M servers/services)
• Providing protection against replay, password 
guessing and session hijacking
• Single-Sign-On (SSO)
• Based on symmetric cryptography
• Developed as part of Project Athena at MIT 
(late 1980s)
• Used in many systems, e.g., Windows 2000 and 
later as default authentication protocol
82
Kerberos - Overview
• Principles: clients (c) and servers (s)
• Key Distribution Center (KDC)
– Authentication Server (AS)
– Ticket Granting Server (TGS)
• Ticket Granting Ticket (TGT)
• The client authenticates to AS using
a long-term shared secret and
receives a TGT
• Later the client can use this TGT
to get additional tickets from TGS
without resorting to using the shared
secret
• These tickets can be used to 
prove authentication to servers
83
Kerberos - Overview
• Timestamp (T)
is used to 
prevent replay
attack
84
Kerberos - Drawback
• Single point of failure
• Requires online trusted third party: Kerberos 
server
• Security depends on tight clock synchronization
• Secret keys are temporarily stored on the 
users’ workstation
• Password file can be exposed; dictionary attack
85
 
</TEXT>
</DOC>
